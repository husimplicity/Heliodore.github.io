<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hulieu">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Hulieu">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Hulieu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Hulieu</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hulieu</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/18/StochasticProcess/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hulieu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hulieu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/18/StochasticProcess/" class="post-title-link" itemprop="url">随机过程论</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-18 12:26:47" itemprop="dateCreated datePublished" datetime="2020-02-18T12:26:47+08:00">2020-02-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-08 18:29:01" itemprop="dateModified" datetime="2020-04-08T18:29:01+08:00">2020-04-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%8C%AB%E7%88%AA%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">猫爪记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%8C%AB%E7%88%AA%E8%AE%B0/Mathematics/" itemprop="url" rel="index"><span itemprop="name">Mathematics</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="条件期望"><a href="#条件期望" class="headerlink" title="条件期望"></a>条件期望</h1><p>给定概率空间$(\Omega,F,P)$，随机变量X，定义随机变量$Y=E(X|F)$如果它满足</p>
<ul>
<li>$Y\in F$</li>
<li>for all $A\in F$，$\int_A XdP = \int_A YdP$</li>
</ul>
<p>显然Y可积且唯一</p>
<p><strong>Radon-Nikodym定理</strong>：测度$\nu &lt;&lt;\mu$，那么存在函数$f\in F$，对所有$A\in F$，</p>
<script type="math/tex; mode=display">
\int_A fd\mu=\nu(A)</script><p>先假设$X\geq 0$然后显然$\nu(A)=\int_A XdP$是测度，所以易证条件期望存在。</p>
<p>几个例子（小污猫说“这几个例子很重要”）</p>
<ul>
<li><p>$X\in F$，那么$E(X|F)=X$</p>
</li>
<li><p>$X$与$F$独立，则$E(X|F)=EX$</p>
</li>
<li><p>$F=\sigma(\Omega_1,\Omega_2,…)$，则$E(X|F)=\frac{E(X;\Omega_i)}{P(\Omega_i)}\:on\:\Omega_i$。所以初等概率论里的条件期望是其一个特例。</p>
</li>
<li><p>$X$，$Y$有联合概率密度$f(x,y)$，则</p>
<script type="math/tex; mode=display">
E(g(X)|Y)=h(Y)=\frac{\int g(x)f(X,y)dx}{\int f(X,y)dx}</script></li>
<li><p>$X$，$Y$独立，$E(\phi(X,Y)|X)=E(\phi(x,Y))$</p>
</li>
</ul>
<p>性质：</p>
<ul>
<li>$E(aX+Y|F)=aE(X|F)+E(Y|F)$</li>
<li>$X\leq Y\Rightarrow E(X|F)\leq E(Y|F)$</li>
<li>$X_n\geq 0$，$X_n\uparrow X$，$EX&lt;\infty$，那么$E(X_n|F)\uparrow E(X|F)$（Levi单调收敛定理）</li>
<li>$X_n\geq 0$，$E(lim_{n\to\infty}X_n|F)\leq lim_{n\to\infty}E(X_n|F)$（Fatou引理，由lim xn=lim inf xk）</li>
<li>$|X_n|&lt;Y&lt;\infty$，$lim_{n\to\infty}X_n=X$，那么$lim_{n\to\infty}E(X_n|F)=E(X|F)$（Lebesgue控制收敛定理）</li>
<li>如果$\phi$凸，则$\phi(E(X|F))\leq E(\phi(X)|F)$（Jensen不等式，直线显然，然后利用直线包络）</li>
<li>$F\subset G$，且$E(X|G)\in F$，那么$E(X|F)=E(X|G)$</li>
<li>$F\subset G$，那么$E(E(X|F)|G)=E(E(X|G)|F)=E(X|F)$（条件期望平滑性）</li>
</ul>
<p>如果$X\in F$且$E|X|\:,\:E|XY|&lt;\infty$，那么$E(XY|F)=XE(Y|F)$。（典型four-step的证明）</p>
<h3 id="正则条件概率："><a href="#正则条件概率：" class="headerlink" title="正则条件概率："></a>正则条件概率：</h3><p>可测映射$X\::\:(\Omega,F)\rightarrow (S,S)$（随机变量）。for X given G，<strong>正则条件分布</strong>$\mu\::\:\Omega\times S\rightarrow [0,1]$满足</p>
<ul>
<li>对每个A，$\omega\rightarrow\mu(\omega,A)$是$P(X\in A|G)$的一个版本</li>
<li>对a.e. $\omega$，$A\rightarrow\mu(\omega,A)$是一个$(S,S)$上的测度。</li>
</ul>
<p>如果$S=\Omega$，X是恒等映射，$\mu$是<strong>正则条件概率</strong>。（此时$\mu(A)=PX^{-1}(A)=P(X\in A)$）</p>
<p>正则条件分布可以<strong>同时计算X的所有函数的条件期望</strong>。</p>
<p>由$E(f(x))=\int_R f(x)dPX^{-1}$可得</p>
<p>定理：$\mu(\omega,A)$是<strong>正则条件分布</strong>，$f:(S,S)\rightarrow (R,R)$，且$E|f(X)|&lt;\infty$，那么f关于测度$\mu(\omega,·)$的积分存在，且</p>
<script type="math/tex; mode=display">
E(f(x)|F)(\omega)=\int \mu(\omega,dx)f(x)\:a.s.</script><p>正则条件分布并不总是存在。但是当$(S,S)$ <strong>is nice</strong>的时候，它总是存在。(定义：<strong>好的可测空间是指标准Borel空间</strong>，即存在从$S\to R$的一一可测映射。若S是<strong>Polish空间（完备+可分）的Borel子集</strong>，S是S上Borel $\sigma$域，那么是一个好的可测空间）</p>
<p>证明：设$\phi:S\to R$是一一可测映射。则$\phi(X):(\Omega,F)\to(R,R)$，那么，$\forall A\in S$</p>
<script type="math/tex; mode=display">
P(X\in A|G)=P(\phi(X)\in\phi(A)|G)\\
=P(Y\in\phi(A)|G)=P(Y\in B|G)\\
(B=\phi(A)\in R)</script><p>然后构造$Y=\phi(x)$关于G的正则条件分布函数$P(Y\leq y|G)$：取除掉一个零测集以外的集合$\Omega_0$使得任意$\omega\in\Omega_0$</p>
<script type="math/tex; mode=display">
G(q,\omega)=P(Y\leq q|G)(\omega)</script><p>然后$F(x,\omega)=inf\{G(q,\omega),q&gt;x\}$。所以$F(x,\omega)$是$P(\phi(X)\leq x|G)$的一个版本。然后得到度量$\nu(\omega,·)$</p>
<script type="math/tex; mode=display">
\nu(w,(-\infty,x])=F(x,\omega)</script><p>然后得到$\mu(\omega,A)=\nu(\omega,\phi(A))$</p>
<p>定理：X，Y在<strong>nice space</strong> (S,S)中取值，$G=\sigma(Y)$，那么存在$\mu\::\:S\times S\rightarrow [0,1]$，</p>
<ul>
<li>对每个A，$\mu(Y(\omega),A)$是$P(X\in A|G)$</li>
<li>对a.e. $\omega$，$A\rightarrow\mu(Y(\omega),A)$是$(S,S)$上的测度</li>
</ul>
<h1 id="鞅过程Martingales"><a href="#鞅过程Martingales" class="headerlink" title="鞅过程Martingales"></a>鞅过程Martingales</h1><p>$F_n$是一个递增的$\sigma$-域序列，如果序列$X_n$满足</p>
<ul>
<li>$E|X_n|&lt;\infty$</li>
<li>$Xn\in F_n$</li>
<li>$E(X_{n+1}|F_n)=x_n$</li>
</ul>
<p>则称$X_n$为<strong>鞅过程</strong>。</p>
<p>如果第三个条件改为$E(X_{n+1}|F_n)\geq(\leq) X_n$，则称为<strong>下鞅（上鞅）</strong></p>
<p>最常见的是线性鞅：$S_n=S_0+\sum_{k=1}^n e_k$，$E(e)=0$。如果$E(e)\leq(\geq)0$，则为上鞅（下鞅）。</p>
<p>定理：鞅过程满足$E(X_n|F_m)=X_m$，$m&lt;n$</p>
<p>定理：凸函数$\phi$，那么$\phi(X_n)$下鞅。即$E(\phi(X_{n+1})|F_n)\geq \phi(E(X_{n+1}|F_n))=\phi(X_n)$。如果$X_n$下鞅，$\phi$增也有此结论。</p>
<p>定义$H_n$为<strong>可预测序列</strong>，即$H_n\in F_{n-1}$。定理：$X_n$上鞅，那么如果$H_n\geq 0$有界，则$(H\cdot X)_n$也是上鞅。显然对下鞅和鞅也有类似结论。</p>
<p>定理：若N是停时，$X_n$上鞅，则$X_{N\wedge n}$也是上鞅。</p>
<h3 id="鞅收敛定理"><a href="#鞅收敛定理" class="headerlink" title="鞅收敛定理"></a>鞅收敛定理</h3><p>$\lim_{n\to\infty}X_n(\omega)$不存在$\Leftrightarrow\lim_{n\to\infty}inf\:X_n(\omega)&lt;\lim_{n\to\infty}sup\:X_n(\omega)$，也等价于存在有理数a,b：</p>
<script type="math/tex; mode=display">
\lim_{n\to\infty}inf\:X_n(\omega)<a<b<\lim_{n\to\infty}sup\:X_n(\omega)</script><p>定义$N_{2k-1}$为第k次下穿a的停时，$N_{2k}$是第k次上穿b的停时。定义$U_n=\{sup\:k|N_{2k}&lt;n\}$为上穿[a,b]的次数。而</p>
<script type="math/tex; mode=display">
\{\lim_{n\to\infty}inf\:X_n(\omega)<a<b<\lim_{n\to\infty}sup\:X_n(\omega)\}\subset \{\lim_{n\to\infty}U_n(\omega)=+\infty\}</script><p>定义$H_m=1_{\bigcup\{N_{2k-1}\leq m\leq N_{2k}\}}$，$W_n=\sum_{m-1}^nH_m(X_m-X_{m-1})$，</p>
<p>（<strong>下鞅上穿不等式</strong>）若$X_n$下鞅，则对a&lt;b，$(b-a)EU_n\leq E(X_n-a)^+-E(X_0-a)^+$（证明：定义$Y_n=a+(X_n-a)^+$，则也是下鞅且上穿次数与$X_n$相等。那么$W_n=\sum_{m=1}^nH_m(Y_m-Y_{m-1})$\geq (b-a)U_n$。又令$K_m=1-H_m$，$V_n=\sum_{m=1}^nK_m(Y_m-Y_{m-1})$。那么$W_n+V_n=Y_n-Y_0$，且$V_n$下鞅，$EV_N\geq EV_0=0 $。所以</p>
<script type="math/tex; mode=display">
E(Y_n-Y_0)=EW_n+EV_n\geq EW_n\geq(b-a)EU_n</script><p> 即得证）</p>
<p>利用上穿不等式，得到</p>
<p>（<strong>下鞅基本收敛定理</strong>） 如果下鞅$X_n$满足$sup\:EX_n^+&lt;\infty$，则$X_n\to X$a.s.，且$E|X|&lt;+\infty$。（证明：$(X_n-a)^+$是下鞅，根据上穿不等式$EU_n\leq E(X_n-a)^+/(b-a)$有界，而根据$U_n$单调上升必有极限$U$，因此</p>
<script type="math/tex; mode=display">
P(\lim_{n\to\infty}inf\:X_n<a<b<\lim_{n\to\infty}sup\:X_n)=0</script><p>所以$X_n$极限a.s.存在。又由于$EX_n\geq EX_0$，$EX_n^-=EX_n^+-EX_n\leq sup\:EX_n^+-EX_0&lt;+\infty$然后由Fatou引理易得$E|X|&lt;+\infty$。）</p>
<p> 定理：若$X_n$非负上鞅，则$\lim X_n=X$a.s.，且$EX\leq EX_0$。（证明：$-X_n$下鞅有界，a.s.收敛到极限X。）</p>
<p><strong>注意：L1收敛并不成立。</strong>一个简单的反例就是$S_0=1$，$P(e_i=-1)=P(e_i=1)=1/2$，N为$S_n=0$的停时，$X_n=S_{n\wedge N}$是鞅。但是由上面的定理可知$X\to 0$a.s.，与$EX_n=1$矛盾。</p>
<h3 id="四个例子"><a href="#四个例子" class="headerlink" title="四个例子"></a>四个例子</h3><h5 id="有界增长"><a href="#有界增长" class="headerlink" title="有界增长"></a>有界增长</h5><p>$X_n$为鞅过程，且$|X_{n+1}-X_n|\leq M&lt;\infty$，那么要么$lim\:X_n$存在且有限，要么$X_n$在正负无穷之间摇摆。(停时$N=inf\{X_n\leq k\}$，那么$x_{n\wedge N}+k+M$a.s.收敛)</p>
<p>（Doob分解）下鞅$X_n$可以写成$X_n=M_n+A_n$。其中$M_n$是鞅过程，$A_n$是可预测序列。(令$A_n-A_{n-1}=E(X_n|F_{n-1})-X_{n-1}$)</p>
<p>（第二Borel-Cantelli引理）$A_n\in F_n$，那么</p>
<script type="math/tex; mode=display">
\{A_n\:i.o.\}=\{\sum_{n=1}^\infty P(A_n|F_{n-1})=\infty\}</script><p>（第二B-C引理是第一引理的推广，去掉了独立性要求）</p>
<p>证明：由Doob分解可得$M_n=\sum_{m=1}^n 1_{A_m}-P(A_m|F_{m-1})$是有界增长的鞅过程。</p>
<h5 id="Polya’s-Urn-Scheme"><a href="#Polya’s-Urn-Scheme" class="headerlink" title="Polya’s Urn Scheme"></a>Polya’s Urn Scheme</h5><p>坛子模型：坛子里有r个红球、g个绿球，每次取出一个并放进与之同色的c+1个球。n次抽取后绿球比例$X_n$是鞅。</p>
<p>如果r=g=c=1，可得$P(X_n=\frac{k}{n+2})=\frac{1}{n+1}$。</p>
<p>实际上，$X_\infty$有参数为$g/c$和$r/c$的beta分布：</p>
<script type="math/tex; mode=display">
\frac{\Gamma((g+r)/c)}{\Gamma(g/c)\Gamma(r/c)}x^{(g/c)-1}(1-x)^{(r/c)-1}</script><h5 id="R-N微分"><a href="#R-N微分" class="headerlink" title="R-N微分"></a>R-N微分</h5><p>有限测度$\mu$，$\nu$，上升的$\sigma-$域$F_n$，定义$\mu_n=\mu|F_n$，$\nu_n=\nu|F_n$。</p>
<p>定理：若$\mu_n&lt;&lt;\nu_n$，定义$X_n=\frac{d\mu_n}{d\nu_n}$，令$X=\lim_{n\to\infty}sup\:X_n$，则</p>
<script type="math/tex; mode=display">
\mu(A)=\int_AXd\nu+\mu(A\cap\{X=+\infty\})</script><p>证明：根据定义，$A\in F_n$，则$\mu(A)=\int_AX_nd\nu$。$X_n$是非负鞅，所以$X_n\to X$a.s.。又令$\rho=(\mu+\nu)/2$，$\rho_n=\rho|F_n$，$Y_n=\frac{d\mu_n}{d\rho_n}$，$Z_n=\frac{d\nu_n}{d\rho_n}$。显然$Y_n$和%Z_n$都是非负鞅，且$Y_n+Z_n=2$a.s.。所以有$Y_n\to Y$，$Z_n\to Z$。记$Y=\frac{d\mu}{d\rho}$，$Z=\frac{d\nu}{d\rho}$。那么对$A\in F_n$，则由有界收敛</p>
<script type="math/tex; mode=display">
\mu(A)=\mu_n(A)=\int_AY_nd\rho\to\int_AYd\rho</script><p>$X_n=Y_n/Z_n$a.s.，而$Y+Z=2$a.s.，且$\rho(Y=0,Z=0)=0$。所以$X=Y/Z$,$\rho-$a.s.。</p>
<p>令$W=\frac{1}{Z}1_{\{Z&gt;0\}}$所以$1=WZ+1_{\{Z=0\}}$。所以可得</p>
<script type="math/tex; mode=display">
\mu(A)=\int_AYd\rho=\int_AYWZd\rho+\int_AY1_{\{Z=0\}}d\rho</script><p>马上得证（第二部分由$\{Z=0\}=\{X=\infty\}$得到）。</p>
<p>由此推出<strong>Kakutani关于无穷乘积测度的二分法</strong>：$\mu$，$\nu$都是$(R^N,R^N)$上的概率测度，$e_n$独立，令$F_n(x)=\mu(e_n\leq x)$，$G_n(x)=\nu(e_n\leq x)$。</p>
<p>$\lambda_{F_n}&lt;&lt;\lambda_{G_n}$，令$q_n=\frac{d\lambda_{F_n}}{d\lambda_{G_n}}$。令$F_n=\sigma(e_m,m\leq n)$，$X_n=\frac{d\mu_n}{d\nu_n}=\prod q_n$。根据上面的定理，$X_n\to X$ $\nu-$a.s.，所以根据Kolmogorov 0-1律，$\nu(X=0)\in\{0,1\}$。因而$\mu&lt;&lt;\nu$或者两者正交。</p>
<p><strong>定理：$\mu\sim\nu$或者两者正交，根据$\prod\int\sqrt{q_m}dG_m$&gt;0或=0进行判断</strong></p>
<p>证明：先证无穷乘积是有定义的。</p>
<p>如果$\prod\int\sqrt{q_m}dG_m=0$，那么$\int X_n^{1/2}d\nu\to 0$。而$\int X^{1/2}d\nu\leq\lim inf\:\int X_n^{1/2}d\nu =0$。所以$\nu(X=0)=1$，$\mu$和$\nu$相互独立。</p>
<p>反之，令$Y_n=X_n^{1/2}$，则$E(X_n)=E(Y_n^2)=1$。下证$Y_n$L2-基本列：$E(Y_{n+k}-Y_n)^2=2(1-\prod_{n+1}^{n+k} \int \sqrt{q_m}dG_m\to 0$。$E|X_{n+k}-X_n|\leq 2(E(Y_{n+k}-Y_n)^2)^{1/2}\to 0$，故而$X_n$是L1-基本列，$X_n\to X$。所以对$A\in F_n$</p>
<script type="math/tex; mode=display">
\mu(A)=\mu_n(A)=\int_AX_nd\nu_n=\int_AX_nd\nu\to\int_AXd\nu</script><p>有$\pi-\lambda$方法，A可以扩展到$R^N$，故而$\mu&lt;&lt;\nu$。</p>
<p>$EX=\lim EX_n=1$，所以$\nu(X=0)<1$，故而$\nu(X=0)=0$，$\nu(X>0)=1$，$\mu\sim\nu$。</p>
<h5 id="分支过程"><a href="#分支过程" class="headerlink" title="分支过程"></a>分支过程</h5><p>$e_n$独立非负，定义$Z_n$，满足$Z_0=1$以及</p>
<script type="math/tex; mode=display">
Z_{n+1}=\left\{\begin{array}.e_1^{n+1}+...+e_{Z_n}^{n+1}\:if\:Z_n>0\\0\:otherwise\end{array} \right.</script><p>也叫做Galtom-Watson过程，描述繁衍过程。</p>
<p><em>引理：令$\mu=E(e_i^n)$，则$\{Z_n/\mu^n\}$是鞅过程 。</em></p>
<p>定理：若$\mu&lt;1$，则对所有足够大的n，$Z_n=0$。因此$Z_n/\mu^n\to^{a.s.}0$</p>
<p>(由$E(Z_n/\mu^n)=E(Z_0)=1$得$E(Z_n)=\mu^n\to 0$可得)</p>
<p>定理：若$\mu=1$且$P(e_i^m=1)&lt;1$，那么对所有足够大的n，$Z_n=0$。</p>
<p>（证明从$P(Z_n=k,n\geq N)=0$入手）</p>
<p>定理：若$\mu&gt;1$，$P(Z_n&gt;0,\forall n)&gt;0$</p>
<p>定理：(Kesten-Stigum)</p>
<script type="math/tex; mode=display">
P(W=\lim \frac{Z_n}{\mu^n}>0)>0\Leftrightarrow\sum P_kkln(k)<+\infty</script><h3 id="Doob不等式-以及LP收敛"><a href="#Doob不等式-以及LP收敛" class="headerlink" title="Doob不等式(以及LP收敛)"></a>Doob不等式(以及LP收敛)</h3><p>定理：设$X_n$下鞅，N有界停时，$P(N\leq k)=1$，那么$EX_0\leq EX_N\leq EX_k$。</p>
<p>证明：$X_n$和$X_{N\wedge n}$下鞅，$Y_n=X_n-X_{N\wedge n}$下鞅，$EY_0\leq EY_k$得到$EX_N\leq EX_k$。</p>
<p>(反例：当N不是有界的时候，不一定成立，考虑SRW，$S_0=1$，停时N为0的首达时，此时$ES_N=0$。)</p>
<p><strong>(Doob不等式)</strong>$X_m$下鞅，令$\bar{X_n}=\max_{0\leq m\leq n}X_m^+$，$A=\{\bar{X_n}\geq\lambda\}$，那么</p>
<script type="math/tex; mode=display">
\lambda P(A)\leq EX_n1_A\leq EX_n^+</script><p>证明：令$N=\inf\{m\geq 0, X_m\geq\lambda\}\wedge n$，在A上$X_N\geq\lambda$，所以$X_N1_A\geq \lambda 1_A$，$\lambda P(A)\leq EX_N1_A$，根据$A^C$上$N=n$，$EX_N1_A\leq EX_n1_A$。右边不等号显然。</p>
<p><strong>（LP不等式）</strong>下鞅$X_n$，p&gt;1，那么</p>
<script type="math/tex; mode=display">
E(\bar{X_n})^p\leq(\frac{p}{p-1})^pE(X_n^+)^p</script><p>特别的，若$Y_n$是鞅过程，$Y_n^*=\max|Y_m|$，那么</p>
<script type="math/tex; mode=display">
E(Y_n^*)^p\leq (\frac{p}{p-1})^pE|Y_n|^p</script><p>证明：$E(X_n^+)^p=+\infty$则显然成立。下设$E(X_n+)^p&lt;+\infty$，考虑$\bar{X_n}\wedge M$，所以</p>
<script type="math/tex; mode=display">
E(\bar{X_n}\wedge M)^p=\int_0^\infty p\lambda^{p-1}P(\bar{X_n}\wedge M\geq\lambda)d\lambda\\
\leq\int_0^\infty p\lambda^{p-1}(\lambda^{-1}EX_n^+1_{\{\bar{X_n}\wedge M\}\geq\lambda})d\lambda\\
=\int X_n^+\int_0^{\bar{X_n}\wedge M}p\lambda^{p-2}d\lambda dp\\
=\frac{p}{p-1}\int X_n^+(\bar{X_n}\wedge M)^{p-1}dp\\
\leq\frac{p}{p-1}(E(X_n^+)^p)^{1/p}(E(\bar{X_n}\wedge M)^p)^{(p-1)/p}</script><p>移项并令$M\to+\infty$由单调收敛定理可得证。</p>
<p><strong>（LP收敛定理）</strong>若$X_n$鞅，满足$sup\:E|X_n|^p&lt;+\infty$，$p&gt;1$，那么</p>
<script type="math/tex; mode=display">
X_n\to^{a.s.}X,\:X_n\to^{LP}X</script><p><strong>（鞅增量正交性）</strong>若$X_n$鞅，$EX_n^2&lt;\infty$，若$Y\in F_m$，$EY^2&lt;\infty$，那么$E(X_n-X_m)Y=0$。</p>
<p><strong>（条件方差公式）</strong>若$X_n$鞅，$EX_n^2&lt;\infty$，则$E((X_n-X_m)^2|F_m)=E(X_n^2|F_m)-X_m^2$。</p>
<h5 id="平方可积鞅"><a href="#平方可积鞅" class="headerlink" title="平方可积鞅"></a>平方可积鞅</h5><p>$X_n$鞅，$X_0=0$，且$EX_n^2&lt;+\infty$，$X_n^2$下鞅，因而可以Doob分解为$X_n=M_n+A_n$，$M_n$鞅，而$A_n$非降。定义$A_\infty=\lim_{n\to\infty}A_n$。</p>
<script type="math/tex; mode=display">
A_n=\sum_{m=1}^nE((X_m-X_{m-1})^2|F_{m-1})</script><p>定理：$E\sup_{n\geq 0}|X_n|^2\leq 4 EA_\infty$（由LP不等式和单调收敛定理即得）</p>
<p>定理：在$\{A_\infty&lt;\infty\}上$\lim_{n\to\infty}X_n$a.s.存在有限。</p>
<p>证明：取停时$N=\inf\{n\geq 0,\:A_{n+1}&gt;a^2\}$，所以$X_{N\wedge n}$鞅。根据LP收敛定律，$X_{N\wedge n}$极限存在有限。所以在$\{A_\infty\leq a^2\}上$N=+\infty$，然后取并可得。</p>
<p>定理：设$f:[0,+\infty)\to [1,+\infty)$非降且$\int_0^\infty \frac{1}{f^2(t)}dt&lt;+\infty$，则在$\{A_\infty=\infty\}$上$\frac{X_n}{f(A_n)}\to^{a.s.}0$</p>
<p>证明：$H_n=\frac{1}{f(A_m)}$可料有界，则$Y_n=\sum_{m=1}^nH_m(X_m-X_{m-1})$鞅。分解$Y_n^2=N_n+B_n$，可证$B_\infty&lt;+\infty$，$Y_n\to^{a.s.}T_\infty$有限，由Kronecker引理得证。</p>
<p>定理（第二Borel-Cantelli定理）：$P_n=P(B_n|F_{n-1})$，那么在$\{\sum_{n=1}^\infty P_n=\infty\}$上</p>
<script type="math/tex; mode=display">
\frac{\sum_{m=1}^n1_{B_m}}{\sum_{m=1}^nP_m}\to^{a.s.}1</script><p>证明：定义$X_n=\sum_{m=1}^n1_{B_m}-\sum_{m=1}^nP_m$，定义$f(t)=t\vee 1$，由上可得。</p>
<h5 id="一致可积L1收敛"><a href="#一致可积L1收敛" class="headerlink" title="一致可积L1收敛"></a>一致可积L1收敛</h5><p>一致可积$\{X_i,\:i\in I\}$满足</p>
<script type="math/tex; mode=display">
\lim_{M\to\infty}\sup E|X_i|1_{|X_i|>M}=0</script><p>（一致）绝对连续$\{X_i,\:i\in I\}$满足</p>
<script type="math/tex; mode=display">
\lim_{p(A)\to 0}\sup E|X_i|1_A=0</script><p><u>一致可积当且仅当绝对连续+L1有界</u></p>
<p>定理：$X\in L1(\Omega,F_0,P)$，那么$\{E(X|F),\:F是子\sigma-域\}$一致可积</p>
<p>定理：若$X_n\to^P X$则下列叙述等价</p>
<ul>
<li>$\{X_n\}$一致可积</li>
<li>$X_n\to{L1}X$</li>
<li>$E|X_n|\to E|X|&lt;+\infty$</li>
</ul>
<p>证明：$(1)\Rightarrow (2)$：构造辅助函数$\phi_M(x)=trunc(x, -M, M)$。$(2)\Rightarrow (3)$：显然。$(3)\Rightarrow (1)$：构造辅助函数</p>
<script type="math/tex; mode=display">
\phi_M(x)=\left\{\begin{align}&x,&x\in[0,M-1]\\&-(M-1)(x-M),&x\in[M-1,M]\\&0,&x\in[M,+\infty)\end{align} \right.</script><p>定理：设$p\in (0,+\infty)$，$\{X_n\}\subset LP(\Omega, F, p)$，随机变量$X_n\to^P X$那么下列叙述等价</p>
<ul>
<li>$\{|X_n|^p\}一致可积</li>
<li>$X\in LP$，$X_n\to^{LP}X$</li>
<li>$X\in LP$，$E|X_n|^p\to E|X|^p$</li>
</ul>
<p>定理：对下鞅$\{X_n\}$，下列叙述等价</p>
<ul>
<li>$\{X_n\}$一致可积</li>
<li>$X_n\to ^{a.s.}X$，且$X_n\to^{L1}X$</li>
<li>$X_n\to^{L1}X$</li>
</ul>
<p>引理：$X_n\to^{L1}X$，那么$\forall A$，$EX_n1_A\to EX1_A$</p>
<p>引理：若鞅$\{X_n\}$满足$X_n\to^{L1}X$，那么$X_n=E(X|F_n)$</p>
<p>定理：对鞅$\{X_n\}$，下列叙述等价</p>
<ul>
<li>$\{X_n\}$一致可积</li>
<li>$X_n\to ^{a.s.}X$，且$X_n\to^{L1}X$</li>
<li>$X_n\to^{L1}X$</li>
<li>存在可积随机变量X，$X_n=E(X|F_n)$</li>
</ul>
<p>定理：若$\sigma$域流$F_n\uparrow F_\infty$，$F_\infty=\sigma(\bigcup F_n)$，随机变量X满足$E|X|&lt;+\infty$，那么$E(X|F_n)\to^{a.s.,L1} E(X|F_\infty)$。</p>
<p>证明：定义$Y_n=E(X|F_n)$是鞅过程。通过典型方法可得$EX1_A=EY_\infty 1_A$，因而$Y_n\to Y_\infty$。</p>
<p>定理（Levy 0-1律）：若$F_n\uparrow F_\infty$，$A\in F_\infty$，那么$E(1_A|F_n)\to^{a.s.}1_A(n\to\infty)$</p>
<p>特例：独立随机变量$X_n$，$A\in\tau(尾\sigma 代数)$，则$E(1_A|F_n)=E1_A=P(A)$。（$\tau=\bigcap_{n\geq 1}\sigma(X_{n+1},…)$）此时即为Kolmogorov 0-1律。</p>
<p>定理（条件期望控制收敛）：$Y_n\to^{a.s.}Y$，$|Y_n|\leq Z$，$EZ&lt;+\infty$，$F_n\uparrow F$，那么$E(Y_n|F_n)\to^{a.s.}E(Y|F_\infty)$</p>
<p>证明：</p>
<script type="math/tex; mode=display">
|E(Y_n|F_n)-E(Y|F_\infty)|\leq |E(Y_n|F_n)-E(Y|F_n)|+|E(Y|F_n)-E(Y|F_\infty)|</script><p>后一部分易证。为证明前一部分，令$W_N=\sup\{|Y_n-Y_m|,n,m\geq N\}$单调收敛可证。</p>
<h3 id="倒向鞅"><a href="#倒向鞅" class="headerlink" title="倒向鞅"></a>倒向鞅</h3><p>鞅$\{X_n:n\leq 0\}$称为倒向鞅，定义$F_{-\infty}=\bigcap F_n$</p>
<p>定理：$X_{-\infty}=\lim_{n\to -\infty}X_n$a.s.存在且L1收敛</p>
<p>证明：记$U_n[a,b]$为$X_{-n}$上穿$[a,b]$的次数，根据上穿不等式，$(b-a)EU_n\leq E(X_0-a)^+$，根据单调收敛定理，$U_\infty[a,b]&lt;+\infty$。所以$X_{-n}$的极限a.s.存在。 然后根据一致可积得到L1收敛。</p>
<p>定理：$\{X_n\}$倒向鞅，则</p>
<script type="math/tex; mode=display">
X_{-\infty}=E(X_0|F_{-\infty})</script><p>证明：先证$X_{-\infty}\in F_{-\infty}$，然后证明条件概率。</p>
<p>定理：若$F_n\downarrow F_{-\infty}$且$E|Y|&lt;+\infty$，那么</p>
<script type="math/tex; mode=display">
\lim_{n\to-\infty}E(Y|F_n)=E(Y|F_{-\infty}),a.s.,L1</script><p>令$A_n(\omega)=\omega_n$</p>
<p>如果单+满的映射$\pi:N\to N$，使得仅对有限个i，有$\pi(i)=i$，则称$\pi$为<strong>有限置换</strong>。定义$(\pi\omega)_i=\omega_{\pi(i)}$。若对任意有限置换$\pi$，$\pi^{-1}A=A$，则称A为<strong>可置换集合</strong>。$\{A|A可置换\}$构成$\sigma-$域，即为E。</p>
<p>例：$(S,S)=(R,R)$，$S_n(\omega)=\sum_{i=1}^nX_i(\omega)$，那么</p>
<ul>
<li>$\{\omega|S_n(\omega)\in B\}$是可置换的，对$\forall B$Borel</li>
<li>任意正常数列$C_n$，$\{\omega|\bar{\lim}S_n(\omega)/C_n\geq 1\}$可置换</li>
<li>任意$A\in \tau$可换，则$\tau\subset E$</li>
</ul>
<p>$E_n=\{\A|\forall 有限置换\pi s.t.\pi(n+k)=n+k有\pi^{-1}A=A}$，$E=\bigcap E_n$</p>
<p>定理（Hewitt-Savage 0-1律）：若$X_n$独立同分布，则任意$A\in E$，$P(A)=0或1$。</p>
<p>证明：引理：若$X_n$独立同分布，$\phi:R^k\to R$，令$A_n(\phi)=\frac{1}{A_n^k}\sum\phi(X_{i_1},…,X_{i_k})$其中$A_n^k=\frac{n!}{(n-k)!}$。若$\phi$有界可测，则$A_n(\phi)\to E\phi(X_1,…,X_k)$a.s.。</p>
<p>引理的证明：$A_n(\phi)\in E_n$，$A_n(\phi)=E(\phi(X_1,…,X_k)|E_n)$，令$F_{<em>**</em>-m}=E_m$，所以$E(\phi(X_1,…,X_k)|E_n)\to{a.s.L1}E(\phi(X_1,…,X_k)|E)$</p>
<p>通过引理可知$E(\phi(X_1,…,X_k)|E)=E\phi(X_1,…,X_k)$，所以E与$\sigma(X_1,…,X_k)$独立，所以E与F独立。又由$E\subset F$可证。</p>
<p>引理：若$EX^2&lt;\infty$，$E(X|G)\in F$，X和F独立，则$E(X|G)=EX$。</p>
<p>例：（强大数律）：$e_n$独立同分布，$E|e_1|&lt;+\infty$，令$X_{-n}=S_n/n$。$F_{-n}=\sigma(S_n,…)$，可证$\{X_{-n},F_{-n}\}$倒向鞅。因而$X_{-n}\to{a.s.L1}E(X_{-1}|F_{-\infty})$。由于$F_{-n}\subset E_n$，所以$F_{-\infty}\subset E$，由H-S 0-1律，$E(X_{-1}|F_{-\infty})=EX_{-1}$</p>
<p>例：（选票定理）设$e_n$非负整数，$G=\{S_j&lt;j\}$，则$P(G|S_n)=(1-\frac{S_n}{n})^+$</p>
<h3 id="停时定理"><a href="#停时定理" class="headerlink" title="停时定理"></a>停时定理</h3><p>问题：若$X_n$下鞅，任意停时$M\geq N$，什么条件下$E(X_M|F_N)\geq X_N$，$X_M\geq X_N$？</p>
<p>定理：若$X_n$下鞅一致可积，则对停时N，则$X_{N\wedge n}$一致可积。（由下鞅基本收敛定理，$X_{n\wedge N}\to^{a.s.}X_N$，易证）</p>
<p>定理：对独立同分布的随机变量$X_n$和非负整数N，s.t. $E|X_N|&lt;+\infty。如果$\{|X_n|1_{N&gt;n}\}$一致可积，那么$\{X_{N\wedge n\}$一致可积。若还有$X_n$下鞅，停时$N&lt;+\infty$，则$EX_0\leq X_N$。</p>
<p>定理：若$X_n$下鞅一致可积，任意停时$N\leq +\infty$，有$EX_0\leq EX_N\leq EX_\infty$。</p>
<p>定理：若$X_n$非负上鞅，停时$N&lt;+\infty$，则$EX_0\geq EX_N$</p>
<p>定理：$X_n$下鞅，$E(|X_{n+1}-X_n||F_n)\leq B$，那么对任意停时$EN&lt;+\infty$，有$\{X_{N\wedge n}\}$一致可积，从而$EX_0\leq EX_N$。</p>
<p>定理（Wald等式）：$e_n$独立同分布，停时N有限，则$ES_N=EeEN$</p>
<p>证明：$S_n-nEe$是鞅，由上面的定理可证。</p>
<p>定理（Doob可选停止定理）：若$L\leq M$是停时，$Y_n\in F_n$，$\{Y_{M\wedge n}\}$一致可积，下鞅，则$EY_L\leq EY_M$，$Y_L\leq E(Y_M|F_L)$。其中$F_L=\{\A\in F|A\cap \{L=n\}\in F_n}$</p>
<p>证明：令$X_n=Y_{M\wedge n}$，则$EX_N\leq EX_\infty=EY_M$，取N=L，则$EY_L\leq EY_M$。对任意A，N在A上取L，否则取M，则N为停时，$EY_N\leq EY_M$，所以$EY_L1_A\leq EY_M1_A=E(E(Y_M1_A|F_L))$。令$A_n=\{Y_L-E(Y_M|F_L)&gt;1/n\}$，所以$1/nP(A_n)\leq 0$</p>
<p>例：随机游动，$\mu=Ee$有限，则$S_n-n\mu$鞅。这里设$\mu=0$，$Ee^2=\sigma^2&lt;+\infty$。则$S_n^2-n\sigma^2$也是鞅。</p>
<p>（简单对称随机游动）$P(e=1)=P(e=-1)=1/2$，$S_0=x\in(a,b)$，停时N为S首次出区间(a,b)的时间。则$P(S_N=a)=\frac{b-x}{b-a}$，$E_xN=(x-a)(b-x)$</p>
<p>(非对称简单随机游动)$P(e=1)=p$，$P(e=-1)=q=1-p$。设$0<p<1$，$\phi(y)=(\frac{1-p}{p})^y$，则$\phi(S_n)$鞅。令$T_Z=\inf\{S_n=z\}$，$P_x(T_a<T_b)=\frac{\phi(b)-\phi(x)}{\phi(b)-\phi(a)}$。设$1/2<p<1$，$a<0$，则$P_0(\inf S_n\leq a)=P_0(T_a<+\infty)=()(1-p)/p)^{-a}。$b>0$，则$P_0(T_b&lt;+\infty)=1$，$E_0T_b=b/(2p-1)$</p>
<h1 id="遍历定理"><a href="#遍历定理" class="headerlink" title="遍历定理"></a>遍历定理</h1><p>如果r.v.s. $X_n$使得$\{X_n\}$和$\{X_{n+k\}$同分布称为<strong>（严）平稳随机变量序列</strong>。</p>
<p><strong>Birkhoff遍历定理</strong>：若$f:R\to R$可测，$E|f(x_n)|&lt;+\infty$，则</p>
<script type="math/tex; mode=display">
\lim_{n\to\infty}\frac1n\sum_{m=0}^{n-1}f(X_m)</script><p>a.s.存在。</p>
<p>若$\{X_n\}$遍历，则极限为$f(X_0)$</p>
<p>例子：iid序列、随机游动、马氏链</p>
<p>这里<strong>马氏链</strong>定义为任意$B\in S$，$P(X_{n+1}\in B|F_n)=P(X_{n+1}\in B|X_n)$</p>
<p><strong>转移概率函数</strong>$p:S\times S\to[0,1]$满足：</p>
<ul>
<li>任意$x\in S$，$A\to p(x,A)$是一个概率测度</li>
<li>任意$A\in S$，$x\to p(x,A)$可测</li>
</ul>
<p>对马氏链$X_n$，定义$p_n(x,A)=P(X_{n+1}\in A|X_n=x)$，则$P(X_{n+1}\in A|F_n)=p_n(X_n,A)$。若正则条件分布存在，则$p_n(x,A)$是转移概率。若$p_n(x,A)$不依赖于n，则称$X_n$时齐。特别的，当S可数集时，$p_n(i,j)$构成转移概率矩阵。</p>
<p>如果可测映射$\phi$满足对任意A，$P(\phi^{-1}A)=P(A)$，则称$\phi$<strong>保测映射</strong>。$X_n(\omega)=X(\phi^n\omega)$是平稳序列。</p>
<p>若$Y_n$平稳序列，取值于nice space，可构造概率测度p，使得</p>
<script type="math/tex; mode=display">
P(\omega\in S^N,(\omega_0,\omega_1,...,\omega_n)\in B)=P(B\times\prod_{i=n+1}^\infty S)=\bar{P}((Y_0,Y_1,...,Y_n)\in B)</script><p>（Kolmogorov相容性定理）令$X_n(\omega)=\omega_n$，则$X_n$与$Y_n$同分布。（可以构造推移算子，可以证明这个算子是保测映射）</p>
<p>保测映射$\phi$对A，满足$P(A\Delta \phi^{-1}A)=0$，称A为<strong>不变集</strong>。若$A=\phi^{-1}A$，称A为<strong>强不变集</strong>。若任意不变集有$P(A)=0$或$1$，则称$\phi$<strong>遍历（ergodic）</strong>。</p>
<p>定义$I=\{A|\phi^{-1}A=A,a.s.\}$，称为<strong>不变$\sigma$域</strong>，则$\phi 遍历\Leftrightarrow I 平凡$</p>
<p>时齐马氏链$X_n$状态空间S可数，平稳分布$\pi$满足对任意状态$\pi(x)&gt;0$（正常返），那么$X_n遍历\Leftrightarrow X_n不可约$。</p>
<p>证明：必要性：反证，可约推出不遍历。充分性：任何不变集A满足，$1_A\theta_n=1_A$，P(A)为0或1，I平凡。</p>
<p><strong>Birkhoff个别遍历定理</strong>：保测变换$\phi$，X期望有限，则</p>
<script type="math/tex; mode=display">
\frac1n \sum_{k=0}^{n-1}X(\phi^k\omega)\to^{a.s.L1}E(X|I)</script><p>若$\phi$遍历，则$E(X|I)=EX$。</p>
<p>引理（极大遍历定理）：令$X_r(\omega)=X(\phi^r\omega)$，$S_k(\omega)=\sum_{r=0}^{k-1}X_r(\omega)$，$M_k(\omega)=\max(0,S_1(\omega),…,S_k(\omega))$，则</p>
<script type="math/tex; mode=display">
EX1_{\{M_k>0\}}\geq 0</script><p>引理的证明：$X(\omega)\geq S_{j+1}(\omega)-M_k(\phi(\omega))$ 对任意$j\leq k$。所以$X(\omega)\geq \max S_{j+1}(\omega)-M_k(\phi(\omega))$。那么$EX1_{\{M_k&gt;0\}}\geq \int_{\{M_k&gt;0\}}(M_k(\omega)-M_k(\phi(\omega)))dP=0$。</p>
<p>遍历定理的证明：不妨设$E(X|I)=0$，只需证</p>
<script type="math/tex; mode=display">
\sup\lim_{n\to\infty}\frac1n S_n(\omega)\leq 0</script><p>令$D=\{\omega|\sup\lim_{n\to\infty}\frac1n S_n(\omega)&gt;\epsilon\}$。令$X^*(\omega)=(X(\omega)-\epsilon)1_D(\omega)$，如此定义$S_n^*(\omega)$和$M_n^*(\omega)$。定义$F_n=\{M_n^*&gt;0\}$，F定义为它们的并集。</p>
<p>那么F=D。由极大遍历定理，$EX^*1_{F_n}\geq 0$，$E|X^*|\leq E|X|+\epsilon$，由控制收敛定理，$X^*1_F$存在且大于等于0，即$EX^*1_D\geq 0$，这就推出$P(D)\leq 0$。由此可以证明a.s.收敛。根据有界收敛+控制收敛可得L1收敛。</p>
<p><u>Birkhoff遍历定理可以直接推出强大数律</u></p>
<p>根据Birkhoff遍历定理在圆周旋转上的应用，如果$\theta\in(0,1)$是无理数，$\phi(\omega)=\omega+\theta\:mod\:1$，令$X(\omega)=1_A(\omega)$，那么</p>
<script type="math/tex; mode=display">
\frac1n\sum_{m=1}^{n-1}1_{(\phi^m\omega\in A)}\to|A|,a.s.</script><p>当$\omega=0$时，也称做<strong>Weyl等分布定理</strong>。由此得到以下数论结论</p>
<p>定理：如果$A=[a,b)$，那么倒外集为空集。</p>
<p><strong>常返</strong></p>
<p>设$X_n$取值$R^d$的平稳序列，定义</p>
<script type="math/tex; mode=display">
R_n=\#\{S_1,S_2,...,S_n\}</script><p>定理：</p>
<script type="math/tex; mode=display">
\lim_{n\to\infty}\frac{R_n}{n}=E(1_A|I)</script><p>其中$A=\{S_k\neq 0,\forall k\geq 1\}$</p>
<p>证明：对$l\geq m$，$S_l=S_m+S_{l-m}(\phi^m\omega)$，</p>
<script type="math/tex; mode=display">
R_n\geq\sum_{m=1}^n1_A(\phi^m\omega)=\#\{m|S_l\neq S_m,\forall l>m\}</script><p>由Birkhoff，</p>
<script type="math/tex; mode=display">
\inf\lim_{n\to\infty}\frac{R_n}n\geq\lim_{n\to\infty}\frac1n\sum_{m=1}^n1_A(\phi^m\omega)=E(1_A|I)</script><p>令$A_k=\{S_m\neq 0, m\leq k\}$</p>
<script type="math/tex; mode=display">
\sum_{m=1}^{n-k}1_{A_k}(\phi^m\omega)=\#\{m|S_l\neq S_m,\forall>m\}</script><p>所以$R_n\leq k+\sum_{m=1}^{n-k}1_{A_k}(\phi^m\omega)$，如此</p>
<script type="math/tex; mode=display">
\sup\lim\frac{R_n}n\leq E(1_{A_k}|I)</script><p>由于$A_k\downarrow A$，由控制收敛可证上界。</p>
<p>Durrent第四章、第六章</p>
<p>206</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/14/ConvexOptimization/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hulieu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hulieu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/14/ConvexOptimization/" class="post-title-link" itemprop="url">凸优化问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-14 18:07:45" itemprop="dateCreated datePublished" datetime="2020-02-14T18:07:45+08:00">2020-02-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-20 11:02:23" itemprop="dateModified" datetime="2020-03-20T11:02:23+08:00">2020-03-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%8C%AB%E7%88%AA%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">猫爪记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%8C%AB%E7%88%AA%E8%AE%B0/Mathematics/" itemprop="url" rel="index"><span itemprop="name">Mathematics</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>凸优化问题具有如下形式</p>
<script type="math/tex; mode=display">
min\:f_0(x)</script><script type="math/tex; mode=display">
subject\:to\:f_i(x)\leq b_i\:, \:i=1,...,m</script><p>其中 $f_i$ 是凸函数</p>
<h3 id="凸集"><a href="#凸集" class="headerlink" title="凸集"></a>凸集</h3><p>C的<strong>仿射包</strong>为C中的点的所有仿射组合，即为<strong>affC</strong></p>
<p>定义集合C的<strong>仿射维数</strong>为其<strong>仿射包</strong>的维数。</p>
<p>定义集合C的<strong>相对内部</strong>为<strong>affC</strong>里C的内部，记为<strong>relintC</strong></p>
<script type="math/tex; mode=display">
relint\:C=\{x\in C|B(x, r)\cap aff\: C\subseteq C \: for \:some\: r \}</script><p><strong>凸集</strong>定义为对$x_1\:,\:x_2\in C\:,\:0\leq\theta\leq 1$</p>
<script type="math/tex; mode=display">
\theta x_1+(1-\theta)x_2\in C</script><p><strong>锥</strong>定义为<strong>非负齐次</strong>集合，对$x_1\:,\:x_2\in C\:,\:0\leq\theta_1\:,\:theta_2$</p>
<script type="math/tex; mode=display">
\theta_1 x_1+\theta_2 x_2\in C</script><p>集合C的<strong>锥包</strong>是C中元素的所有锥组合，也是包含C的<strong>最小凸锥</strong>。</p>
<p>凸集的例子</p>
<ul>
<li><p>空集、单点、直线、全空间</p>
</li>
<li><p>任意子空间都是<strong>凸锥</strong></p>
</li>
<li><p>超平面定义的半空间</p>
</li>
<li><p>Euclid球和椭球</p>
</li>
<li><p>范数球和范数锥</p>
</li>
<li><p>多面体和单纯形</p>
<p><u>如何表示多面体：凸包描述和不等式解集，n很大时两种描述规模相差极大。</u></p>
</li>
<li><p>半正定锥（半正定矩阵的元素在n(n+1)/2的向量空间里）</p>
</li>
</ul>
<p>保凸运算</p>
<ul>
<li><p>交集</p>
</li>
<li><p><strong>仿射</strong>函数</p>
</li>
<li><p>透视函数：$P:R^{n+1}\to R^n\:,\: P(z,t)=z/t \:,\: t&gt;0$</p>
</li>
<li><p>线性分式：</p>
<script type="math/tex; mode=display">
f(x)=(Ax+b)/(c^T x+d)\:,\:dom\: f = \{x|c^T x+d>0\}</script><p><u>凸集在透视函数或线性分式下的原相也是凸的。</u></p>
</li>
</ul>
<p><strong>正常锥</strong>K是满足下列条件的锥</p>
<ul>
<li>凸集</li>
<li>闭集</li>
<li><strong>实</strong>的：有非空内部</li>
<li><strong>尖</strong>的：不包含直线的</li>
</ul>
<p><strong>正常锥</strong>K可以用来定义<strong>广义不等式</strong> ，即偏序关系</p>
<script type="math/tex; mode=display">
x\preceq_K \: y \Leftrightarrow y - x \in K</script><p>（$K=R^+$时这个偏序关系就是通常意义上的不等式）</p>
<p>广义不等式定义的偏序关系$\preceq_K$具有加法保序性、传递性、自反性、反对称性等等。</p>
<p>但是它不具有<strong>线性序</strong>，即并非任意两点都可比。如果对每个$y\in S$，都有$x\preceq_K \: y$，那么我们称x为S的<strong>最小元</strong>，类似可定义<strong>最大元</strong>。最小元符号定义为</p>
<script type="math/tex; mode=display">
S \subseteq x +K</script><p>如果$y\in S$，而且$y\preceq_K \: x$可以推得$y=x$，那么我们称x为S的<strong>极小元</strong>，类似可定义<strong>极大元</strong>。极小（极大）元不一定唯一。极小元符号定义为 </p>
<script type="math/tex; mode=display">
(x-K)\cap S=\{x\}</script><p><strong>超平面分离定理</strong>：两个不相交的凸集C、D可以用一个超平面分离，即存在a，b</p>
<script type="math/tex; mode=display">
a^Tx+b\leq 0 \:for \:x\in C</script><script type="math/tex; mode=display">
a^Tx+b\geq 0 \:for \:x\in D</script><p><strong>严格分离</strong>是更强的条件（上式为严格不等号时），不相交的凸集也不一定能被严格分离。</p>
<p>超平面分离定理逆定理<strong>不成立</strong>，但是加上条件的如下结论：任何两个凸集C、D，如果其中至少有一个是<strong>开集</strong>，那么当且仅当存在分离超平面时，它们不相交。</p>
<p><strong>支撑超平面</strong>是指对C<strong>边界(bd C)</strong>上一点$x_0$，如果对</p>
<script type="math/tex; mode=display">
a\neq0\:,\:\forall x\in C\:,\:a^Tx\leq a^Tx_0</script><p>那么称$\{x|a^Tx=a^Tx_0\}$为C在$x_0$处的支撑超平面。一个基本结论<strong>支撑超平面定理</strong>：对任意凸集C和任意$x_0\in bd\:C$，存在支撑超平面。一个<strong>不完全的逆定理</strong>：具有非空内部的闭集，若其边界每个点都存在支撑超平面，那么他是凸的。（证明大概是从内点出发找到不满足凸集要求的点？</p>
<p>对一个锥K，集合</p>
<script type="math/tex; mode=display">
K^*=\{y|x^Ty\geq 0\:,\forall x\in K\}</script><p>称为K的<strong>对偶锥</strong>。几何上看，$y\in K^*$当且仅当-y是K在原点的一个支撑超平面的法线。</p>
<p>对偶锥的例子：</p>
<ul>
<li>子空间的对偶锥是其正交补</li>
<li>非负象限、半正定锥自对偶</li>
<li>范数锥的对偶由<strong>对偶范数</strong>定义</li>
</ul>
<p>一些性质：</p>
<ul>
<li>$K^*$总是闭+凸的</li>
<li>K有非空内部，则$K^*$是尖的</li>
<li>K的闭包是尖的，则$K^*$有非空内部</li>
<li>$K^{**}$是K的凸包的闭包</li>
<li>由上述性质可知当K是正常锥时$K^{**}=K$</li>
</ul>
<p><strong>广义不等式的对偶的性质</strong>：$x\preceq_K\:y$ 当且仅当对任意$\lambda\succeq_{K^<em>}0$有$\lambda^Tx\leq \lambda^Ty$。由于$K^{*</em>}=K$，显然对K的对偶也成立。</p>
<p><strong>线性严格广义不等式的择一定理</strong>：考虑严格广义不等式</p>
<script type="math/tex; mode=display">
Ax\prec_K\:b</script><p>，假设它不可行，即仿射集合$\{b-Ax\}$和int K不相交，那么存在一个分离超平面，因此存在$\lambda$和$\mu$使得对任意x，$\lambda^T(b-Ax)\leq\mu$，以及对任意$y\in K$，$\lambda^Ty\geq\mu$。第一个条件表明$A^T\lambda=0$以及$\lambda^Tb\leq\mu$；第二个条件表明$\lambda\in K^{*}$以及$\mu\leq 0$。所以，即存在$\lambda$，</p>
<script type="math/tex; mode=display">
\lambda\succeq_{K^*}0\:,\:A^T\lambda=0\:,\:\lambda^Tb\leq0</script><p>由此两个不等式构成一对择一，仅有一个可行。</p>
<p><strong>最小元的充要条件</strong>：对所有$\lambda\succ_{K^*}0$，x是极小化$\lambda^Tz$的唯一最优解。</p>
<p><strong>极小元的充要条件</strong>：如果有$\lambda\succ_{K^*}0$，x是极小化$\lambda^Tz$。（如果S不是凸集，则必要性不一定成立）</p>
<h3 id="凸函数"><a href="#凸函数" class="headerlink" title="凸函数"></a>凸函数</h3><p>定义f为<strong>凸函数</strong>如果dom f是凸集且对任意$x,y\in dom\: f$和任意$0\leq\theta\leq 1$有</p>
<script type="math/tex; mode=display">
f(\theta x+(1-\theta)y)\leq\theta f(x)+(1-\theta)f(y)</script><p><strong>严格凸</strong>即上式在$x\neq y$且$0&lt;\theta &lt;1$时严格成立。<strong>凹函数</strong>类似定义。</p>
<p><strong>扩展值延伸</strong>：可以通过定义凸函数在定义域外的值为$\infty$来将这个凸函数延伸到全空间。</p>
<p>假设f<strong>可微</strong>，则f是凸函数的充要条件是dom f是凸集且对于任意$x,y\in dom\:f$，</p>
<script type="math/tex; mode=display">
f(y)\geq f(x)+\nabla f(x)^T(y-x)</script><p>假设f<strong>二阶可微</strong>，则f是凸函数的充要条件是dom f是凸集且对于任意$x\in dom\:f$，</p>
<script type="math/tex; mode=display">
\nabla^2f(x)\succeq 0</script><p>凸函数的例子：</p>
<ul>
<li>线性函数、仿射函数</li>
<li>指数、幂函数、对数、负熵</li>
<li>范数、最大值</li>
<li>指数和的对数</li>
</ul>
<p>凹函数的例子</p>
<ul>
<li>线性函数、仿射函数</li>
<li>几何平均、对数-行列式</li>
</ul>
<p><strong>$\alpha$-下水平集</strong>定义为</p>
<script type="math/tex; mode=display">
C_\alpha=\{x\in dom\:f\:|\:f(x)\leq \alpha\}</script><p>显然凸函数的下水平集仍然是凸集，反之不然。</p>
<p><strong>上境图</strong>定义为</p>
<script type="math/tex; mode=display">
epi\:f=\{(x,t)|x\in dom\:f\:,\:f(x)\leq t\}</script><p>一个函数是凸函数当且仅当它的上境图是凸集。一个函数是凹函数当且仅当它的<strong>亚图</strong>是凸集。</p>
<p><strong>Jensen不等式</strong>：如果f是凸函数，则</p>
<script type="math/tex; mode=display">
f(\theta x+(1-\theta)y)\leq\theta f(x)+(1-\theta)f(y)</script><p>可以推广到多点、无穷项和、积分、期望等。</p>
<p><strong>保凸运算</strong>是保持函数凸性的运算</p>
<ul>
<li>非负加权求和</li>
<li>复合仿射映射</li>
<li>逐点最大（或上确界）：本质上是上境图的交集</li>
<li>一族仿射函数的逐点上确界</li>
</ul>
<p><strong>复合函数</strong>$f(x)=h(g(X))$的一些性质</p>
<ul>
<li>标量复合：h凸（凹）且单调，g凸或凹，则f是凸（凹），如果不再假设h、g可微，或者$dom\:g=R^n$，则要求h的扩展值延伸$\tilde{h}$单调。</li>
<li>矢量复合：和标量复合相似，但要求h的每个维度分量上单调</li>
</ul>
<p>特殊形式的<strong>最小化</strong>也可以得到凸函数，假设$f(x,y)$是凸函数，集合C是非空凸集，则</p>
<script type="math/tex; mode=display">
g(x)=inf_{y\in C}f(x,y)</script><p>若$g(x)&gt;-\infty$，则g关于x是凸函数。</p>
<p>定义f的<strong>透视函数</strong>$g(x,t)=tf(x/t)$，透视运算是保凸运算。</p>
<p>f的<strong>共轭函数</strong>定义为</p>
<script type="math/tex; mode=display">
f^*(y)=sup_{x\in dom\:f}(y^Tx-f(x))</script><p>显然$f^*$是凸函数。</p>
<p>共轭函数的例子：</p>
<ul>
<li>仿射函数$f(x)=ax+b$，$f^*$定义域为单点集{a}，值为-b。</li>
<li>负对数函数$f(x)=-log(x)$，$f^*(y)=-log(-y)-1$定义域为{y|y&lt;0}</li>
<li>指数函数$f(x)=e^x$，$f^*(y)=y\cdot log(y)-y$定义域为{y|y&gt;0}</li>
<li>严格凸的二次函数$f(x)=\frac12 x^TQx$，$f^*(y)=\frac12 y^TQ^{-1}y$</li>
<li>对数-行列式$f(X)=log(det(X^{-1}))$，$f*(Y)=log(det(-Y^{-1}))-n$</li>
<li>示性函数的共轭函数$f^*(y)=sup_{x\in S}y^Tx$，是集合S的支撑函数</li>
</ul>
<p><strong>Fenchel不等式</strong>：有定义可知$f(x)+f*(y)\geq x^Ty$</p>
<p>共轭的共轭：如果f是凸函数且是闭的，$f^{**}=f$</p>
<p><strong>可微</strong>函数f的共轭函数也称为函数f的<strong>Legendre变换</strong>。此时$y=\nabla f(x^*)$</p>
<p>复合仿射的共轭函数：f(Ax+b)的共轭函数为$f*(A^{-T}y)-b^TA^{-T}y$</p>
<p><strong>拟凸函数</strong>定义为满足<strong>定义域和所有下水平集都是凸集</strong>的函数。<strong>拟凹函数</strong>函数类似定义，如果一个函数拟凸且拟凹，则称为<strong>拟线性函数</strong>。</p>
<p>一些例子</p>
<ul>
<li>对数函数、上取整函数（都是拟线性函数）</li>
<li>线性分式函数（也是拟线性）</li>
</ul>
<p>拟凸函数的Jensen不等式：</p>
<script type="math/tex; mode=display">
f(\theta x+(1-\theta)y)\leq max\{f(x),f(y)\}</script><p>在R上函数f拟凸当且仅当一下条件至少一个成立：</p>
<ul>
<li>f单调</li>
<li>存在一点c，在其左边f非增，在其右边f非减</li>
</ul>
<p>可微拟凸函数的充要条件：</p>
<ul>
<li>一阶条件：$f(y)\leq f(x) \Rightarrow \nabla f(x)^T(y-x)\leq 0$</li>
<li>二阶条件：$y^T\nabla f(x)=0\Rightarrow y^T\nabla^2 f(x)y \geq 0$</li>
</ul>
<p>保拟凸运算</p>
<ul>
<li>非负加权最大（可以扩展到逐点上确界）</li>
<li>拟凸函数和一个非减函数、仿射函数或线性分式函数复合</li>
<li>最小化也是保拟凸的</li>
</ul>
<p>拟凸函数可以通过<strong>一族凸函数</strong>进行表示。这些凸函数满足</p>
<script type="math/tex; mode=display">
f(x)\leq t \Leftrightarrow\phi_t(x)\leq0</script><p><strong>对数-凹函数</strong>和<strong>对数-凸函数</strong>定义为log(f)为凸函数和凹函数。非负凸（凹）函数是对数-凸（凹）函数；对数-凸（凹）函数是拟凸（凹）函数。</p>
<p><strong>二次可微</strong>函数f是对数-凸函数当且仅当</p>
<script type="math/tex; mode=display">
f(x)\nabla^2f(x)\succeq\nabla f(x)\nabla f(x)^T</script><p>对数-凸（凹）性对加法、乘法、积分、<strong>卷积</strong>封闭。</p>
<p>非负函数p的Laplace变换$P(z)=\int p(x)e^{-z^T x}dx$，是对数-凸函数。$M(z)=P(-z)$是矩生成函数，$log(M(z))$是累积量生成函数。</p>
<p><strong>广义不等式的单调性</strong>：$x\preceq_K y\Rightarrow f(x)\leq f(y)$，称函数<strong>K-非减</strong>。当上式严格成立时，称函数<strong>K-增</strong>。类似定义<strong>K-非增</strong>和<strong>K-减</strong>。</p>
<p>可微函数f，定义域是凸集，它是<strong>K-非减</strong>的，当且仅当$\nabla f(x)\succeq_{K*}0$。严格情形下反过来不一定正确。</p>
<p><strong>广义不等式的凸性</strong>：f是<strong>K-凸</strong>的，如果对于任意x，y，以及$0\leq\theta\leq 1，</p>
<script type="math/tex; mode=display">
f(\theta x+(1-\theta)y)\preceq_K \theta f(x)+(1-\theta)f(y)</script><p>当$x\neq y$和$0&lt;\theta&lt;1$时上式严格成立，则称其为<strong>严格K-凸</strong>的。</p>
<p>一些例子</p>
<ul>
<li>当K为$R^N_+$时，即在每个分量上凸</li>
<li>当K为正定矩阵时，称为<strong>矩阵凸性</strong>。等价定义就是对任意z，$z^Tf(x)z$凸。例如$f(X)=XX^T$</li>
</ul>
<p>对偶刻画：f是K-凸的当且仅当对任意$w\succeq_{K^*}0$，$w^Tf$是凸的。</p>
<p><strong>可微的K-凸函数</strong>：充要条件</p>
<script type="math/tex; mode=display">
f(y)\succeq_K f(x)+Df(x)(y-x)</script><p>函数复合保留凸性的结论都可以推广到K-凸的情形。</p>
<h3 id="凸优化问题"><a href="#凸优化问题" class="headerlink" title="凸优化问题"></a>凸优化问题</h3><p>一般<strong>标准形式问题</strong></p>
<script type="math/tex; mode=display">
min\:f_0(x)</script><script type="math/tex; mode=display">
subject\:to\:f_i(x)\leq 0\:,\:i=1,...,m \\
h_i(x)=0\:,\:i=1,...,p</script><p><strong>最优值</strong>$p^*=inf\:f_0(x)$。如果$x^*$可行且$f_0(x^*)=p^*$，称$x^*$为<strong>最优点</strong>。最优点的集合称为<strong>最优集</strong>。最优集是空集，则称最优值<strong>不可得（不可达）</strong>。满足$f_0(x)\leq p^* + \epsilon$的可行解x称为<strong>$\epsilon-$次优</strong>。所有$\epsilon-$次优的集合称为<strong>$\epsilon-$次优集</strong>。</p>
<p>称可行解x为<strong>局部最优</strong>，如果存在$R&gt;0$，使得在$||z-x||_2\leq R$的条件下x是最优解。</p>
<p>等价问题：</p>
<ul>
<li>数乘</li>
<li>一一映射的变量代换</li>
<li>目标（约束）函数的单调变换</li>
<li>松弛变量替换不等式约束</li>
<li>显式/隐式约束替换</li>
<li>优化独立的部分变量</li>
<li>上境图形式</li>
</ul>
<p><strong>凸优化问题</strong>是形如</p>
<script type="math/tex; mode=display">
min\:f_0(x)\\
subject\:to\:f_i(x)\leq 0\:,\:i=1,...,m \\
a_i^Tx=b_i\:,\:i=1,...,p</script><p>相比一般标准形式，要求目标函数和约束函数是<strong>凸函数</strong>，等式约束必须是<strong>仿射</strong>的。显然它的<strong>可行集</strong>和<strong>最优集</strong>是凸的。所以，<strong>局部最优解就是全局最优解</strong>。($f_0$是拟凸函数的时候，称为<strong>拟凸优化</strong>)</p>
<p>可微函数$f_0$的最优性准则：$\forall y\:,\:\nabla f_0(x)^T(y-x)\geq 0$，相当于定义了可行集的一个支撑超平面。（拟凸问题中，这是个充分不必要条件）</p>
<p><strong>解决拟凸优化的一般方法</strong>是把$f_0$表示成一族凸函数，然后解决可行性问题。</p>
<p><strong>线性规划（LP）</strong>问题是</p>
<script type="math/tex; mode=display">
min\:c^Tx+d\\
subject\:to\:Gx\preceq h\\
Ax=b</script><p><strong>标准形式线性规划</strong>是</p>
<script type="math/tex; mode=display">
min\:c^Tx+d\\
subject\:to\:Ax=b\\
x\succeq0</script><p>可以通过引入松弛变量、把$x$分解为$x^+$和$x^-$把线性规划转换为标准形式。</p>
<p><strong>线性分式规划</strong>问题是</p>
<script type="math/tex; mode=display">
min\:f_0(x)=\frac{c^Tx+d}{e^Tx+f}\:,\:dom\:f_0=\{x|e^Tx+f>0\}\\
subject\:to\:Gx\preceq h\\
Ax=b</script><p>作变量替换$y=\frac{x}{e^Tx+f}$和$z=\frac{1}{e^Tx+f}$，可以转换为等价的线性规划。</p>
<p>线性分式规划的一个推广是<strong>广义线性分式规划</strong>，目标函数是r个线性分式的最大值，这是个拟凸优化。</p>
<p><strong>二次优化问题（QP）</strong>是</p>
<script type="math/tex; mode=display">
min\:(1/2)x^TPx+q^Tx+R\\
subject\:to\:Gx\preceq h\\
Ax=b</script><p>如果约束也是二次的，称为<strong>二次约束二次规划（QCQP）</strong>。</p>
<p><strong>二阶锥规划（SOCP）</strong>是</p>
<script type="math/tex; mode=display">
min\:f^Tx\\
subject\:to\:||A_ix+b_i||_2\leq c^T_ix+di\:,\:i=1,...,m\\
Fx=g</script><p>当$c_i=0$时，SOCP退化为QCQP。</p>
<p><strong>鲁棒线性规划</strong>：约束条件的系数为一个给定的椭球。</p>
<p><strong>随机约束下的线性规划</strong>：要求约束成立的概率</p>
<p><strong>几何规划（GP）</strong>是</p>
<script type="math/tex; mode=display">
min\:f_0(x)\\
subject\:to\:f_i(x)\leq 1\:,\:i=1,...,m \\
h_i(x)=1\:,\:i=1,...,p</script><p>其中$f_i$是<strong>正项式</strong>，$h_i$是<strong>单项式</strong>。通过$y_i=log(x_i)$的换元可以简单的转换为凸优化问题。</p>
<p><strong>广义不等式意义下的凸优化问题</strong>：</p>
<script type="math/tex; mode=display">
min\:f_0(x)\\
subject\:to\:f_i(x)\preceq_{K_i} 0\:,\:i=1,...,m \\
a_i^Tx=b_i\:,\:i=1,...,p</script><p>其中$f_i$是$K_i-$凸的。可行集和最优集也是凸的，任何局部最优都是全局最优。</p>
<p>广义不等式凸优化问题中，最简单的是<strong>锥规划</strong>：</p>
<script type="math/tex; mode=display">
min\:c^Tx\\
subject\:to\:Fx+g\preceq_K 0\\
Ax=b</script><p>当K为半正定矩阵锥时，相应锥问题称为<strong>半定规划（SDP）</strong>，这时不等式是<strong>线性矩阵不等式（LMI）</strong>。</p>
<script type="math/tex; mode=display">
\sum x_iF_i+G\preceq 0</script><p><strong>标准形式的SDP</strong>：</p>
<script type="math/tex; mode=display">
min\:tr(CX)\\
subject\:to\:tr(A_iX)=b_i\\
X\succeq0</script><p>注意tr(CX)是S上一般实值线性函数的形式。</p>
<p><strong>广义向量优化问题</strong>记为</p>
<script type="math/tex; mode=display">
min（关于K）\:f_0(x)\\
subject\:to\:f_i(x)\leq 1\:,\:i=1,...,m \\
h_i(x)=1\:,\:i=1,...,p</script><p>如果$f_0$是$K-$凸的，称为<strong>凸向量优化问题</strong>。</p>
<p>点$x^*$是<strong>最优</strong>的当且仅当<strong>可达目标值集合</strong>$O\subseteq f_0(x^*)+K$</p>
<p>点$x^*$是<strong>Pareto最优</strong>当且仅当$O\cap (f_0(x^*)-K)=\{f_0(x^*)\}$，可以证明Pareto最优值集合$P\subseteq O\cap bd\:O$。</p>
<p><strong>标量化</strong>是寻找Pareto最优的标准技术。选择任意$\lambda\succ_{K^*}0$，最优化$\lambda^Tf_0(x)$的最优解是Pareto最优的。</p>
<p><strong>多准则优化</strong>：当向量优化函数关于锥$K=R^q_+$时，称为多准则优化。多准则问题的Pareto最优值集合称为<strong>最优权衡曲面</strong>。我们通过加权来标量化多准则问题。</p>
<h3 id="对偶"><a href="#对偶" class="headerlink" title="对偶"></a>对偶</h3><p>考察标准形式优化问题</p>
<script type="math/tex; mode=display">
min\:f_0(x)\\
subject\:to\:f_i(x)\leq 0\\
h_i(x)=0</script><p><strong>Lagrange函数</strong>定义为</p>
<script type="math/tex; mode=display">
L(x,\lambda,\nu)=f_0(x)+\sum\lambda_if_i(x)+\sum\nu_ih_i(x)</script><p><strong>Lagrange对偶函数</strong>定义为Lagrange函数关于x取得的最小值</p>
<script type="math/tex; mode=display">
g(\lambda,\nu)=inf_xL(x,\lambda,\nu)</script><p>这是原问题$f_0(x)$的下界，即$\forall\lambda\succeq 0\:,\:g(\lambda,\nu)\leq p^*$。</p>
<p><strong>Lagrange对偶函数和共轭函数紧密相关：</strong>比如下面的优化问题</p>
<script type="math/tex; mode=display">
min\:f_0(x)\:subject\:to\:Ax\preceq b\:,\:Cx=d</script><script type="math/tex; mode=display">
g(\lambda,\nu)=-b^T\lambda-d^T\nu-f_0^*(-A^T\lambda-C^T\nu)</script><p><strong>Lagrange对偶问题</strong>表述为</p>
<script type="math/tex; mode=display">
max\:g(\lambda,\nu)\\
subject\:to\:\lambda\succeq 0</script><p>对偶问题的差值称之为<strong>最优对偶间隙</strong>=$p^*-d^*$。</p>
<p>如果$d^*=p^*$成立，那么<strong>强对偶性</strong>成立。一般情况下，强对偶性不成立，<strong>凸优化问题</strong>中强对偶性成立的条件称为<strong>约束准则</strong>。</p>
<p>一个简单的约束准则是<strong>Slater条件</strong>：存在一点$x\in relint\:D$，<strong>严格可行</strong>，即</p>
<script type="math/tex; mode=display">
f_i(x)<0\:,\:i=1,...,m,\:Ax=b</script><p>这个条件可以进一步改进为<strong>仿射条件不需要严格成立，其他条件严格成立</strong>。因而对于线性规划问题，根据Slater条件弱化形式，只要原问题可行，强对偶性都成立。</p>
<p>由此推论：<strong>矩阵对策的混合策略</strong>满足强对偶条件，所以知道对方策略并不影响博弈的策略。</p>
<h5 id="对偶问题的几何解释"><a href="#对偶问题的几何解释" class="headerlink" title="对偶问题的几何解释"></a>对偶问题的几何解释</h5><p>定义集合</p>
<script type="math/tex; mode=display">
G=\{(f_1(x),...,f_m(x),h_1(x),...,h_p(x),f_0(x)\}</script><p>很容易定义优化问题最优解</p>
<script type="math/tex; mode=display">
p^*=inf\{t|(u,v,t)\in G,u\preceq 0,v=0\}</script><p>对偶函数</p>
<script type="math/tex; mode=display">
g(\lambda,\nu)=inf\{(\lambda,\nu,1)^T(u,v,t)|(u,v,t)\in G\}</script><p>如果下确界有限，则不等式</p>
<script type="math/tex; mode=display">
(\lambda,\nu,1)^T(u,v,t)\geq g(\lambda,\nu)</script><p>定义了集合G的一个支撑超平面。假设有$\lambda\succeq 0$，那么$p^*\geq g(\lambda,\nu)$，即弱对偶性成立。</p>
<p>如果以G的上境图A来描述</p>
<script type="math/tex; mode=display">
A=\{(u,v,t)|\exists x\in D,f_i(x)\leq u_i,h_i(x)=v_i,f_0(x)\leq t\}</script><p>那么最优值</p>
<script type="math/tex; mode=display">
p^*=inf\{t|(0,0,t)\in A\}</script><p>同上也是定义了A的支撑超平面。特别的，因为$(0,0,p^*)\in bd\:A$，若对偶性成立。</p>
<p>在几何意义下，<strong>Slater条件意味着分离超平面必非竖直</strong>，强对偶成立。证明如下：先如上定义集合A，另一个凸集</p>
<script type="math/tex; mode=display">
B=\{(0,0,s)|s<p^*\}</script><p>可以找到超平面分离AB，因而$g(\lambda,\nu)\geq p^*$，然后通过说明对偶问题能达到最优，说明强对偶成立。</p>
<h5 id="鞍点解释"><a href="#鞍点解释" class="headerlink" title="鞍点解释"></a>鞍点解释</h5><p>弱对偶性可以描述为</p>
<script type="math/tex; mode=display">
sup_{\lambda\succeq 0}inf_x L(x,\lambda)\leq inf_x sup_{\lambda\succeq 0}L(x,\lambda)</script><p>强对偶性即为上式取等。</p>
<p>我们称一对$\hat{w}$，$\hat{z}$是<strong>鞍点</strong>如果</p>
<script type="math/tex; mode=display">
f(\hat{w},z)\leq f(\hat{w},\hat{z})\leq f(w,\hat{z})</script><p>上式意味着<strong>极大极小性质</strong>成立。</p>
<h5 id="最优性条件"><a href="#最优性条件" class="headerlink" title="最优性条件"></a>最优性条件</h5><p>如果找到对偶可行解$(\lambda,\nu)$那么就对原问题的最优值建立了一个下界。定义差值</p>
<script type="math/tex; mode=display">
f_0(x)-g(\lambda,\nu)</script><p>是<strong>对偶间隙</strong>。这可以用在优化算法中给出<strong>非启发式停止准则</strong>。</p>
<p>如果强对偶性成立，且$x^*,\lambda^*,\nu^*$取到最优，那么</p>
<script type="math/tex; mode=display">
\lambda_i^*f_i(x^*)=0</script><p>称为<strong>互补松弛性</strong>。</p>
<p>非凸问题的<strong>KKT条件</strong>：</p>
<script type="math/tex; mode=display">
\nabla f_0(x^*)+\sum \lambda_i^*\nabla f_i(x^*)+\sum v_i^* \nabla h_i(x^*)=0\\
f_i(x^*)\leq 0\\
h_i(x^*)=0\\
\lambda_i^*\geq 0\\
\lambda_i^* f_i(x^*)=0</script><p>KKT条件是任何一对原问题最优解和对偶问题最优解必须满足的条件。当原问题是<strong>凸优化问题</strong>时，满足KKT条件的点也是原、对偶问题的最优解。</p>
<h5 id="扰动问题"><a href="#扰动问题" class="headerlink" title="扰动问题"></a>扰动问题</h5><script type="math/tex; mode=display">
min\:f_0(x)\\
subject\:to\:f_i(x)\leq u_i\\
h_i(x)=v_i</script><p>定义最优解为$p^*(u,v)$。假设原问题强对偶性成立并且最优值可以达到，那么</p>
<script type="math/tex; mode=display">
p^*(u,v)\geq p^*(0,0)-\lambda^{*T}u-\nu^{*T}v</script><h5 id="择一定理"><a href="#择一定理" class="headerlink" title="择一定理"></a>择一定理</h5><p>严格不等式系统的可行性</p>
<script type="math/tex; mode=display">
f_i(x)<0,\:h_i(x)=0</script><p>和</p>
<script type="math/tex; mode=display">
\lambda\succeq 0,\:g(\lambda,\nu)\geq0</script><p>是<strong>弱择一</strong>的。当原不等式系统是凸的，那么则是<strong>强择一</strong>的。</p>
<p>推导Farkas引理：考虑线性规划</p>
<script type="math/tex; mode=display">
min\:c^Tx\\
subject\:to\:Ax\preceq 0</script><p>和对偶问题</p>
<script type="math/tex; mode=display">
max\:0\\
subject\:to\:A^Ty+c=0,\:y\succeq 0</script><p>显然强对偶成立。可以证明<strong>Farkas引理</strong>：</p>
<script type="math/tex; mode=display">
Ax\preceq 0,\:c^Tx<0</script><p>和</p>
<script type="math/tex; mode=display">
A^Ty+c=0,\:y\succeq0</script><p>是一对强择一系统。</p>
<p><u>Lagrange对偶对广义不等式同样成立，对偶条件和KKT条件中$\lambda$的约束从$\geq 0$改为$\succeq_{K^*}0$。</u></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/14/csapp10/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hulieu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hulieu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/14/csapp10/" class="post-title-link" itemprop="url">从四开始的汇编</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-14 16:22:35" itemprop="dateCreated datePublished" datetime="2020-02-14T16:22:35+08:00">2020-02-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-20 11:00:41" itemprop="dateModified" datetime="2020-03-20T11:00:41+08:00">2020-03-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%8C%AB%E7%88%AA%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">猫爪记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%8C%AB%E7%88%AA%E8%AE%B0/Computer-Science/" itemprop="url" rel="index"><span itemprop="name">Computer-Science</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="系统I-O"><a href="#系统I-O" class="headerlink" title="系统I/O"></a>系统I/O</h3><p>打开关闭文件/改变文件位置/读写文件</p>
<p>RIO包（Robust I/O)提供两类函数</p>
<ul>
<li>无缓冲的输入输出：直接在存储器和文件间传送数据</li>
<li>带缓冲的输入：rio_readlineb 他是线程安全的</li>
</ul>
<p>读取文件元数据：stat/fstat</p>
<p>内核用三个数据结构表示打开的文件：</p>
<ul>
<li>描述符表：每个进程有独立的描述符表，每个描述符表指向文件表的一个表项</li>
<li>文件表：文件表的表项包括当前的文件位置、引用计数和指向v-node的指针，所有进程共享</li>
<li>v-node表：包含stat大多数信息，所有进程共享</li>
</ul>
<p><em>共享文件即多个文件表指向一个v-node表</em></p>
<p>I/O重定向（&gt;）：拷贝旧的描述符表项到新的描述符表项</p>
<p>标准I/O：libc的fopen/fclose、fread/fwrite、fgets/fputs、scanf/printf</p>
<p>三个流stdin、stdout、stderr</p>
<p><img src="io.png" alt=""></p>
<p>一般使用标准I/O，但是网络输入输出等情况需要用低级Unix I/O（或者RIO）</p>
<p><u>这是因为Unix对网络的抽象为<em>套接字</em>类型文件，对流的限制和对套接字的限制会有冲突。标准I/O是在同一个流输入输出的，而套接字需要打开两个流一个读一个写。</u></p>
<h3 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h3><p>网络是个I/O设备</p>
<p>最低层的是局域网LAN，流行的局域网技术是以太网Ethernet，每个以太网适配器有一个全球唯一的48位地址。使用网桥bridge可以将多个以太网段连接成桥接以太网bridged ethernet。</p>
<p>多个不兼容的局域网可以通过路由器router连接，组成互联网络internet。每台路由器对它连接的每个网络都有一个适配器（端口）。路由器也能连接高速点到点通话，这就是广域网WAN。</p>
<p>网络协议消除不同网络之间的差异，他需要两种基本能力：</p>
<ul>
<li>命名机制：一致的主机格式</li>
<li>传送机制：把数据捆扎成不连续片（称为包）</li>
</ul>
<h3 id="全球IP因特网Internet"><a href="#全球IP因特网Internet" class="headerlink" title="全球IP因特网Internet"></a>全球IP因特网Internet</h3><p>最成功的的互联网络的实现。</p>
<p>每台主机都实现TCP/IP协议，这实际上是个协议族。</p>
<p>IP协议提供基本的命名方法和传送机制；UDP扩展了IP协议，包可以在进程间传递；TCP则是一个复杂协议，提供进程间双向连接。</p>
<ul>
<li><p>主机集合被映射为一组32位的IP地址</p>
<p><em>用机构存放IP地址这一标量是套接字接口早期实现的不幸产物。</em></p>
<p>总是以大端法存放在包头，常以点分十进制表示。</p>
</li>
<li><p>这组IP地址被映射为一组被称为因特网域名的标识符</p>
<p>一级域名由ICANN定义，常见的有com、edu、gov、org、net</p>
<p>二级域名由ICANN各个授权代理分配</p>
<p>本机回传地址总是为localhost 127.0.0.1</p>
<p>一般域名和IP地址是一一映射，也有多个域名映射到多个IP地址的</p>
</li>
<li><p>主机上的进程能和其他任何主机上的进程通信</p>
<p>一个套接字是连接的一个端口，每个套接字都有相应的地址，是一个因特网地址和16位整数端口组成。客户端端口是内核自动分配的，称为临时端口；然而服务器端口通常是知名端口，如Web常用80，电子邮件使用25。连接由两端的套接字地址唯一确定。</p>
<p><img src="connect.png" alt=""></p>
</li>
</ul>
<h3 id="套接字端口"><a href="#套接字端口" class="headerlink" title="套接字端口"></a>套接字端口</h3><p>套接字接口（socket interface）是一组函数。</p>
<p><img src="socket.png" alt=""></p>
<p>套接字地址结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Generic socket address structure (for connet bind and accept)*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> short sa_family; <span class="comment">/*protocol family*/</span></span><br><span class="line">    <span class="keyword">char</span>           sa_data[<span class="number">14</span>]; <span class="comment">/*address data*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Internet-syle socket address structure*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> short sin_family; <span class="comment">/*address family (always AF_INET)*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> short sin_port;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">/*IP address in network*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>  sin_zero[<span class="number">8</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端和服务器用socket函数创建一个套接字描述符。</p>
<p>客户端调用connect函数建立连接，得到的连接是套接字对(x:y, serv.sin_addr:serv.sin_port)刻画的。x是客户端IP地址，y是临时端口。</p>
<p>open_clientfd包装socket和connect函数。</p>
<p>open_listenfd包装socket、bind和listen函数。</p>
<p>accept等待客户端的连接请求。</p>
<h3 id="Web服务器"><a href="#Web服务器" class="headerlink" title="Web服务器"></a>Web服务器</h3><p>基于文本的应用级协议HTTP。Web内容可以用HTML来编写。</p>
<p>Web内容是与MIME（多用途国际邮件扩充协议，multipurpose Internet mail extensions)相关的字节序列。</p>
<p>URL可以用“？”分割文件名和参数，参数用“&amp;”隔开。</p>
<p>HTTP支持不同的方法包括GET、POST、OPTIONS、HEAD、PUT、DELETE、TRACE</p>
<p>HTTP请求由一个请求行和零个或更多请求报头，加上一个空行组成。请求行的形式是<code>&lt;method&gt;&lt;uri&gt;&lt;version&gt;</code>，请求报头的形式为<code>&lt;header name&gt;: &lt;header data&gt;</code>。</p>
<p>HTTP响应由一个响应行和零个或多个响应报头，加上响应主体组成。响应行格式为<code>&lt;version&gt;&lt;status code&gt;&lt;status message&gt;</code>。响应报头中最重要的是Content-Type告知类型和Content-Length指示大小。</p>
<p>CGI（通用网关接口Common Gateway Interface）提供标准解决服务动态内容的问题。服务器接收请求后，fork创建子进程，并调用execve在子进程上下文执行程序（CGI程序）。</p>
<h3 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h3><h5 id="基于进程的并发："><a href="#基于进程的并发：" class="headerlink" title="基于进程的并发："></a>基于进程的并发：</h5><p>fork、exec、waitpid</p>
<p>服务器并发的注意问题</p>
<ul>
<li>必须要SIGCHLD处理程序处理僵死子进程</li>
<li>父子进程必须关闭connfd的拷贝</li>
</ul>
<p>进程共享状态信息困难，为了共享信息，必须使用显式的IPC机制</p>
<h5 id="基于I-O多路复用的并发"><a href="#基于I-O多路复用的并发" class="headerlink" title="基于I/O多路复用的并发"></a>基于I/O多路复用的并发</h5><p>使用select函数，要求内核挂起进程，只有I/O事件发生才将控制返回。</p>
<p>优点是给了程序员更多的对程序行为的控制，流之间共享数据变得容易</p>
<p>缺点是编码复杂</p>
<h5 id="基于线程的并发"><a href="#基于线程的并发" class="headerlink" title="基于线程的并发"></a>基于线程的并发</h5><p>线程就是运行在进程上下文中的逻辑流。线程由内核自动调度，每个线程有自己的线程上下文。</p>
<p>线程上下文比进程上下文小得多，因而切换更快。线程没有严格的层次，而能对等的读写相同数据。</p>
<p>Posix线程是个标准接口。</p>
<p>线程存储器模型：根据存储类型映射到VM</p>
<ul>
<li>全局变量/静态变量：VM只包含它的一个实例</li>
<li>本地自动变量：每个线程的栈包含他自己所有本地自动变量的实例</li>
</ul>
<p>利用信号量实现互斥、共享资源</p>
<p>四个线程不安全函数</p>
<ul>
<li>不保护共享变量的函数</li>
<li>跨越多个调用的状态（比如随机数）</li>
<li>返回静态变量指针</li>
<li>调用线程不安全函数的函数</li>
</ul>
<p>竞争：一个线程要在另一个线程到达y点前到达x点，会发生竞争（race）。为了消除竞争，我们可以动态地为y分配一个独立的块并传递给线程例程一个指向这个块的指针。</p>
<p>信号量会导致一种错误叫死锁（deadlock），就是一组线程被阻塞，等待永远不真的条件。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/08/csapp7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hulieu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hulieu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/08/csapp7/" class="post-title-link" itemprop="url">从三开始的汇编</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-08 16:10:30" itemprop="dateCreated datePublished" datetime="2020-02-08T16:10:30+08:00">2020-02-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-20 11:00:35" itemprop="dateModified" datetime="2020-03-20T11:00:35+08:00">2020-03-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%8C%AB%E7%88%AA%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">猫爪记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%8C%AB%E7%88%AA%E8%AE%B0/Computer-Science/" itemprop="url" rel="index"><span itemprop="name">Computer-Science</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>C预处理器cpp 将 .c 翻译成 .i</p>
<p>C编译器cc1 将.i 翻译成汇编 .s</p>
<p>汇编器as 将 .s 翻译成可重定向目标文件 .o</p>
<p>连接器程序 ld 将 .o 结合起来创建可执行文件</p>
<p>连接器的两个任务</p>
<ul>
<li>符号解析 symbol resolution 将每个符号引用和符号定义联系起来</li>
<li>重定位 relocation 将符号定义与存储器位置联系起来</li>
</ul>
<p>目标文件</p>
<ul>
<li>可重定位目标文件</li>
<li>可执行目标文件</li>
<li>共享目标文件</li>
</ul>
<p>最早的Unix使用.out，现代Unix使用ELF，Windows NT使用COFF的变种PE。</p>
<h3 id="ELF"><a href="#ELF" class="headerlink" title="ELF"></a>ELF</h3><p>一个典型的ELF可重定位目标文件格式。</p>
<p><img src="elf.png" alt=""></p>
<ul>
<li>ELF头以16字节序列描述生成该文件的系统的字的大小和字节顺序，然后是语法分析和解释（包括ELF头大小、目标文件类型、机器类型、节头部表的文件偏移等。</li>
<li>.text：已编译的代码</li>
<li>.rodata：只读数据</li>
<li>.data：初始化的全局变量</li>
<li>.bss：未初始化的全局变量</li>
<li>.symtab：符号表，存放程序中定义和引用的函数和全局变量</li>
<li>.rel.text：.text中位置的列表</li>
<li>.rel.data：全局变量的重定位信息</li>
<li>.debug：调试符号表 -g才会得到</li>
<li>.line ：行号 -g才会得到</li>
<li>.strtab：字符串表，包括.symtab和.debug和节头部的名字</li>
</ul>
<p><u>static变量是在符号表定义</u>。</p>
<p><u>重载函数类名为原始名字前加上名字中字符数，比如Foo被编码成3Foo；方法被编码为原始方法加上类名加上每个参数的单字母编码，比如Foo::bar(int, long)被编码为bar__3Fooil。</u></p>
<p><u>多重定义：会选择强定义（初始化的定义），不同类型可能导致错误。</u></p>
<h3 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h3><p>代码的重定位条目放在.rel.text</p>
<p>已初始化数据的重定位条目放在.rel.data</p>
<p>重定位条目格式如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> offset; <span class="comment">/* offset of the refence to relocate*/</span></span><br><span class="line">    <span class="keyword">int</span> symbol:<span class="number">24</span>, <span class="comment">/*symbol the reference should point to*/</span></span><br><span class="line">    	type:<span class="number">8</span>; <span class="comment">/*Relocation type 有11中不同类型*/</span></span><br><span class="line">&#125; Elf32_Rel</span><br></pre></td></tr></table></figure>
<p>重定位符号引用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">refptr = s + r.offset;</span><br><span class="line"><span class="comment">/* 相对引用 */</span></span><br><span class="line"><span class="keyword">if</span> (r.type == R_386_PC32) &#123;</span><br><span class="line">    refaddr = ADDR(s) + r.offset;</span><br><span class="line">    *refptr = (<span class="keyword">unsigned</span>)(ADD(r.symbol) + *refptr - refaddr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 绝对引用 */</span></span><br><span class="line"><span class="keyword">if</span> (r.type == R_386_32) &#123;</span><br><span class="line">    *refptr = (<span class="keyword">unsigned</span>)(ADD(r.symbol) + *refptr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="可执行文件"><a href="#可执行文件" class="headerlink" title="可执行文件"></a>可执行文件</h3><p>下图是个典型的ELF可执行文件</p>
<p><img src="elfexe.png" alt=""></p>
<p>ELF头部包含程序的入口（entry point)，.init定义了初始化函数，不再需要.rel。</p>
<h3 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h3><p>静态库（.o）是所有相关的目标打包称为独立的文件。</p>
<p>优点：不需要重复定义、只拷贝被引用的模块、只需要较少的库文件名</p>
<p><em>AR工具创建库</em></p>
<h3 id="动态链接共享库"><a href="#动态链接共享库" class="headerlink" title="动态链接共享库"></a>动态链接共享库</h3><p>.so（Unix）或者.dll（Windows）</p>
<p>解决静态库需要显式链接、浪费资源的问题</p>
<p><em>gcc -shared -fPIC 创建库</em> </p>
<blockquote>
<p>PIC是位置无关代码 position-independent code，通过全局偏移量表实现，但是有性能缺陷。</p>
<p>因而ELF有延迟绑定lazy binding技术，通过GOT和PLT。</p>
<p>GOT[1] 是连接器标识信息，GOT[2] 是连接器入口点</p>
<p>调用时控制传递到PLT中，然后通过GOT做间接跳转。第一次调用时，GOT跳转回PLT下一条指令，通过将标识信息压入栈中并跳转动态链接器，覆盖GOT跳转地址。以后调用时，只是间接引用而没有额外开销。</p>
</blockquote>
<p><u>应用程序还可能在运行时要求链接共享库而无需在编译时链接。（dlopen、dlsym、dlclose）</u></p>
<h3 id="异常控制流（Exception-Control-Flow）"><a href="#异常控制流（Exception-Control-Flow）" class="headerlink" title="异常控制流（Exception Control Flow）"></a>异常控制流（Exception Control Flow）</h3><p>异常处理是在内核模式（kernel mode）</p>
<p>每个异常有一个异常号。异常可分为四类</p>
<ul>
<li>中断 interrupt：来自I/O设备，异步</li>
<li>陷阱 trap：有意的异常，提供系统调用接口，比如system call</li>
<li>故障 fault</li>
<li>终止 abort</li>
</ul>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>一个执行中的程序的实例</p>
<ul>
<li>独立的逻辑控制流</li>
<li>私有的地址空间</li>
</ul>
<p>内核为每个进程维持一个上下文context，内核通过上下文切换context switch来实现多任务。在进程执行的某些时刻，内核可以通过调度器进行调度schedule，选择一个新的进程运行。</p>
<p>获取ID getpid（进程PID） getppid（父进程PID）</p>
<p><u>fork在新的子进程中运行相同程序，而execve函数在当前进程上下文加载并运行新程序，会覆盖当前进程的地址，仍然有相同的PID。Unix和Web服务器大量使用fork和execve。</u></p>
<h3 id="回收子进程"><a href="#回收子进程" class="headerlink" title="回收子进程"></a>回收子进程</h3><p>终止而未被回收的称为僵死进程zombie，它们仍然消耗系统资源。</p>
<ul>
<li>判定等待集合成员 pid</li>
<li>修改默认行为 WNOHANG 和 WUNTRACED</li>
<li>waitpid函数</li>
<li>检查已回收子进程的退出状态 WIFEXITED等 见wait.h</li>
<li>错误条件：没有子进程 waitpid=-1 ECHILD/被信号中断 返回-1 EINTR</li>
</ul>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>Unix信号允许进程中断其他进程。</p>
<p>一个发送而没被接受的信号为待处理信号pending signal。一个类型至多只有一个待处理信号，多余的会简单丢弃。一个待处理信号只能被接受一次。</p>
<p>发送信号的机制基于进程组。一个负的PID会导致信号被发送到进程组PID中的每个进程。</p>
<p>可以通过signal函数修改接收到信号的默认行为。</p>
<p>几个信号处理中的问题</p>
<ul>
<li>信号会阻塞和不会排队等待：改成while尽可能多的接收信号</li>
<li>系统调用被中断的可能性：while手动重启</li>
</ul>
<p>Signal是sigaction的一个包装函数，提供了可移植的信号处理。</p>
<p>sigprocmask显式改变阻塞信号集合。</p>
<p><u>同步流以避免并发问题。这个问题称之为竞争race，通过阻塞信号来就解决。暴露竞争的问题的方法就是随机决定父进程和子进程执行的顺序。</u></p>
<h3 id="非本地跳转"><a href="#非本地跳转" class="headerlink" title="非本地跳转"></a>非本地跳转</h3><p>用户级异常控制流，直接从一个函数跳转另一个函数。</p>
<p>setjmp和longjump（catch相当于setjmp，throw相当于longjump</p>
<h3 id="虚拟存储器VM"><a href="#虚拟存储器VM" class="headerlink" title="虚拟存储器VM"></a>虚拟存储器VM</h3><p>虚拟寻址时，CPU生成虚拟地址来访问主存。</p>
<p><img src="pte.png" alt=""></p>
<p>这里DRAM缓存是全相连的。</p>
<p><u>页面调度</u></p>
<p>虚拟存储器作为存储器管理工具</p>
<ul>
<li>简化链接</li>
<li>简化加载</li>
<li>简化共享</li>
<li>简化存储器分配</li>
</ul>
<p>同时能通过读写权限控制保护存储器。</p>
<h3 id="地址翻译"><a href="#地址翻译" class="headerlink" title="地址翻译"></a>地址翻译</h3><p>符号定义</p>
<ul>
<li>N 虚拟空间地址数 M 物理空间地址数 P 页大小</li>
<li>VPO 虚拟页面偏移 VPN 虚拟页号 </li>
<li>TLBI TLB索引 TLBT TLB标记</li>
<li>PPO 物理页面偏移 PPN 物理页号</li>
<li>CO 缓冲块偏移</li>
<li>CI 高速缓存索引 CT 高速缓存标记</li>
</ul>
<p>地址翻译：虚拟地址空间VAS到物理地址空间PAS的映射</p>
<p><img src="translate.png" alt=""></p>
<p>MMU利用VPN选择适当的PTE，得到PPN，PPO和VPO是相同的。</p>
<p><u>利用TLB加速地址翻译：TLB是个小的虚拟寻址的缓存，每行保存一个PTE块。VPN的t个低位组成TLB索引，其余n-p-t位是TLB标记。</u></p>
<p><u>每次MMU从TLB取出相应PTE，如果TLB不命中，则从L1缓存取出PTE并存放在TLB。</u></p>
<p><img src="tlb.png" alt=""></p>
<p><u>多级页表：减小主存压力，地址翻译也并不比单级页表慢很多。</u></p>
<p>Core i7地址翻译概况如下</p>
<p><img src="corei7translate.png" alt=""></p>
<p><u>优化地址翻译：CPU翻译时，发送VPN到MMU，发送VPO到L1，同时进行。</u></p>
<h3 id="存储器映射"><a href="#存储器映射" class="headerlink" title="存储器映射"></a>存储器映射</h3><p>存储器映射是将虚拟存储器区域和一个磁盘上的对象关联起来。这个对象可以是普通文件，也可以是匿名文件。一旦一个虚拟页面被初始化了，就在一个专门的交换文件（也叫做交换空间或交换区域）之间转换。</p>
<p><u>一个对象可以被映射到虚拟存储器的一个区域，要么作为共享对象，要么作为私有对象。共享对象即使被映射到了多个共享区域，也只需存放它的一个拷贝。私有对象使用写时拷贝copy-on-write的技术充分使用了稀有的物理存储器。</u></p>
<h3 id="动态存储器分配"><a href="#动态存储器分配" class="headerlink" title="动态存储器分配"></a>动态存储器分配</h3><p>低级的mmap和munmap可以创建和删除虚拟存储器的区域。</p>
<p>动态存储器分配dynamic memory allocater更方便且更好移植。它维护一个进程的虚拟存储器区域，称为堆heap。每个进程维护一个brk，指向堆的顶部。</p>
<ul>
<li><p>显式分配</p>
<p>malloc和free（C++里的new和delete）</p>
<p>想要已初始化的动态存储calloc，改变已分配块大小realloc</p>
<p>sbrk通过移动brk指针来改变堆</p>
</li>
<li><p>隐式分配</p>
<p>也叫垃圾收集器，自动释放未使用的已分配块，见JAVA等高级语言。</p>
</li>
</ul>
<p>分配器的目标</p>
<ul>
<li><p>最大化吞吐率</p>
</li>
<li><p>最大化利用率</p>
<p>利用率低是因为碎片fragmentation</p>
<ul>
<li>内部碎片：已分配块比有效载荷大（对齐约束）</li>
<li>外部碎片：组织/放置/分割/合并 空闲块（空闲链表）</li>
</ul>
</li>
</ul>
<h3 id="隐式空闲链表"><a href="#隐式空闲链表" class="headerlink" title="隐式空闲链表"></a>隐式空闲链表</h3><p>因为双字的对齐约束，块大小总是8的倍数，块大小最低三位总是0，所以只需存储块大小的29个高位，剩余3位编码其他信息。1表示已分配，0表示空闲。</p>
<p><img src="list.png" alt=""></p>
<p>优点是简单，缺点是开销与块总数呈线性关系。</p>
<p>放置策略：首次适配、下次适配（对首次适配的改进）、最佳适配</p>
<p>合并策略：立即合并（会产生抖动？）、推迟合并</p>
<p><u>Knuth提出边界标记（boundary tag），通过在块结尾处添加脚部（头部的副本），允许常数时间内对前面块进行合并。</u></p>
<h5 id="显式空闲链表"><a href="#显式空闲链表" class="headerlink" title="显式空闲链表"></a>显式空闲链表</h5><p>加入pred和succ的指针，使得开销与<strong>空闲块</strong>总数呈线性关系</p>
<p>缺点是空闲块必须足够大，潜在提高了内部碎片程度</p>
<h5 id="分离的空闲链表"><a href="#分离的空闲链表" class="headerlink" title="分离的空闲链表"></a>分离的空闲链表</h5><p>维护多个空闲链表，每个表中块大小大致相等</p>
<ul>
<li>简单分离存储：快速但是容易造成碎片</li>
<li>分离适配：GNU malloc就是这种方法</li>
<li>伙伴系统：特殊的分离适配，都是2的幂次；块地址和伙伴地址只有一位不同、主要缺点是要求块大小为2的幂次，导致显著的内部碎片。</li>
</ul>
<h5 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h5><p>C和C++保守的垃圾收集器：每个可达的都被正确标记了，但一些不可达的也被错误标记为可达了（因为int或float可以伪装成指针，而收集器无法判断）</p>
<p>Mark&amp;Sweep：由于C的保守，需要维护一个已分配块的平衡二叉树</p>
<h3 id="常见存储器错误"><a href="#常见存储器错误" class="headerlink" title="常见存储器错误"></a>常见存储器错误</h3><ul>
<li>间接引用坏指针：错误的把int或float当做指针</li>
<li>读未初始化的存储器：<strong>堆存储器</strong>不总是初始化为零，正确方法是用calloc代替malloc或者显式初始化</li>
<li>缓冲区溢出</li>
<li>假设指针和对象相同大小</li>
<li>引用不存在的变量/空闲堆栈</li>
<li>存储器泄露（不释放空间）</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/29/csapp5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hulieu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hulieu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/29/csapp5/" class="post-title-link" itemprop="url">从二开始的汇编</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-29 13:41:03" itemprop="dateCreated datePublished" datetime="2020-01-29T13:41:03+08:00">2020-01-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-20 11:00:29" itemprop="dateModified" datetime="2020-03-20T11:00:29+08:00">2020-03-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%8C%AB%E7%88%AA%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">猫爪记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%8C%AB%E7%88%AA%E8%AE%B0/Computer-Science/" itemprop="url" rel="index"><span itemprop="name">Computer-Science</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="编写高效程序"><a href="#编写高效程序" class="headerlink" title="编写高效程序"></a>编写高效程序</h3><ul>
<li>合适的算法和数据结构</li>
<li>高效执行的源代码</li>
</ul>
<p>GCC 命令行标志 -01 到 -03 提供不同程度的优化</p>
<p>妨碍优化的几个因素</p>
<ul>
<li><p>存储器别名使用：两个指针可能指向同一个存储器</p>
</li>
<li><p>函数调用：大多数编译器不会判断函数是否有副作用，并保持所有函数调用不变</p>
<p>可以使用内联函数替换（将函数代码展开）对此进行优化（-finline或者-02以上）</p>
</li>
</ul>
<p>运行时间可以通过最小二乘拟合得到，线性因子系数称为每元素的周期数（CPE）的有效数</p>
<p>CPE是主要的优化目标</p>
<p>两种优化界限：</p>
<ul>
<li>延迟界限：指令级并行的能力</li>
<li>吞吐量界限：终极限制，处理器功能单元的计算能力</li>
</ul>
<p>整体操作：分为指令控制单元ICU和执行单元EU，可以乱序执行指令</p>
<p>功能单元的性能：</p>
<ul>
<li>延迟：完成运算总时间</li>
<li>发射：连续运算需要的时钟周期数，发射时间为1即为完全流水线化的</li>
</ul>
<h3 id="循环里的优化"><a href="#循环里的优化" class="headerlink" title="循环里的优化"></a>循环里的优化</h3><ul>
<li>代码移动：将strlen或vec_length的计算移出循环（特别是strlen，因为它是O(n)的）</li>
<li>减少过程调用</li>
<li>减少不必要的存储调用：在临时变量里存放结果代替直接访问</li>
<li>-02 的优化：会最后将结果写到目标位置，而不是重复读写</li>
<li><u>循环展开：通过增加每次迭代计算的元素数量，减少循环迭代次数。比如在求数组累加和的时候，每次计算两个元素。因为减少了循环分支以及减少了关键路径操作数量，可以提升延迟界限。但是并不能提升浮点数计算的CPE。</u></li>
<li><u>并行计算：将一组合并运算分割成两个或更多的部分，最后合并结果以提高性能。但是需要注意浮点乘法和加法由于四舍五入或溢出的不可结合性，可能会改变最终结果。</u></li>
<li><u>重新结合变换：在循环中改变元素合并顺序，减少关键路径操作。同上，可能改变最终结果。</u></li>
</ul>
<p>高级设计、编码原则、低级优化</p>
<h3 id="SIMD"><a href="#SIMD" class="headerlink" title="SIMD"></a>SIMD</h3><p>SSE=Streaming SIMD Extensions</p>
<p>SIMD是单指令多数据Single-Instruction, Multiple-Data</p>
<p>16字节的XMM可以存放多个值，因此指令会读取多个值并行计算</p>
<p>-msse4</p>
<h3 id="一些限制"><a href="#一些限制" class="headerlink" title="一些限制"></a>一些限制</h3><ul>
<li>寄存器溢出</li>
<li>分支预测和预测错误处罚<ul>
<li>可预测的分支不太影响</li>
<li>使用功能式风格的代码（用条件操作计算值），而非命令式（用条件语句来选择更新）</li>
</ul>
</li>
<li>加载/存储性能</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li><p>程序剖析 GCC -pg </p>
</li>
<li><p>Amdahl定律 </p>
<p>加速比S，其中\alpha是加速部分所占时间比例，k是加速到的倍数。</p>
<script type="math/tex; mode=display">
S=\frac{1}{1-\alpha+\alpha/k}</script></li>
</ul>
<h3 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h3><ul>
<li>高速缓存存储器</li>
<li>主存储器</li>
<li>磁盘</li>
</ul>
<p><img src="memory.png" alt=""></p>
<p>随机访问存储器（RAM），SRAM更快更贵，作为高速存储，一般不超过几MB，而DRAM有可以有几GB</p>
<ul>
<li><p>静态RAM（SRAM）</p>
<p>存储在双稳态单元，用六晶体管来实现，可以无限保持在两个不同状态，其他状态都是不稳定的，即使有干扰，也能在干扰消除时恢复稳态。</p>
</li>
<li><p>动态RAM（DRAM）</p>
<p>存储为对一个电容充电，因此对干扰敏感。</p>
</li>
<li><p>传统DRAM</p>
<p>DRAM芯片中的单元被分成d个超单元(supercell)，每个超单元有w个DRAM单元，信息通过引脚(pin)流入流出。</p>
</li>
<li><p>存储器模块</p>
<p>DRAM芯片包装在存储器模块里，常见的168引脚的双列直插存储器模块DIMM，以64位为块，也有72个引脚的单列直插存储器模块SIMM，以32位为块。存储器将地址A转换为超单元地址，然后广播到每个DRAM，每个DRAM输出超单元地址处的8位内容，然后将他们合并为64位双字。</p>
</li>
<li><p>增强的DRAM</p>
<ul>
<li>快页模式 FPM DRAM 允许对同一行连续地址从缓存区访问</li>
<li>扩展数据输出 EDO DRAM 允许单独CAS信号时间上更紧密</li>
<li>同步 SDRAM 用外部时钟信号上升代替控制信号，输出更快</li>
<li>双倍速率同步DRAM（DDR SDRAM）通过两个时钟作为控制，不同DDR是根据预取缓存区大小来划分的 DDR（2位）DDR2（4位） DDR3（8位）</li>
<li>Rambus DRAM 最大带宽更高</li>
<li>视频RAM（Video RAM） 对内部缓存区整个内容移位</li>
</ul>
</li>
<li><p>非易失性存储器</p>
<p>即使断电也能保存，ROM、PROM、EPROM、EEPROM、闪存</p>
</li>
<li><p>读取主存</p>
<p>I/O通过主线(bus)</p>
</li>
</ul>
<h3 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h3><p>磁盘存储，比DRAM慢10万倍，比SRAM慢100万倍。</p>
<p>磁盘由多个盘片（platter）构成，盘片有表面（surface）和主轴（spindle），有固定的旋转速率（54k-150k RPM）。每个表面是一组同心圆（磁道track）组成，每个磁道划分为一组扇区（sector）用以储存等长的数据，扇区之间有间隙（gap）。</p>
<p>磁盘操作时，通过传动臂（actuator arm）连接到读写头，通过寻道（seek）定位到磁道上，然后进行读写。读写时间=寻道时间+旋转时间+传送时间，其中寻道时间和旋转延迟大致相等。</p>
<p>磁盘还有逻辑磁盘块，维护逻辑块好和磁盘扇区的映射关系。</p>
<p>连接到I/O设备：通用串行总线（USB）、图形卡、主机总线适配器（将磁盘连接到I/O总线，包括SCSI和SATA）</p>
<p><img src="IObus.png" alt=""></p>
<p>磁盘控制器收到CPU读命令后，将逻辑块号翻译成扇区地址，然后将这些内容直接传送到主存，不需要CPU干涉，称为直接存储器访问（DMA）。</p>
<p>固态硬盘 SSD：基于闪存技术，更快能耗也更低。</p>
<p>趋势：降低成本（增加密度）比降低访问时间更容易。</p>
<h3 id="局部性"><a href="#局部性" class="headerlink" title="局部性"></a>局部性</h3><p>DRAM和磁盘的性能滞后于CPU的性能。现代计算机频繁使用基于SRAM的高速缓存试图弥补这一差距（利用局部性）。</p>
<p>一个编写良好的程序具有良好的局部性（倾向于引用最近引用数据的邻近数据或其本身）。</p>
<p>步长为k的引用模式：stride-k reference pattern，一个连续向量中，每隔k个元素进行访问，随着步长的增加，空间局部性下降。步长为1的引用模式有良好的空间局部性。</p>
<p>取指令的局部性：循环具有好的时间局部性。</p>
<h3 id="存储器层次结构"><a href="#存储器层次结构" class="headerlink" title="存储器层次结构"></a>存储器层次结构</h3><p>离CPU越远的存储器缓存越大，延迟越高，传送的块越大。</p>
<p>核心思想是k层的存储设备作为k+1层的存储设备的缓存</p>
<ul>
<li>缓存命中</li>
<li>缓存不命中<ul>
<li>冷缓存（强制性不命中）：缓存是空的</li>
<li>冲突不命中</li>
<li>容量不命中</li>
</ul>
</li>
</ul>
<p>高速缓存（S，E，B，m）的通用组织：S个高速缓存组数组，每个组含有E个高速缓存行，每个行有B字节的数据块，1个有效位和t个标记位。m个地址划分为t个标记位，s个组索引位和b个块偏移位。</p>
<p><img src="cache.png" alt=""></p>
<p><u>抖动冲突不命中问题：即使有良好的空间局部性，引用还是会导致冲突不命中，因为这些块被映射到了同一个高速缓存组，一个简单的方法就是在数组结尾放B子节的填充。</u></p>
<p><u>用中间位做索引，使得连续存储器映射到不同的高速缓存块。</u></p>
<p>写的问题：</p>
<ul>
<li>直写 write-through</li>
<li>写回 write-back 块要被驱逐时才更新存储器，能显著减少总线流量，但是需要维护额外的修改位</li>
<li>写分配 write-allocate（加载之后写）/ 非写分配 not-write-allocate</li>
</ul>
<p><u>越往下层传送时间更差，因此越可能使用写回。</u></p>
<p>举例：矩阵乘法 C=AB</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>乘法版本</th>
<th>存储次数</th>
<th>A不命中次数</th>
<th>B不命中次数</th>
<th>C不命中次数</th>
</tr>
</thead>
<tbody>
<tr>
<td>ijk&amp;jik</td>
<td>0</td>
<td>0.25</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>jki&amp;kji</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>kij&amp;ikj</td>
<td>1</td>
<td>0</td>
<td>0.25</td>
<td>0.25</td>
</tr>
</tbody>
</table>
</div>
<p>kij和ikj性能最好。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/29/2020%E5%B9%B4%E5%88%9D%E7%9A%84%E5%87%A0%E9%83%A8%E7%94%B5%E5%BD%B1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hulieu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hulieu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/29/2020%E5%B9%B4%E5%88%9D%E7%9A%84%E5%87%A0%E9%83%A8%E7%94%B5%E5%BD%B1/" class="post-title-link" itemprop="url">2020年初的几部电影</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-29 12:04:30" itemprop="dateCreated datePublished" datetime="2020-01-29T12:04:30+08:00">2020-01-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-13 19:15:17" itemprop="dateModified" datetime="2020-02-13T19:15:17+08:00">2020-02-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%96%B5%E5%90%8E%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">喵后记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="教宗的承继-8-5-10"><a href="#教宗的承继-8-5-10" class="headerlink" title="教宗的承继 8.5/10"></a>教宗的承继 8.5/10</h3><p>源自真实的故事，讲述了2013年罗马教皇权力更迭背后的故事。剧情简介可以参看豆瓣</p>
<blockquote>
<p>主教贝尔格利奥对教会的发展方向感到十分失望，因此向教皇本笃申请在 2012 年退休。然而，面对丑闻和自我怀疑，善于内省的教皇本笃召见对他最严厉的批判者和未来的继任者来到罗马，在梵蒂冈的围墙之内，展开了一场传统与进步、罪恶与宽恕之间的斗争，这两位截然不同的人直面各自的过去，以图寻找共同点，以及为全世界十亿信徒开创未来。</p>
</blockquote>
<p>影片基于两位教皇的观点展开演绎，本笃十六世象征着保守，本片中也处处表现出保守和传统，比如强调宗教的意义，提出对传统的恢复；而方济各一世则代表着自由主义，他批评教会和教宗，在底层的人群中受到欢迎。以方济各向本笃申请退休为契机，两人在梵蒂冈相会。借着这两位教皇对于教会发展方向的深入探讨，影片试图表达自己在其中的观点。</p>
<p>来自南美洲的导演费尔南多无疑是阿根廷人方济各的支持者，在片中方济各表现出近乎完美的形象：进步现代、关注经济、关心民众、抨击教会弊端，而本笃十六世只能在方济各的各种问题的责问下无力地表示</p>
<blockquote>
<p>I don’t agree with anything you just said。</p>
</blockquote>
<p>在片中，为了展现出全面的自由主义的胜利，本笃表示”听不到上帝的声音了“，因而要退位；而那个不时出现打断剧情的提醒他步行的医疗仪器也似乎为了反衬他的保守。但是，我们可以看到，片中着重讲述了方济各的过去，但是对本笃的过去却没有多少笔墨。影片关注了方济各指出的教会内部腐败的问题、经济问题、贫民问题，但也没能回答本笃关注的同性恋、宗教意义的问题。我们很难说对于一个教宗而言，哪一个问题更加重要。</p>
<p>当然，作为一部电影而言，无疑是成功的。两位教皇用拉丁语/西班牙语/英语轮番探讨宗教的意义显得很decent。看到两位爷爷一起吃披萨、看足球，甚至一起跳探戈、讨论beatles，就是一件很有趣的事情了。（虽然说我是不信的……但方济各一直以来的形象确实能支撑起这样的剧情。</p>
<p>最后我还是觉得方济各就是宗教界的戈尔巴乔夫。</p>
<h3 id="囧妈-6-0-10"><a href="#囧妈-6-0-10" class="headerlink" title="囧妈 6.0/10"></a>囧妈 6.0/10</h3><p>囧妈大火无疑是占了大年初一抖音免费观看的热度。（虽然我觉得确实是很有意义的一种尝试，但还是要说，徐峥聪明在于商人而非导演</p>
<p>囧妈的剧本完成度比较差（就算是小成本电影），相比于它的几部前作也大大不如。影片分两线，一条是主角和母亲的感情线，另一条是主角和妻子的感情/商业竞争线。前一条线是主线，后一条线就显得无关紧要，感觉有强行附会的嫌疑。</p>
<p>在妻子感情线里，把主角母亲想控制主角的心情等同于主角想控制主角妻子的心情，这是完全不同的感情啊，毕竟主角和妻子从没有表现出“爱情”，而看得出主角母亲溢出屏幕的母爱。影片塑造了一个近乎完美的妻子：性格独立、工作能力强、孝敬主角母亲，而主角一直不肯离婚，乃至在妻子的事业不断制造麻烦的唯一理由就是一句轻描淡写的”还爱着“，这是何等的扭曲啊。</p>
<p>主线里母亲为了圆梦莫斯科大剧院表演，坐火车去莫斯科（这里我就不吐槽身为负责人怎么这么随便了），主角由于意外决定陪母亲去。明显由于母子这个主题没有很好的素材，影片成了很多段与主题无关的独立故事的合集。俄罗斯娜塔莎突然出现，和主角一路缠绵，然后飘然下车；母亲下车后遭遇熊出没，得到猎人解救（典型的机械降神）；赶不上火车，然后乘着热气球感到剧院……整个故事充满着机械降神的情节，而缺乏整体的连贯性。</p>
<p>最后说一下这部影片的优点，第一肯定是特殊时期娱乐大众，第二是母亲这个主题表现得有点做作，不过可以接受，第三是贾冰这个列车员可以（他在春晚的小品也可以）。</p>
<h3 id="1917-8-0-10"><a href="#1917-8-0-10" class="headerlink" title="1917 8.0/10"></a>1917 8.0/10</h3><p>传闻中的一镜到底（虽然是伪一镜，但都是长镜头的组合</p>
<p>整体的故事性偏弱，情节没有太突出的地方</p>
<blockquote>
<p>1917年，第一次世界大战进入最激烈之际，两个年仅16岁的英国士兵接到的命令，需立即赶往死亡前线，向那里的将军传达一个“立刻停止进攻”讯息。 时间只有八小时，武器弹药有限，无人知晓前方敌况：死亡寂静之地、布满尸体的铁丝网、突入其来的敌军、随时毙命的危险境况…… </p>
</blockquote>
<p>一镜到底确实有很好的代入感，看得出导演和演员在拍摄中应该付出了比寻常多几倍的努力。抛开外在形式上的创新，这部电影也有感人之处。</p>
<p>下士Schofield片头到片尾都是靠在树下休息，但可以想到，经历了这么多他的心境一定不一样了；将军说的一段话（今天撤退，明天又要进攻，反反复复的命令更加折磨）虽然不深刻，但是直击人心。另外教堂那一段的光影效果值得关注一下。</p>
<h3 id="利刃出鞘-8-5-10"><a href="#利刃出鞘-8-5-10" class="headerlink" title="利刃出鞘  8.5/10"></a>利刃出鞘  8.5/10</h3><p>原以为是一部本格推理，但是和我想的不太一样。整个推理没什么大的漏洞，硬要说就是警察太菜了，不仅第一时间的证据找不到，还让人炸了证据中心……</p>
<p>电影开头对每个人有一段问询，每个人都说了一些假话，侦探007（丹尼尔·克雷格）轻易地推理出了每个人隐瞒了什么秘密。然后….影片直接告诉了我们整个作案过程，之后就是最后的大反转。<strong>这是一部悬疑喜剧，而非烧脑的推理剧。</strong></p>
<p>值得一提的是，片中藏了很多小彩蛋，还有政治隐喻。比如</p>
<blockquote>
<p>贵为美国白人的众卿家内讧一无所获，仰望着从巴基斯坦人手里买来的生父老宅； 身为巴西移民的本宫站在老宅阳台，端起“My House My Rules My Coffee”杯具轻呷，俯视着一切。 哈哈哈哈……吐！</p>
</blockquote>
<p>就是<em>粉刺</em>川普大帝的移民政策。还有那个用装饰画挡住的窗，也暗指了偷渡。</p>
<h3 id="别告诉她-7-5-10"><a href="#别告诉她-7-5-10" class="headerlink" title="别告诉她 7.5/10"></a>别告诉她 7.5/10</h3><p>偶然看见的电影，故事并不复杂</p>
<blockquote>
<p>影片讲述一个华人家庭的奶奶被诊断罹癌，但家人选择隐瞒奶奶，假借一场婚礼的名义让所有家人回家见奶奶最后一面，但在纽约长大的碧莉（奥卡菲娜饰演）认为知道自己病况是奶奶的人权，因此在华人家庭中上演一场中西文化冲突，一部寻根家庭喜剧。</p>
</blockquote>
<p>整体上探讨了中西文化，但是影片却意外地西方。相比之下，我猜导演更了解西方（或者为了面向西方社会），所以对于西方的个人主义和bili所主张的知情权有较为深刻的认识，而对中国的人情只有一句“生命是集体的”来概括。整体比较轻松，观影体验还行。</p>
<h3 id="哪吒之魔童降世7-5-10"><a href="#哪吒之魔童降世7-5-10" class="headerlink" title="哪吒之魔童降世7.5/10"></a>哪吒之魔童降世7.5/10</h3><p>去年以来名声很大的一部动画电影</p>
<blockquote>
<p>天地灵气孕育出一颗能量巨大的混元珠，元始天尊将混元珠提炼成灵珠和魔丸，灵珠投胎为人，助周伐纣时可堪大用；而魔丸则会诞出魔王，为祸人间。元始天尊启动了天劫咒语，3年后天雷将会降临，摧毁魔丸。太乙受命将灵珠托生于陈塘关李靖家的儿子哪吒身上。然而阴差阳错，灵珠和魔丸竟然被掉包。本应是灵珠英雄的哪吒却成了混世大魔王。调皮捣蛋顽劣不堪的哪吒却徒有一颗做英雄的心。然而面对众人对魔丸的误解和即将来临的天雷的降临，哪吒是否命中注定会立地成魔？他将何去何从？</p>
</blockquote>
<p>动画效果感觉比不上玄机娘娘（反正都是“国产动漫最高水平“啦）</p>
<p>细细看完，却发现设定上有问题。哪吒生性顽劣因为魔丸附身（考虑到哪吒对关心爱护他的父母师父也这么残暴），那么灵丸附身的小龙就不会因为龙族水淹陈塘关了。</p>
<p>更重要的是，仔细一想这部电影三观并不是那么正。哪吒魔丸附身，被村民视为妖怪，之后再李靖等人的感化之下，想要反抗命运。但是那句高燃台词“我命由我不由天”却是对小龙喊出的；而在天尊引天雷的时候，哪吒却束手就擒。细想之下，是魔丸还是灵丸本是天尊所定，那些村民不过是无知的愚民罢了，而真正应该反抗的命运应该是天尊（或者其化身天雷）。影片消解了这层对天的反抗，就退化成了纨绔子弟哪吒作威作福多年终于良心发现的故事了。</p>
<h3 id="爱尔兰人-9-5-10"><a href="#爱尔兰人-9-5-10" class="headerlink" title="爱尔兰人 9.5/10"></a>爱尔兰人 9.5/10</h3><p>爱尔兰人没能得奥斯卡奖很可惜（虽然因为《教父》在前，这也是必然的</p>
<blockquote>
<p>　　《爱尔兰人》为马丁·斯科塞斯执导的传奇巨制，罗伯特·德尼罗、阿尔·帕西诺和乔·佩西主演。通过二战老兵弗兰克·希兰的视角，讲述了战后美国有组织犯罪的故事。弗兰克·希兰是一名骗子和杀手，曾经在 20 世纪最恶名昭彰的人物身边工作。该电影跨越数十年，记录了美国历史上最大的悬案之一，即传奇工会领袖吉米·霍法失踪案，以宏大的故事之旅，展现有组织犯罪的隐秘通道：其内部运作、仇敌以及与主流政治的瓜葛。</p>
</blockquote>
<p>电影属于半纪实的性质，讲述了黑帮的往事。电影中的很多事情都是历史上的悬案，很难说黑帮的这些人物到底在里面参与了多少。整部电影很明显带着《教父》的风格（从整体的布景、到人物的谈吐甚至是四个小时的片长），讲述故事的方式也有《阿甘正传》的味道（意外参与了当时的重大事件的感觉），以主角黑帮杀手Frank Sheeran的视角展开意识流的叙事。</p>
<p>整部片中没有什么伟光正的人物，气氛都比较压抑。三个老戏骨扮演着三个黑道的重要人物，互相飙戏确实精彩（虽然都不是什么好人</p>
<p>Frank作为黑帮杀手，冷酷无情而且计划周密，是个心狠手辣的人物。他因为工会的起诉搭上了黑帮的船，而后一步步成长为令人闻风丧胆的“爱尔兰人”。影片从Frank的自传改编，选取了一些看起来比较可信的片段（虽然也很大一部分不可考证，依旧被认为悬案）。Frank对于生死的思考是超越常人的（当然不是说这种理解是正确的），他对黑帮的一切都感到坦然，因而保持着绝对的冷静，到最后一刻问及Hoffa的死时第一反应还是找律师。可以说，电影塑造的Frank的形象，诠释了一个近乎完美的黑帮杀手。</p>
<p>Russell是黑帮大佬，提携Frank的恩人。地位很高，但是身形很小，说话很轻柔。片中表现的性格还是比较单一的（当然演技没的说</p>
<p>Jimmy Hoffa是历史上的传奇人物，创立了美国分布最广的工会，鼎盛时有两百三十万会员，而最后又神秘失踪，称为一桩悬案。剧里的Hoffa也表现出了对工会的热爱和重视，他在重新夺回工会的时候揭露黑帮和工会的内幕交易也并非只是为了竞选，相比之下他可能不是那么“黑帮”，所以最后Hoffa一定会和黑帮分道扬镳。</p>
<p>最后Frank杀Hoffa这段是全剧的高潮，整个刺杀行动策划的看着随意，实则周密。比如对一切一无所知的大侄子运送Frank和Hoffa，降低了Hoffa的警惕心；Frank必须亲手杀了Hoffa，一方面为了让Hoffa彻底放心，另一方面也为了表明立场。刺杀过程中也有死鱼的暗喻这样的表现手法，Frank一瞬间的犹豫……在Hoffa被刺杀之后的四十分钟倒显得比较平淡，这些辉煌一时的黑帮大佬也都渐渐老去（情节虽然缓和，镜头也放的很慢，但就是有一种深深的悲凉？</p>
<p>最后片中两句著名的黑话（看了影评才懂…当时就这么划过去了</p>
<blockquote>
<p>Jimmy Hoffa：”I heard you paint houses“</p>
<p>Frank Sheeran：”I do my own carpentry work, too.” </p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/12/%E5%90%89%E6%96%AF%E5%B0%BC%E4%BA%9A%E4%BC%A0%E5%A5%8701/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hulieu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hulieu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/12/%E5%90%89%E6%96%AF%E5%B0%BC%E4%BA%9A%E4%BC%A0%E5%A5%8701/" class="post-title-link" itemprop="url">吉斯尼亚传奇</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-12 19:59:31 / Modified: 13:16:31" itemprop="dateCreated datePublished" datetime="2020-01-12T19:59:31+08:00">2020-01-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%89%E6%96%AF%E5%B0%BC%E4%BA%9A%E4%BC%A0%E5%A5%87/" itemprop="url" rel="index"><span itemprop="name">吉斯尼亚传奇</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="序章：初雪"><a href="#序章：初雪" class="headerlink" title="序章：初雪"></a>序章：初雪</h2><p>​        今年的冬天虽然来得晚了些，但是来得够快。十二月初的时候，京城还像是延续刚刚过去的夏天一样，温暖的仿佛阳春三月。然而人们根本没有想到，寒气来的迅猛，就连北面大兴安岭绵延的山脉，也只能略微延缓寒气南下的步伐。短短几天里，凛冬真的来了，京城冷的像另一个世界。永定河结起了薄冰，西山上萧瑟地立着满山枯木，庭院里只有几枝梅花迎风傲立，人们都已经不愿意出门了，街上仅存的行人也都把自己裹得严严实实。<br>​        罗一成清早就出门了，带着他的行李箱，迎着略有些刺骨的微风，登上了前往机场的列车。由于才刚刚过七点，车上还很空，罗一成随意地坐下了。他看向窗外，只见清冷的早晨，整个城市都昏昏沉沉；加上这是个没有生气的季节，平日里喜爱热闹的鸟儿，也消踪匿迹了，一切都显得灰蒙蒙的。<br>​        列车跑的很快，罗一成的思绪没有飘多远，就发现自己已经出了城。城外的这一站，平日就没什么人，罗一成心想，他往车里挪了挪，以躲避车外的冷风。一声提示音响起来，车厢的门整齐地打开了，猛地一阵风吹过，罗一成缩了缩脖子，那一瞬间他仿佛看见车外一只橘猫跑过，但仔细看去却没了踪迹。罗一成转头看去，却发现隔壁车厢不知何时上来了个三十岁左右的年轻人。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/10/csapp4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hulieu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hulieu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/10/csapp4/" class="post-title-link" itemprop="url">从一开始的汇编</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-10 15:49:05" itemprop="dateCreated datePublished" datetime="2020-01-10T15:49:05+08:00">2020-01-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-20 11:00:21" itemprop="dateModified" datetime="2020-03-20T11:00:21+08:00">2020-03-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%8C%AB%E7%88%AA%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">猫爪记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%8C%AB%E7%88%AA%E8%AE%B0/Computer-Science/" itemprop="url" rel="index"><span itemprop="name">Computer-Science</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Y86-一个玩具"><a href="#Y86-一个玩具" class="headerlink" title="Y86(一个玩具)"></a>Y86(一个玩具)</h3><p>定义Y86指令集只处理四字节的数据</p>
<p><img src="y86.png" alt=""></p>
<ul>
<li>将movl拆分成四个指令，显示指定源和目的。i表示立即数，r表示寄存器，m表示存储器。</li>
<li>OPl包含四个整数操作，分别是addl,subl,andl,xorl</li>
<li>三个条件码ZF、SF和OF</li>
<li>7个跳转指令jmp、jle、jl、je、jne、jge、jg</li>
<li>6个条件传送cmovle、cmovl、cmove、cmovne、cmovge、cmovg（属于rrmovl类）</li>
<li>call、ret、pushl、popl不变</li>
<li>halt相当于X86里的hlt，会直接导致处理器暂停</li>
</ul>
<p>指令集模拟器YIS</p>
<h3 id="HCL"><a href="#HCL" class="headerlink" title="HCL"></a>HCL</h3><p>位级电路-&gt;字级电路</p>
<p>多路复用电路</p>
<p>ALU（算术单元）：根据输入做一次算术运算</p>
<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>寄存器操作时，输出会一直保存在当前寄存器状态上，直到时钟信号上升。</p>
<p><img src="register.png" alt=""></p>
<p>这是一个典型的寄存器文件，这样一个多端口随机访问存储器允许同时进行多个读写操作。向寄存器文件写入字是由时钟信号控制的。</p>
<p><img src="register2.png" alt=""></p>
<p>数据存储器只有一个输入输出。</p>
<p><em>现实中更为复杂</em></p>
<h3 id="顺序实现"><a href="#顺序实现" class="headerlink" title="顺序实现"></a>顺序实现</h3><p>一个指令的各个阶段</p>
<ul>
<li>取指 fetch</li>
<li>解码 decode</li>
<li>执行 execute（包括计算和设置条件码）</li>
<li>访存 memory</li>
<li>写回 write back</li>
<li>更新PC PC update，将PC设置成下一条指令的地址</li>
</ul>
<p>大多数指令比较简单，最难实现的应该是pushl和popl（举例如下）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>阶段</th>
<th>call Dest</th>
<th>ret</th>
</tr>
</thead>
<tbody>
<tr>
<td>fetch</td>
<td>icode: ifun &lt;-M[PC]<br>valC&lt;-M[PC+1]<br>valP&lt;-PC+5</td>
<td>icode: ifun &lt;-M[PC]<br>valP&lt;-PC+1</td>
</tr>
<tr>
<td>decode</td>
<td>valB&lt;-R[%esp]</td>
<td>valA&lt;-R[%esp]<br>valB&lt;-R[%esp]</td>
</tr>
<tr>
<td>execute</td>
<td>valE&lt;-valB-4</td>
<td>valE&lt;-valB+4</td>
</tr>
<tr>
<td>memory</td>
<td>M[valE]&lt;-valP</td>
<td>valM&lt;-M[valA]</td>
</tr>
<tr>
<td>write back</td>
<td>R[%esp]&lt;-valE</td>
<td>R[%esp]&lt;-valE</td>
</tr>
<tr>
<td>PC update</td>
<td>PC&lt;-valC</td>
<td>PC&lt;-valM</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>阶段</th>
<th>pushl rA</th>
<th>popl rA</th>
</tr>
</thead>
<tbody>
<tr>
<td>fetch</td>
<td>icode: ifun &lt;-M[PC]<br> rA:rB&lt;-M[PC+1]</td>
<td>icode: ifun &lt;-M[PC]<br/> rA:rB&lt;-M[PC+1]</td>
</tr>
<tr>
<td>decode</td>
<td>valP&lt;-PC+2</td>
<td>valP&lt;-PC+2</td>
</tr>
<tr>
<td>execute</td>
<td>valA&lt;-R[rA] <br/>valB&lt;-R[%esp]</td>
<td>valA&lt;-R[%esp]<br/> valB&lt;-R[%esp]</td>
</tr>
<tr>
<td>memory</td>
<td>valE&lt;-valB+(-4)</td>
<td>valE&lt;-valB+4</td>
</tr>
<tr>
<td>write back</td>
<td>M[valE]&lt;-valA <br/>R[%esp]&lt;-valE</td>
<td>valM&lt;-M[valA]<br/> R[%esp]&lt;-valE <br/>R[rA]&lt;-valM</td>
</tr>
<tr>
<td>PC update</td>
<td>PC&lt;-valP</td>
<td>PC&lt;-valP</td>
</tr>
</tbody>
</table>
</div>
<p>一种顺序实现如下</p>
<p><img src="seq.png" alt=""></p>
<h3 id="SEQ实现"><a href="#SEQ实现" class="headerlink" title="SEQ实现"></a>SEQ实现</h3><p>所使用的常数如下（除了指令之外还包括了状态码）</p>
<p><img src="seqconstant.png" alt=""></p>
<h5 id="取指阶段"><a href="#取指阶段" class="headerlink" title="取指阶段"></a>取指阶段</h5><ul>
<li>instr_valid：合法指令</li>
<li>need_regids：包括寄存器指示符</li>
<li>need_valC：包含常数</li>
</ul>
<p><img src="seqfetch.png" alt=""></p>
<p>增加器产生值p+1+need_rigids+4*need_valC</p>
<h5 id="译码和写回阶段"><a href="#译码和写回阶段" class="headerlink" title="译码和写回阶段"></a>译码和写回阶段</h5><p><img src="seqfetch.png" alt=""></p>
<h5 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h5><p><img src="seqexecute.png" alt=""></p>
<h5 id="访存阶段"><a href="#访存阶段" class="headerlink" title="访存阶段"></a>访存阶段</h5><p><img src="seqmemory.png" alt=""></p>
<h5 id="更新PC阶段"><a href="#更新PC阶段" class="headerlink" title="更新PC阶段"></a>更新PC阶段</h5><p>HCL描述如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int new_pc &#x3D; [</span><br><span class="line">	icode &#x3D;&#x3D; ICALL: valC; # 调用</span><br><span class="line">	icode &#x3D;&#x3D; IJXX &amp;&amp; Cnd: valC; # 跳转</span><br><span class="line">	icode &#x3D;&#x3D; IRET: valM; # 返回</span><br><span class="line">	1: valP; # 默认</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<h3 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h3><p>SEQ的问题在于每个单元只在整个时钟周期的一部分时间里被使用</p>
<p>理想流水线：划分成n个相互独立的周期，每个阶段需要的时间是原来的1/n，其他因素：</p>
<ul>
<li>不一致的划分</li>
<li>流水线过深，反而降低收益（寄存器的延迟）</li>
</ul>
<p>现代处理器采用15或更深的流水线，因而需要划分指令的执行减小延迟、设计更好的流水线寄存器、设计时钟传播网络</p>
<p><u>带反馈的流水线：处理有数据相关的相邻指令</u></p>
<h3 id="Y86流水线的实现"><a href="#Y86流水线的实现" class="headerlink" title="Y86流水线的实现"></a>Y86流水线的实现</h3><h5 id="SEQ-：重新安排计算阶段"><a href="#SEQ-：重新安排计算阶段" class="headerlink" title="SEQ+：重新安排计算阶段"></a>SEQ+：重新安排计算阶段</h5><p>PC计算移到了时钟周期开始</p>
<p><img src="seq+.png" alt=""></p>
<h5 id="插入流水线寄存器"><a href="#插入流水线寄存器" class="headerlink" title="插入流水线寄存器"></a>插入流水线寄存器</h5><p><img src="pipe.png" alt=""></p>
<p>寄存器按以下方式标号</p>
<ul>
<li>F 保存计数器的预测值</li>
<li>D 保存指令信息</li>
<li>E 保存指令和寄存器文件读出的值</li>
<li>M 保存执行指令的结果</li>
<li>W 提供计算出来的值，提供返回地址</li>
</ul>
<h5 id="预测下一个PC"><a href="#预测下一个PC" class="headerlink" title="预测下一个PC"></a>预测下一个PC</h5><p>除了条件转移指令和ret之外，我们能够根据取指信息确定下一条指令地址。</p>
<p>这里分支预测总是预测选择了条件分支，预测PC为valC。 <u>这种预测成功率约为60%。其他还有根据分支地址高低进行预测（分支地址低则预测选择分支），成功率约为65%，这种改进源自循环是由后向分支结束这一事实。</u></p>
<p>ret只是简单地暂停处理新指令。<u>大多数程序可以利用栈顶的值作为预测的返回值。</u></p>
<h5 id="数据冒险"><a href="#数据冒险" class="headerlink" title="数据冒险"></a>数据冒险</h5><p>加入暂停（nop）自动产生的nop指令为气泡（bubble）</p>
<p><img src="bubble.png" alt=""></p>
<p>但这会导致流水线暂停过长，降低整体吞吐量。</p>
<p>解决方法是将要写的值传到流水线寄存器E作为源操作数。在译码阶段发现有写回阶段对寄存器未进行的写，则用这个值作为源操作数。</p>
<p>这样就有5个转发源e_valE,m_valM,M_valE,W_valM,W_valE</p>
<p>有两个不同的转发目的valA, valB</p>
<p>在结构中就是加入Sel+Fwd A和Fwd B的模块更新valA和valB</p>
<p><u>加载互锁和转发技术结合起来处理所有可能的数据冒险</u></p>
<h5 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h5><p>没有实际的异常指令</p>
<p>异常处理的几个细节</p>
<ul>
<li>多条指令引起异常</li>
<li>分支预测错误取消了异常指令</li>
<li>异常指令之后的指令改变了部分状态</li>
</ul>
<p><u>当处于访存或写回阶段中的指令导致异常时，流线控制逻辑必须禁止更新条件码或数据存储器。</u></p>
<h5 id="PIPE各阶段"><a href="#PIPE各阶段" class="headerlink" title="PIPE各阶段"></a>PIPE各阶段</h5><ul>
<li><p>取指：增加了f_pred</p>
</li>
<li><p>译码和写回：使用sel+fwd A和fwd B </p>
<p>五个转发源的顺序很重要，应该是e_dstE, m_valM, M_valE, W_valM, W_valE</p>
</li>
<li><p>执行阶段</p>
</li>
<li><p>访存阶段</p>
</li>
</ul>
<h5 id="控制逻辑"><a href="#控制逻辑" class="headerlink" title="控制逻辑"></a>控制逻辑</h5><p>处理4种控制</p>
<ul>
<li><p>ret</p>
<p>ret后加入三个bubble</p>
<p>但是取指阶段没有办法插入bubble，实际处理中ret后加入三个rrmovl+bubble效果等价</p>
</li>
<li><p>加载/使用冒险</p>
<p>气泡+转发</p>
</li>
<li><p>预测错误的分支</p>
<p>在下一个周期译码和执行阶段加入bubble 指令排除预测错误的指令</p>
</li>
<li><p>异常</p>
</li>
</ul>
<p>我们可以由此产生各个流水线控制信号的HCL描述</p>
<p><u>遇到加载/使用冒险和ret指令组合时，寄存器D不应该插入气泡。</u></p>
<h5 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h5><script type="math/tex; mode=display">
CPI（每指令周期数）=1+C_b/C_i 
=1+\sum 指令频率*条件频率*气泡数</script><p>其中C_b是气泡数，C_i是指令数，分加载/使用、预测错误、ret三种情况考虑。</p>
<h5 id="未完成工作"><a href="#未完成工作" class="headerlink" title="未完成工作"></a>未完成工作</h5><ul>
<li>多周期指令：计算单元做不同运算所需时间不同</li>
<li>存储系统的接口</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/02/csapp3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hulieu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hulieu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/02/csapp3/" class="post-title-link" itemprop="url">从零开始的汇编</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-02 19:59:31" itemprop="dateCreated datePublished" datetime="2020-01-02T19:59:31+08:00">2020-01-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-20 11:00:15" itemprop="dateModified" datetime="2020-03-20T11:00:15+08:00">2020-03-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%8C%AB%E7%88%AA%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">猫爪记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%8C%AB%E7%88%AA%E8%AE%B0/Computer-Science/" itemprop="url" rel="index"><span itemprop="name">Computer-Science</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="汇编代码后缀"><a href="#汇编代码后缀" class="headerlink" title="汇编代码后缀"></a>汇编代码后缀</h3><div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>代码</th>
<th>大小</th>
</tr>
</thead>
<tbody>
<tr>
<td>char</td>
<td>b</td>
<td>1个字节</td>
</tr>
<tr>
<td>short</td>
<td>w</td>
<td>2个字节</td>
</tr>
<tr>
<td>int/long int/char*</td>
<td>l</td>
<td>4个字节</td>
</tr>
<tr>
<td>float</td>
<td>s</td>
<td>4个字节</td>
</tr>
<tr>
<td>double</td>
<td>l</td>
<td>8个字节</td>
</tr>
<tr>
<td>long double</td>
<td>t</td>
<td>8/10/12个字节(根据系统)</td>
</tr>
</tbody>
</table>
</div>
<h3 id="访问信息"><a href="#访问信息" class="headerlink" title="访问信息"></a>访问信息</h3><p>寄存器是用来存储整数数据和指针的。<br><img src="cpu.png" alt=""></p>
<h3 id="三种操作数指示符："><a href="#三种操作数指示符：" class="headerlink" title="三种操作数指示符："></a>三种操作数指示符：</h3><p>第一种：立即数 $<br>格式 $Imm 操作数值 Imm<br>第二种：寄存器 用E来表示寄存器，R[E]来表示它的值<br>格式 E 操作数值 R[E]<br>第三种：存储器 用M_b[Addr]来表示从Addr开始b个字节的引用<br>一般格式 Imm(E_b, E_l, s) 操作数值 M[Imm+R[E_b]+R[E_l]\dot s]</p>
<h3 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h3><p>mov<br>movb/movw/movl 传送字节/字/双字<br>movs 符号扩展<br>movsbw/movsbl/movswl<br>movz 零扩展<br>movzbw/movzbl/movzwl</p>
<p>pushl 双字压栈<br>popl 双字出栈</p>
<p>leal S D 加载有效地址 &amp;S-&gt;D<br>和movl的区别在于leal赋值的是地址，movl赋值的是值</p>
<h3 id="整数算术操作"><a href="#整数算术操作" class="headerlink" title="整数算术操作"></a>整数算术操作</h3><div class="table-container">
<table>
<thead>
<tr>
<th>操作</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>INC D</td>
<td>加一</td>
</tr>
<tr>
<td>DEC D</td>
<td>减一</td>
</tr>
<tr>
<td>NEG D</td>
<td>取负</td>
</tr>
<tr>
<td>NOT D</td>
<td>取补</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>ADD S, D</td>
<td>相加</td>
</tr>
<tr>
<td>SUB S, D</td>
<td>相减 D-S</td>
</tr>
<tr>
<td>IMUL S, D</td>
<td>相乘</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>XOR S, D</td>
<td>异或</td>
</tr>
<tr>
<td>OR S, D</td>
<td></td>
</tr>
<tr>
<td>AND S, D</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>SAL k, D</td>
<td>左移 D&lt;&lt;k</td>
</tr>
<tr>
<td>SHL k, D</td>
<td>同上</td>
</tr>
<tr>
<td>SAR k, D</td>
<td>算术右移 D&gt;&gt;k （填上符号位），特别的，SAR D为SAR $1, D的简写</td>
</tr>
<tr>
<td>SHR k, D</td>
<td>逻辑右移 D&gt;&gt;k  （填上0）</td>
</tr>
</tbody>
</table>
</div>
<h3 id="特殊算术操作"><a href="#特殊算术操作" class="headerlink" title="特殊算术操作"></a>特殊算术操作</h3><p>imull S 有符号全64位乘法 S*R[%eax]-&gt;R[%edx]:R[%eax]<br>mull S 无符号全64位乘法 S*R[%eax]-&gt;R[%edx]:R[%eax]<br>cltd 转为四字 R[%eax]-&gt;R[%edx]:R[%eax]<br>idivl S 有符号除法 R[%edx]:R[%eax] mod S -&gt; R[%edx]<br>                             R[%edx]:R[%eax] / S -&gt; R[%eax]<br>divl S 无符号除法 同上</p>
<h3 id="条件码"><a href="#条件码" class="headerlink" title="条件码"></a>条件码</h3><p>CF 进位 ZF 零 SF 负数 OF 补码溢出</p>
<p>只设置条件码而不改变目的寄存器的值</p>
<ul>
<li>CMP S2, S1 基于S1-S2</li>
<li>TEST S2, S1 基于S1&amp;S2</li>
</ul>
<p>SET系列指令 操作条件码存储一个字节的存储器位置</p>
<h3 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h3><p>无条件跳转 jmp</p>
<ul>
<li>jmp .L1 直接跳转</li>
<li>jmp *%eax 间接跳转</li>
</ul>
<p>条件跳转(只能是直接跳转）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>指令</th>
<th>跳转条件</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>je/jz</td>
<td>ZF</td>
<td>相等或零</td>
</tr>
<tr>
<td>jne/jnz</td>
<td>~ZF</td>
<td></td>
</tr>
<tr>
<td>js</td>
<td>SF</td>
<td>负数</td>
</tr>
<tr>
<td>jns</td>
<td>~SF</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>jg/jnle</td>
<td>~(SF^OF)&amp;~ZF</td>
<td>大于（有符号）</td>
</tr>
<tr>
<td>jge/jnl</td>
<td>~(SF^OF)</td>
<td>大于等于（有符号）</td>
</tr>
<tr>
<td>jl/jnge</td>
<td>SF^OF</td>
<td>小于（有符号）</td>
</tr>
<tr>
<td>jle/jng</td>
<td>(SF^OF)&#124;ZF</td>
<td>小于等于（有符号）</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ja/jnbe</td>
<td>~CF&amp;~ZF</td>
<td>大于（无符号）</td>
</tr>
<tr>
<td>jae/jnb</td>
<td>~CF</td>
<td>大于等于（无符号）</td>
</tr>
<tr>
<td>jb/jnae</td>
<td>CF</td>
<td>小于（无符号）</td>
</tr>
<tr>
<td>jbe/jna</td>
<td>CF&#124;ZF</td>
<td>小于等于（无符号）</td>
</tr>
</tbody>
</table>
</div>
<h3 id="条件赋值"><a href="#条件赋值" class="headerlink" title="条件赋值"></a>条件赋值</h3><p>cmovl S, R 如果&lt;，用S代替R<br>cmov系列指令和上面j系列相似<br><strong>不是所有的条件表达式可以用条件传送来编译</strong>，因为代码会对then-expr和else-expr求值，如果有一个值不存在或者操作了全局变量，即使测试为假，也会导致错误</p>
<h3 id="switch方法"><a href="#switch方法" class="headerlink" title="switch方法"></a>switch方法</h3><p>在.rodata(Read-Only Data)里声明switch情况分配地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.L7:</span><br><span class="line">  .long .L3</span><br><span class="line">  .long .L2</span><br><span class="line">  .long .L4</span><br><span class="line">  ... ...</span><br></pre></td></tr></table></figure><br>然后使用间接跳转<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp *.L7(, %eax, 4) # Goto *jt[index]</span><br></pre></td></tr></table></figure><br>值得注意的是，<strong>当switch的case值不连续且跨度足够大的时候，会编译成multi-if的形式</strong></p>
<p><em>有传闻显示，编译器还有二分区间这样的骚操作</em></p>
<h3 id="程序栈"><a href="#程序栈" class="headerlink" title="程序栈"></a>程序栈</h3><p>单个过程分配的那部分栈称为栈帧，最顶端以两个指针界定<br>%ebp为帧指针，%esp为栈指针，程序执行时，栈指针可以移动，一般相对于帧指针进行访问<br><img src="stackframe.png" alt=""></p>
<p>转移控制指令</p>
<ul>
<li>call Label 过程调用</li>
<li>call *Operand 过程调用</li>
<li>leave 为返回准备栈</li>
<li>ret 从过程调用中返回<br>call指令将控制转移到一个函数开始，ret指令返回到call指令之后的那条指令<br>leave指令将%esp移到%ebp然后弹出%ebp。如果函数要返回整数或指针的话，寄存器%eax可以用来返回值。</li>
</ul>
<p>一个典型的过程调用示例</p>
<p><img src="stackframeExample.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">caller:</span><br><span class="line">  pushl %ebp</span><br><span class="line">  movl %esp, %ebp</span><br><span class="line">  subl $24, %esp</span><br><span class="line">  ... # 赋值</span><br><span class="line">  call swap_add</span><br><span class="line">swap_add:</span><br><span class="line">  pushl %ebp # Save old %ebp</span><br><span class="line">  movl %esp, %ebp</span><br><span class="line">  pushl %ebx</span><br><span class="line">  ... # 主体代码</span><br><span class="line">  popl %ebx</span><br><span class="line">  popl %ebp</span><br><span class="line">  ret # 返回值在%eax</span><br><span class="line">caller: # 之后的代码</span><br><span class="line">  ... </span><br><span class="line">  imull %edx, %eax</span><br><span class="line">  leave</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure>
<p><em>leave效果上等价于几个popl</em>，但效率上更高</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>声明方式：T A[N]</p>
<p>假设整型数组E存在%edx，整数索引i存在%ecx</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>表达式</th>
<th>类型</th>
<th>值</th>
<th>汇编代码</th>
</tr>
</thead>
<tbody>
<tr>
<td>E</td>
<td>int*</td>
<td>x_E</td>
<td>movl %edx, %eax</td>
</tr>
<tr>
<td>E[i]</td>
<td>int</td>
<td>M[x_E+4i]</td>
<td>movl (%edx,%ecx,4), %eax</td>
</tr>
<tr>
<td>&amp;E[i]</td>
<td>int*</td>
<td>x_E+4i</td>
<td>leal (%edx, %ecx, 4), %eax</td>
</tr>
</tbody>
</table>
</div>
<h3 id="异质数据结构"><a href="#异质数据结构" class="headerlink" title="异质数据结构"></a>异质数据结构</h3><p>struct声明数据结构类型</p>
<p>union允许以多种类型引用一个对象-&gt;一般需要创建一个标签字段</p>
<p><u>数据对齐：要求short地址必须为2的倍数，int等地址必须为4的倍数</u></p>
<h3 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h3><ul>
<li>开始和停止：<ul>
<li>quit</li>
<li>run</li>
<li>kill</li>
</ul>
</li>
<li>断点：<ul>
<li>break sum</li>
<li>break *0x00000000</li>
<li>delete 1</li>
</ul>
</li>
<li>执行：<ul>
<li>stepi n 执行n条指令，默认1条</li>
<li>nexti 以程序为单位执行</li>
<li>continue</li>
<li>finish</li>
</ul>
</li>
<li>检查代码（反汇编）：<ul>
<li>disas</li>
<li>disas sum</li>
<li>disas 0x00000000 反汇编地址附近的函数</li>
<li>disas 0x00000000 0x000000ff</li>
</ul>
</li>
<li>检查数值 <ul>
<li>print $eax（十进制）</li>
<li>print /x $eax(十六进制)</li>
<li>print <em>(int </em>)($ebp+8) 输出%ebp+8处的整数</li>
</ul>
</li>
<li>有用的信息<ul>
<li>info frame 当前栈帧</li>
<li>info registers 所有寄存器</li>
</ul>
</li>
</ul>
<h3 id="保护机制"><a href="#保护机制" class="headerlink" title="保护机制"></a>保护机制</h3><ul>
<li>栈随机化</li>
<li>栈保护</li>
<li>限制存储可执行代码的存储器</li>
</ul>
<h3 id="64位"><a href="#64位" class="headerlink" title="64位"></a>64位</h3><p>指针和声明为长整型的变量都是64位，用movq和addq代替movl和addl</p>
<p>相应的运算和控制也要加上q</p>
<p>返回值放在寄存器%rax中</p>
<p>许多函数没有生成栈帧，通过寄存器传递参数，参数传递见下表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>操作数大小</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody>
<tr>
<td>64</td>
<td>%rdi</td>
<td>%rsi</td>
<td>%rdx</td>
<td>%rcx</td>
<td>%r8</td>
<td>%r9</td>
</tr>
<tr>
<td>32</td>
<td>%edi</td>
<td>%esi</td>
<td>%edx</td>
<td>%ecx</td>
<td>%r8d</td>
<td>%r9d</td>
</tr>
<tr>
<td>16</td>
<td>%di</td>
<td>%si</td>
<td>%dx</td>
<td>%cx</td>
<td>%r8w</td>
<td>%r9w</td>
</tr>
<tr>
<td>8</td>
<td>%dil</td>
<td>%sil</td>
<td>%dl</td>
<td>%cl</td>
<td>%r8b</td>
<td>%r9b</td>
</tr>
</tbody>
</table>
</div>
<p>需要帧栈的情况如下</p>
<ul>
<li>局部变量太多</li>
<li>局部变量是数组或结构</li>
<li>用&amp;计算局部变量地址</li>
<li>需要传递栈上的参数</li>
<li>需要保存它的状态</li>
</ul>
<p>此时x86-64一般会在过程开始后固定栈指针%rsp，并通过栈指针访问</p>
<p><strong>相比之下，x86-64的代码比IA32更简洁且需要较少存储器访问</strong></p>
<p><img src="cpu64.png" alt=""></p>
<p>16个通用目的寄存器中，6个用来传递参数（%rdi,%rsi,%rdx,%rcx,%r8,%r9），6个被调用者保存的临时寄存器（%rbx,%rbp,%r12~%r15)，1个保存返回值(%rax)，1个栈指针(%rsp)，剩下的是调用者保存的寄存器（%r10,%r11）</p>
<p>由于没有帧指针寄存器，可以用寄存器%rbp作为通用寄存器</p>
<p><em>跳转到ret前会加rep作为空操作（使处理器适当预测ret目的以加速）</em></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/28/%E5%90%89%E6%96%AF%E5%B0%BC%E4%BA%9A%E4%BC%A0%E5%A5%870n/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hulieu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hulieu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/28/%E5%90%89%E6%96%AF%E5%B0%BC%E4%BA%9A%E4%BC%A0%E5%A5%870n/" class="post-title-link" itemprop="url">吉斯尼亚传奇N</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-09-28 15:28:01" itemprop="dateCreated datePublished" datetime="2019-09-28T15:28:01+08:00">2019-09-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-01-11 22:12:26" itemprop="dateModified" datetime="2020-01-11T22:12:26+08:00">2020-01-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%89%E6%96%AF%E5%B0%BC%E4%BA%9A%E4%BC%A0%E5%A5%87/" itemprop="url" rel="index"><span itemprop="name">吉斯尼亚传奇</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>​    经过漫漫长夜的飞行，飞机缓缓地降落在跑道上。地面上星星点点的小房子渐渐明晰起来，地上还在闪耀着的跑道灯，在晨曦中显得暗淡无力，罗一成恍惚间意识到，他终于来到了吉斯尼娅，这个古老而年轻的国度，这个陌生而熟悉的城市了。</p>
<p>​    飞机在跑道上开始减速，随着一抹晨光从飞机的后弦方向斜斜地照射过来，整个飞机仿佛也开始苏醒了。乘客们的交谈声渐渐响了起来，打破了延续十七个小时的安静；机舱里再次活跃了起来，有些乘客已经开始急急忙忙地收拾自己的行李了。</p>
<p>​    不过，这些都似乎与罗一成毫无关系。</p>
<p>​    罗一成也开始清醒过来，十七个小时的飞行中，他完完全全地沉浸在自己的迷梦里，这是一个旖旎多姿的梦，如果他的梦有颜色的话，那一定是金色的：从小罗一成就听闻吉斯尼娅的种种传奇，带着对吉斯尼娅美好的想象，只不过他从没想过，他会如今天一般真正来到吉斯尼娅，至少，不会来得那么快。</p>
<p>​    在他的印象里，或者说，在大多数人眼里，吉斯尼娅是危险而神秘的，而罗一成似乎对这样捉摸不定的东西尤其有好感；那些有关吉斯尼娅的美丽传说就仿佛五光十色的肥皂泡，越是缥缈、越是虚幻、越是引人入迷。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Hulieu"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Hulieu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">22</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/husimplicity/husimplicity.github.io" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;husimplicity&#x2F;husimplicity.github.io" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:tulongzikun@126.com" title="E-Mail → mailto:tulongzikun@126.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>
      <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1364161141&auto=1&height=66"></iframe>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hulieu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
