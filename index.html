<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hulieu">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hulieu">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Hulieu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Hulieu</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hulieu</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/08/cryptography/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hulieu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hulieu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/08/cryptography/" class="post-title-link" itemprop="url">密码学</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-08 23:03:48" itemprop="dateCreated datePublished" datetime="2020-04-08T23:03:48+08:00">2020-04-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-11 15:52:05" itemprop="dateModified" datetime="2020-04-11T15:52:05+08:00">2020-04-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%8C%AB%E7%88%AA%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">猫爪记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%8C%AB%E7%88%AA%E8%AE%B0/Mathematics/" itemprop="url" rel="index"><span itemprop="name">Mathematics</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="古典密码学"><a href="#古典密码学" class="headerlink" title="古典密码学"></a>古典密码学</h1><h2 id="几种古典密码"><a href="#几种古典密码" class="headerlink" title="几种古典密码"></a>几种古典密码</h2><p>移位密码（K=3即为凯撒密码）</p>
<script type="math/tex; mode=display">
e_k(x)=(x+K)\:mod\:26\\
d_k(y)=(x-K)\:mod\:26</script><p>代换密码</p>
<script type="math/tex; mode=display">
e_\pi(x)=\pi(x)\\
d_\pi(x)=\pi^{-1}(x)</script><p>仿射密码</p>
<script type="math/tex; mode=display">
e(x)=(ax+b)\:mod\:26\\
d(y)=a^{-1}(y-b)\:mod\:26\\
gcd(a,26)=1\:(保证a^{-1}唯一)</script><p>维吉尼亚密码</p>
<script type="math/tex; mode=display">
e(x_1,x_2,...,x_m)=(x_1+k_1,x_2+k_2,...,x_m+k_m)\\
d(y_1,y_2,...,y_m)=(y_1-k_1,y_2-k_2,...,y_m-k_m)</script><p>希尔密码</p>
<script type="math/tex; mode=display">
e(x)=xK\\
d(x)=yK^{-1}\\
K为Z_{26}上的m\times m可逆矩阵</script><p>置换密码</p>
<script type="math/tex; mode=display">
e_\pi(x_1,x_2,...,x_m)=(x_{\pi(1)},x_{\pi(2)},...,x_{\pi(m)})\\
d_\pi(y_1,y_2,...,y_m)=(y_{\pi^{-1}(1)},y_{\pi^{-1}(2)},...,y_{\pi^{-1}(m)})</script><p>流密码</p>
<p>自动秘钥密码</p>
<script type="math/tex; mode=display">
e_z(x)=(x+z)\:mod\:26\\
d_z(y)=(y-z)\:mod\:26\\
z_i=x_{i-1}，x_1=K</script><h2 id="密码分析"><a href="#密码分析" class="headerlink" title="密码分析"></a>密码分析</h2><p>常见攻击类型：</p>
<ul>
<li>唯密文攻击</li>
<li>已知明文攻击</li>
<li>选择明文攻击：有加密机访问权限</li>
<li>选择密文攻击：有解密机访问权限</li>
</ul>
<p>统计分析：</p>
<p>根据字母出现的频率（或者结合二元组出现频率）</p>
<p>维吉尼亚密码的分析：</p>
<p>Kasiski测试法，搜索长度至少为3的相同密文段，记录这些密文段到起始点之间的距离，猜测m为这些距离的最大公因子的因子</p>
<p>重合指数法，随机两个字母相等的概率（称为重合指数）为0.038，如果相隔为m，这个概率提高到0.065</p>
<p>希尔密码的分析：</p>
<p>需要至少m个不同的明-密文对</p>
<h1 id="Shannon理论"><a href="#Shannon理论" class="headerlink" title="Shannon理论"></a>Shannon理论</h1><p>1949年Claude Shannon发表的”Communication Theory of Secrecy Systems”</p>
<ul>
<li>计算安全性：度量破解所做的计算</li>
<li>可证明安全性：归入数学难题</li>
<li>无条件安全性</li>
</ul>
<p><strong>完善保密性</strong>定义为对任意明文x，密文y，有$P(x|y)=P(x)$</p>
<p>定义：密文空间C、明文空间P、密钥空间K</p>
<p>定理：如果密码体制满足|K|=|C|=|P|。那么这个密码体制是完善保密的，当且仅当每个密钥被使用的概率为1/|K|，且对$x\in P$，$y\in C$，存在唯一的密钥K，$e_K(x)=y$。</p>
<p>一个著名的完善保密的密码体制是”一次一密“，$P=C=K=(Z_2)^n$，加密和解密都是取异或。但是这个体制要求用n比特的密钥加密n比特的明文，且对已知明文攻击是脆弱的。</p>
<p>由于以概率$2^{-n}$发生的事件可以编码为长度为n的比特串，因此定义随机变量X的熵为</p>
<script type="math/tex; mode=display">
H(X)=-\sum P(x)log(x)</script><p><strong>Huffman算法</strong>找到了使得加权平均编码长度最小的<strong>单射</strong>编码l，他是无前缀的，并且</p>
<script type="math/tex; mode=display">
H(X)\leq l(f)<H(X)+1</script><p>熵的性质</p>
<ul>
<li>$H(X)\leq log(n)$</li>
<li>$H(X,Y)\leq H(X)+H(Y)$，(X、Y独立时取等号)</li>
<li>$H(X,Y)=H(Y)+H(X|Y)$</li>
<li>$H(X|Y)\leq H(X)$</li>
</ul>
<p>定义条件熵H(K|C)为密钥含糊度。那么</p>
<script type="math/tex; mode=display">
H(K|C)=H(K)+H(P)-H(C)</script><p>($H(K|C)=H(K,C)-H(C)=H(K,P,C)-H(C)=H(K,P)-H(C)=H(K)+H(P)-H(C)$)</p>
<p>自然语言L的熵定义为</p>
<script type="math/tex; mode=display">
H_L=\lim_{n\to\infty}\frac{H(P^n)}{n}</script><p>语言L的冗余度定义为</p>
<script type="math/tex; mode=display">
R_L=1-\frac{H_L}{log_2|P|}</script><p>英语中$H(P)=4.19$，$H(P^2)/2=3.90$，$1.0\leq H_L\leq 1.5$</p>
<p>定理：|C|=|P|且密钥是等概率选取的，那么给定长为n的密文串，伪密钥的期望数满足</p>
<script type="math/tex; mode=display">
\bar{s_n}\geq \frac{|K|}{|P|^{nR_L}}-1</script><p>($\bar{s_n}=\sum P(y)|K(y)|-1$，而$H(K|C)=H(K)+H(P^n)-H(C^n)\geq H(K)-nR_Llog_2|P|$)</p>
<p>定义<strong>唯一解距离</strong>为使得伪密钥期望等于0的n，记为$n_0$。这是给定足够时间下，分析者能唯一计算出密钥所需密文的平均量。</p>
<script type="math/tex; mode=display">
n\approx \frac{log_2|K|}{R_Llog_2|P|}</script><p><strong>乘积密码体制</strong>密钥$K=(K_1,K_2)$，定义加密解密如下</p>
<script type="math/tex; mode=display">
e_{(K_1,K_2)}(x)=e_{K_2}(e_{K_1}(x))\\
d_{(K_1,K_2)}(y)=d_{K_1}(d_{K_2}(y))</script><p>如果密码体制不是幂等的，那么多次迭代有可能提高安全性。</p>
<h1 id="分组密码和高级加密标准"><a href="#分组密码和高级加密标准" class="headerlink" title="分组密码和高级加密标准"></a>分组密码和高级加密标准</h1><p>大多数分组密码都是乘积密码：用K来生成$N_r$个<strong>轮密钥</strong>（也叫子密钥），轮密钥的列表就是<strong>密钥编排方案</strong>。通过这些轮密钥依次进行加密。</p>
<h2 id="代换-置换网络（SPN）"><a href="#代换-置换网络（SPN）" class="headerlink" title="代换-置换网络（SPN）"></a>代换-置换网络（SPN）</h2><script type="math/tex; mode=display">
\pi_s:\{0,1\}^l\to\{0,1\}^l\\
\pi_p:\{1,...,lm\}\to\{1,...,lm\}</script><p>均为置换，设$P=C=\{0,1\}^{lm}$，$K\subset(\{0,1\}^{lm})^{N_r+1}$是由K生成的密钥编排方案的集合。</p>
<p>每轮加密先用异或操作混入该轮密钥，再用$\pi_s$进行m次代换，再用$\pi_p$进行一次置换。（最后一轮只做异或操作）</p>
<h2 id="线性密码分析"><a href="#线性密码分析" class="headerlink" title="线性密码分析"></a>线性密码分析</h2><p>取值01的随机变量$P(X_i=1)=p_i$，定义<strong>偏差</strong>$e_i=p_i-1$</p>
<p>堆积引理：独立随机变量$X_i$，那么随机变量$X_1\oplus X_2\oplus … \oplus X_n$的偏差满足</p>
<script type="math/tex; mode=display">
e=2^{k-1}\prod_{j=1}^ke_k</script><p>对于一个置换$\pi_s:\{0,1\}^4\to\{0,1\}^4$，把每个相关的随机变量表示成如下形式</p>
<script type="math/tex; mode=display">
(\oplus_{i=1}^4a_iX_i)\oplus(\oplus_{i=1}^4b_iY_i)</script><p>设$N_L(a,b)$表示满足如下条件的8元组对(a,b),(x,y)的个数</p>
<script type="math/tex; mode=display">
(y_1,y_2,y_3,y_4)=\pi_S(x_1,x_2,x_3,x_4)\\
(\oplus_{i=1}^4a_iX_i)\oplus(\oplus_{i=1}^4b_iY_i)=0</script><p>该随机变量的偏差$e(a,b)=(N_L(a,b)-8)/16$</p>
<p>一个基于偏差为$e$的线性逼近的线性攻击想要成功所需要的的明-密文对数$T\approx ce^{-2}$</p>
<h2 id="差分分析"><a href="#差分分析" class="headerlink" title="差分分析"></a>差分分析</h2><p>定义$\Delta(x’)=\{(x,x^*|x\oplus x^*=x’\}$，则显然这个集合大小为$2^m$</p>
<p>定义</p>
<script type="math/tex; mode=display">
N_D(x',y')=|\{(x,x^*)\in \Delta(x'):\pi_s(x)\oplus\pi_s(x^*)=y'\}|</script><p>由此定义对应于差分$(a’,b’)$的扩散率</p>
<script type="math/tex; mode=display">
R_p(a',b')=\frac{N_D(a',b')}{2^m}(=P(b'|a'))</script><p>一个基于扩散率为e的差分攻击，需要4重组$(x,x^*,y,y^*)$的数量$T\approx ce^{-1}$</p>
<h2 id="数据加密标准"><a href="#数据加密标准" class="headerlink" title="数据加密标准"></a>数据加密标准</h2><p>DES是一种特殊的迭代密码，叫做<strong>Feistel型密码</strong>，每个状态$u^i$被分成长度相同的两部分$L^i$和$R^i$，轮函数g有如下形式</p>
<script type="math/tex; mode=display">
g(L^{i-1},R^{i-1},K^i)=(L^i,R^i)\\
L^i=R^{i-1},R^i=L^{i-1}\oplus f(R^{i-1},K^i)</script><p>显然Feistel型轮函数是可逆的，所以f不需要满足单射条件。</p>
<p>DES是16轮Feistel型密码，分组长度为64，密钥空间为$2^56$。</p>
<p>1998年56小时找到了DES密钥</p>
<h2 id="高级加密标准"><a href="#高级加密标准" class="headerlink" title="高级加密标准"></a>高级加密标准</h2><p>AES要求具有分组长度128，支持128、192、256的密钥长度，轮数依赖于密钥长度</p>
<p>最终<strong>Rijndael</strong>当选</p>
<p>前N-1轮，用S盒进行一次代换SubBytes，对State做一置换ShiftRows，再对State做一次操作MixColumns，然后进行AddRoundKey。最后一轮不用MixColumns。</p>
<p>目前来看，AES是安全的，不存在快于穷尽密钥搜索的攻击。</p>
<h2 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h2><p>四种模式</p>
<ul>
<li>密码本（ECB）</li>
<li>密码反馈（CFB）：$z_i=e_K(y_{i-1}),\:y_i=x_i\oplus z_i$</li>
<li>密码分组连接（CBC）：$y_i=e_K(y_{i-1}\oplus x_i)$</li>
<li>输出反馈（OFB）：$z_i=e_K(z_{i-1}),\:y_i=x_i\oplus z_i$</li>
</ul>
<p>ECB和OFB中，改变一个明文分组不影响其他密文分组，常用于信道不安全的通信，OFB常用于卫星通信。</p>
<p>CBC和CFB模式对于认证是有用的，能产生消息认证码MAC。</p>
<h1 id="Hash函数"><a href="#Hash函数" class="headerlink" title="Hash函数"></a>Hash函数</h1><p>Hash函数安全性从三个问题来评估（这三个问题都是难解的才是稳固的）</p>
<ul>
<li>原像</li>
<li>第二原像</li>
<li>碰撞</li>
</ul>
<p>随机预言模型：理想的Hash函数，这个模型对x，随机选择Hash函数h，h(x)是完全随机的。</p>
<p>取q个点寻找原像的平均成功率$e=1-(1-1/M)^q$。（也是寻找第二原像的成功率）</p>
<p>取q个点寻找碰撞的成功率为$e=1-P_M^q/M^q$</p>
<p>可以估计$q\approx\sqrt{2Mln(1/(1-e))}$，（这就说明大约$\sqrt{M}$个随机元素计算有50%概率出现碰撞）</p>
<p>104</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/22/program-design/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hulieu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hulieu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/22/program-design/" class="post-title-link" itemprop="url">程序设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-22 11:04:03" itemprop="dateCreated datePublished" datetime="2020-03-22T11:04:03+08:00">2020-03-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-20 23:15:29" itemprop="dateModified" datetime="2020-04-20T23:15:29+08:00">2020-04-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%8C%AB%E7%88%AA%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">猫爪记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%8C%AB%E7%88%AA%E8%AE%B0/Computer-Science/" itemprop="url" rel="index"><span itemprop="name">Computer-Science</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="C语言输入输出"><a href="#C语言输入输出" class="headerlink" title="C语言输入输出"></a>C语言输入输出</h1><h2 id="scanf"><a href="#scanf" class="headerlink" title="scanf"></a>scanf</h2><p>参数可变的函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">scanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * , ...)</span></span>;</span><br></pre></td></tr></table></figure>
<p>第一个参数是格式字符串，后面的参数是变量的地址，函数作用是按照第一个参数指定的格式，将数据读入后面的变量</p>
<p>返回值</p>
<ul>
<li>>0 成功读入的数据个数</li>
<li>0 没有被赋值</li>
<li>EOF 第一个尝试输入的字符是EOF</li>
</ul>
<h2 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h2><p>参数可变函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> * , ...)</span></span>;</span><br></pre></td></tr></table></figure>
<p>第一个参数是格式字符串，后面的参数是待输出的变量，函数作用是按照第一个参数指定的格式，将后面的变量在屏幕上输出</p>
<p>返回值</p>
<ul>
<li>成功打印的字符数</li>
<li>返回负值为出错</li>
</ul>
<p>例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="keyword">char</span> b;</span><br><span class="line">	<span class="keyword">char</span> c[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">double</span> d = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">float</span> e = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="built_in">scanf</span>(<span class="string">"%d%c%s%lf%f"</span>,&amp;a,&amp;b,c,&amp;d,&amp;e);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d %c %s %lf %e %f %d"</span>,a,b,c,d,e,e,n);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="gets"><a href="#gets" class="headerlink" title="gets"></a>gets</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">gets</span><span class="params">(<span class="keyword">char</span> * s)</span></span>;</span><br></pre></td></tr></table></figure>
<p>从标准输入读取一行到字符串s</p>
<p>如果成功，返回值就是s 地址</p>
<p>如果失败，返回值是 NULL</p>
<p><u>调用时要确保s 指向的缓冲区足够大，否则可能发生内存访问错误</u></p>
<h2 id="sscanf和ssprint"><a href="#sscanf和ssprint" class="headerlink" title="sscanf和ssprint"></a>sscanf和ssprint</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sscanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="built_in">buffer</span>, <span class="keyword">const</span> <span class="keyword">char</span> * format[, address, ...])</span></span>;</span><br><span class="line"><span class="comment">// 和scanf的区别在于，它是从buffer里读取数据</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sprintf</span><span class="params">(<span class="keyword">char</span> *<span class="built_in">buffer</span>, <span class="keyword">const</span> <span class="keyword">char</span> *format[, argument, ...])</span></span>;</span><br><span class="line"><span class="comment">// 和printf的区别在于，它是往buffer里输出数据</span></span><br></pre></td></tr></table></figure>
<h1 id="C语言高级内容"><a href="#C语言高级内容" class="headerlink" title="C语言高级内容"></a>C语言高级内容</h1><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>定义形式：类型名 (* 指针变量名)(参数类型1, 参数类型2,…);</p>
<p>使用方法：可以用一个原型匹配的函数的名字给一个函数指针赋值。要通过函数指针调用它所指向的函数，写法为：函数指针名(实参表);</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintMin</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span>  </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>( a&lt;b )</span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">"%d"</span>,a);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">"%d"</span>,b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> (* pf)(<span class="keyword">int</span> ,<span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">4</span>, y = <span class="number">5</span>;		</span><br><span class="line">    pf = PrintMin;   </span><br><span class="line">    pf(x,y);	</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应用：qsort库</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">void</span> *base, <span class="keyword">int</span> nelem, <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">width</span>, <span class="keyword">int</span> ( * pfCompare)( <span class="keyword">const</span> <span class="keyword">void</span> *, <span class="keyword">const</span> <span class="keyword">void</span> *))</span></span>; <span class="comment">// base起始位置，nelem元素个数，width元素宽度</span></span><br></pre></td></tr></table></figure>
<h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span>&#123;&#125; <span class="comment">// argc命令行参数个数，包括可执行程序本身的名字</span></span><br></pre></td></tr></table></figure>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>六种运算符：&amp;，|，^，~，&lt;&lt;，&gt;&gt;</p>
<p>应用：交换a，b</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = a ^ b;</span><br><span class="line">b = b ^ a;</span><br><span class="line">a = a ^ b;</span><br></pre></td></tr></table></figure>
<h1 id="从C到C"><a href="#从C到C" class="headerlink" title="从C到C++"></a>从C到C++</h1><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>下面的写法定义了一个引用，并将其初始化为引用某个变量。 类型名 &amp; 引用名 = 某变量名; </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">4</span>; </span><br><span class="line"><span class="keyword">int</span> &amp; r = n;  <span class="comment">// r引用了 n, r的类型是 int &amp;</span></span><br></pre></td></tr></table></figure>
<p>定义引用时一定要将其初始化成引用某个变量。</p>
<p>初始化后，它就一直引用该变量，不会再引用别 的变量了。</p>
<p>引用只能引用变量，不能引用常量和表达式。</p>
<p><u>C语言&amp;取指，C++中&amp;引用</u></p>
<p>引用可以作为函数的返回值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">4</span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp; <span class="title">SetValue</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> n;  &#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    SetValue() = <span class="number">40</span>; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; n; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;  <span class="comment">//输出： 40</span></span><br></pre></td></tr></table></figure>
<p><u>const T &amp; 和T &amp; 是不同的类型</u></p>
<p>T &amp; 类型的引用或T类型的变量可以用来初始化 const T &amp; 类型的引用。</p>
<p>const T 类型的常变量和const T &amp; 类型的引用则 不能用来初始化T &amp;类型的引用，除非进行强制类 型转换</p>
<h2 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h2><p>第一种用法，分配一个变量：T是任意类型名，P是类型为T * 的指针。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P = <span class="keyword">new</span> T;</span><br></pre></td></tr></table></figure>
<p>第二种用法，分配一个数组：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P = <span class="keyword">new</span> T[N];</span><br></pre></td></tr></table></figure>
<p><u>使用new动态分配的内存空间，一定要用delete进行释放</u></p>
<p>使用delete释放动态分配的数组，要加[]，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> [] p;</span><br></pre></td></tr></table></figure>
<h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p> 为了减少函数调用的开销，引入了内联函数机制。编译器处理对内联函数的调用语句时，是将整个函数的代码插入到调用语句处，而不会产生调用函数的语句。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( a &gt; b) <span class="keyword">return</span> a; </span><br><span class="line">    <span class="keyword">return</span> b; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>一个或多个函数，名字相同，然而参数个数或参数类型不相同，这叫做函数的重载</p>
<p>函数重载使得函数命名变得简单。 </p>
<p>编译器根据调用语句的中的实参的个数和类型判断应该调用哪个函数</p>
<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h2><p>其作用就是指向成员函数所作用的对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Hello</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">"hello"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// 等价于 void Hello(A * this ) &#123; cout &lt;&lt; this-&gt;i &lt;&lt; "hello" &lt;&lt; endl; &#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>非静态成员函数</strong>中可以直接使用this来代表指向该函数作用的对象的指针。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> real, imag;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; real &lt;&lt; <span class="string">","</span> &lt;&lt; imag ; &#125;</span><br><span class="line">    Complex(<span class="keyword">double</span> r,<span class="keyword">double</span> i):real(r),imag(i) &#123;&#125;</span><br><span class="line">    <span class="function">Complex <span class="title">AddOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;real ++; <span class="comment">//等价于 real ++;</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;Print(); <span class="comment">//等价于 Print</span></span><br><span class="line">        <span class="keyword">return</span> * <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2><p><strong>静态成员</strong>是在说明前面加了static关键字的成员。静态成员变量本质上是全局变量。</p>
<p><u>普通成员变量每个对象有各自的一份，而静态成员变量一共就一份， 为所有对象共享。</u></p>
<p>sizeof 运算符不会计算静态成员变量。  </p>
<p>普通成员函数必须具体作用于某个对象，而静态成员函数并不具体作用于某个对象，因此静态成员不需要通过对象就能访问。</p>
<p>四种种访问静态成员的方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CRectangle::PrintTotal(); <span class="comment">// 类名::成员名</span></span><br><span class="line">CRectangle r; r.PrintTotal(); <span class="comment">// 对象名.成员名</span></span><br><span class="line">CRectangle * p = &amp;r; p-&gt;PrintTotal(); <span class="comment">// 指针-&gt;成员名</span></span><br><span class="line">CRectangle &amp; ref = r; <span class="keyword">int</span> n = ref.nTotalNumber; <span class="comment">// 引用.成员名</span></span><br></pre></td></tr></table></figure>
<p>必须在定义类的文件中对静态成员变量进行一次说明或初始化。否则编译能通过，链接不能通过。  </p>
<p><u>在静态成员函数中，不能访问非静态成员变量，也不能调用非静态成员函数。</u></p>
<p>例子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CRectangle::CRectangle(<span class="keyword">int</span> w_,<span class="keyword">int</span> h_)&#123;</span><br><span class="line">    w = w_;</span><br><span class="line">    h = h_;</span><br><span class="line">    nTotalNumber ++;</span><br><span class="line">    nTotalArea += w * h;</span><br><span class="line">&#125;</span><br><span class="line">CRectangle::~CRectangle()&#123;</span><br><span class="line">    nTotalNumber --;</span><br><span class="line">    nTotalArea -= w * h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> CRectangle::PrintTotal()&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; nTotalNumber &lt;&lt; <span class="string">","</span> &lt;&lt; nTotalArea &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样写缺陷是在使用CRectangle类时，有时会调用复制构造函数生成临时的隐藏的CRectangle对象  ，比如调用CRectangle类对象作为参数或作为返回值的函数时，并不会增加nTotalNumber，却会在这些对象消亡时调用析构函数。解决办法：写一个赋值构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CRectangle :: CRectangle(CRectangle &amp; r )&#123;</span><br><span class="line">    w = r.w; h = r.h;</span><br><span class="line">    nTotalNumber ++;</span><br><span class="line">    nTotalArea += w * h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="成员对象和封闭类"><a href="#成员对象和封闭类" class="headerlink" title="成员对象和封闭类"></a>成员对象和封闭类</h2><p>有<strong>成员对象</strong>的类叫<strong>封闭类</strong>。</p>
<p>任何生成封闭类对象的语句，都要让编译器明白，对象中的成员对象，是如何初始化的。</p>
<p>具体的做法就是：<u> 通过封闭类的构造函数的初始化列表 。</u> </p>
<p>封闭类对象生成时，先执行所有对象成员的构造函数，然后才执行封闭类的构造函数。</p>
<p>对象成员的构造函数调用次序和对象成员在类中的说明次序一致，与它们在成员初始化列表中出现的次序无关。</p>
<p>当封闭类的对象消亡时，先执行封闭类的析构函数，然后再执行成员对象的析构函数。次序和构造函数的调用次序相反  </p>
<p>例子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTyre</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CTyre() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"CTyre contructor"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    ~CTyre() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"CTyre destructor"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CEngine</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CEngine() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"CEngine contructor"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    ~CEngine() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"CEngine destructor"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCar</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    CEngine engine;</span><br><span class="line">    CTyre tyre;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CCar( ) &#123; <span class="built_in">cout</span> &lt;&lt; “CCar contructor” &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    ~CCar() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"CCar destructor"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CCar car;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">CEngine contructor</span></span><br><span class="line"><span class="comment">CTyre contructor</span></span><br><span class="line"><span class="comment">CCar contructor</span></span><br><span class="line"><span class="comment">CCar destructor</span></span><br><span class="line"><span class="comment">CTyre destructor</span></span><br><span class="line"><span class="comment">CEngine destructor</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><u>封闭类的对象，如果是用默认复制构造函数初始化的，那么它里面包含的成员对象，也会用复制构造函数初始化。</u></p>
<h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>友元分为友元函数和友元类两种  </p>
<p><u>友元函数: 一个类的友元函数可以访问该类的私有成员。</u></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCar</span> ;</span> <span class="comment">//提前声明 CCar类，以便后面的CDriver类使用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDriver</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ModifyCar</span><span class="params">( CCar * pCar)</span> </span>; <span class="comment">//改装汽车</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCar</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">void</span> CDriver::ModifyCar(CCar * pCar); <span class="comment">//声明友元</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> CDriver::ModifyCar( CCar * pCar)&#123;</span><br><span class="line">    pCar-&gt;price += <span class="number">1000</span>; <span class="comment">//汽车改装后价值增加</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以将一个类的成员函数(包括构造、析构函数)说明为另一个类的友元。</p>
<p><u>友元类: 如果A是B的友元类，那么A的成员函数可以访问B的私有成员。</u></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCar</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">CDriver</span>;</span> <span class="comment">//声明CDriver为友元类</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><u>友元类之间的关系不能传递，不能继承。</u></p>
<h2 id="常量成员函数"><a href="#常量成员函数" class="headerlink" title="常量成员函数"></a>常量成员函数</h2><p>如果不希望某个对象的值被改变，则定义该对象的时候可以在前面加 const关键字 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Sample Obj;</span><br></pre></td></tr></table></figure>
<p>常量对象只能使用构造函数、析构函数和有const 说明的函数(常量方法）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sample</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Sample() &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>常量成员函数内部不能改变属性的值，也不能调用非常量成员函数。  </p>
<p>在<u>定义常量成员函数</u>和<u>声明常量成员函数</u>时都应该使用const 关键字  </p>
<p>如果一个成员函数中没有调用非常量成员函数，也没有修改成员变量的值，那么， 最好将其写成常量成员函数。</p>
<p>两个函数，名字和参数表都一样，但是一个是const,一个不是，算重载。  </p>
<p>const成员函数可以修改的成员变量要加mutable</p>
<h1 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h1><p>运算符重载的实质是函数重载</p>
<p>可以重载为普通函数，也可以重载为成员函数</p>
<p>把含运算符的表达式转换成对运算符函数的调用</p>
<p>例子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="keyword">double</span> real,imag; </span><br><span class="line">    Complex( <span class="keyword">double</span> r = <span class="number">0.0</span>, <span class="keyword">double</span> i= <span class="number">0.0</span> ):real(r),imag(i) &#123;&#125; </span><br><span class="line">    Complex <span class="keyword">operator</span>-(<span class="keyword">const</span> Complex &amp; c); </span><br><span class="line">&#125;; </span><br><span class="line">Complex <span class="keyword">operator</span>+ (<span class="keyword">const</span> Complex &amp; a, <span class="keyword">const</span> Complex &amp; b) &#123; </span><br><span class="line">    <span class="keyword">return</span> Complex(a.real+b.real,a.imag+b.imag); <span class="comment">//返回一个临时对象 </span></span><br><span class="line">&#125; </span><br><span class="line">Complex Complex::<span class="keyword">operator</span>-(<span class="keyword">const</span> Complex &amp; c) &#123; </span><br><span class="line">    <span class="keyword">return</span> Complex(real - c.real, imag - c.imag); <span class="comment">//返回一个临时对象 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="赋值运算符的重载"><a href="#赋值运算符的重载" class="headerlink" title="赋值运算符的重载"></a>赋值运算符的重载</h2><p>赋值运算符“=”只能重载为成员函数</p>
<p>如不定义自己的赋值运算符，那么可能会导致浅拷贝。</p>
<h2 id="运算符重载为友元函数"><a href="#运算符重载为友元函数" class="headerlink" title="运算符重载为友元函数"></a>运算符重载为友元函数</h2><p>有时，重载为成员函数不能满足使用要求，重载为普通函数，又不能访问类的私有成员，所以需要将运算符重载为友元。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span> </span><br><span class="line">    <span class="keyword">double</span> real,imag; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    Complex( <span class="keyword">double</span> r, <span class="keyword">double</span> i):real(r),imag(i)&#123; &#125;; </span><br><span class="line">    Complex <span class="keyword">operator</span>+( <span class="keyword">double</span> r );  <span class="comment">// c + 5</span></span><br><span class="line">    <span class="keyword">friend</span> Complex <span class="keyword">operator</span> + (<span class="keyword">double</span> r,<span class="keyword">const</span> Complex &amp; c); <span class="comment">// 5 + c</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="流插入-提取运算符的重载"><a href="#流插入-提取运算符的重载" class="headerlink" title="流插入/提取运算符的重载"></a>流插入/提取运算符的重载</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ostream &amp; ostream::<span class="keyword">operator</span>&lt;&lt;(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    ... <span class="comment">// 输出n的代码</span></span><br><span class="line">    <span class="keyword">return</span> * <span class="keyword">this</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="重载类型转换运算符"><a href="#重载类型转换运算符" class="headerlink" title="重载类型转换运算符"></a>重载类型转换运算符</h2><h2 id="自增-自减运算符重载"><a href="#自增-自减运算符重载" class="headerlink" title="自增/自减运算符重载"></a>自增/自减运算符重载</h2><p>前置运算符作为一元运算符重载</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重载为成员函数： </span></span><br><span class="line">T &amp; <span class="keyword">operator</span>++(); </span><br><span class="line">T &amp; <span class="keyword">operator</span>--(); </span><br><span class="line"><span class="comment">// 重载为全局函数： </span></span><br><span class="line">T1 &amp; <span class="keyword">operator</span>++(T2); </span><br><span class="line">T1 &amp; <span class="keyword">operator</span>--(T2);</span><br></pre></td></tr></table></figure>
<p>后置运算符作为二元运算符重载，多写一个没用的参数int</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重载为成员函数： </span></span><br><span class="line">T <span class="keyword">operator</span>++(<span class="keyword">int</span>); </span><br><span class="line">T <span class="keyword">operator</span>--(<span class="keyword">int</span>);</span><br><span class="line"><span class="comment">// 重载为全局函数： </span></span><br><span class="line">T1 <span class="keyword">operator</span>++(T2,<span class="keyword">int</span> ); </span><br><span class="line">T1 <span class="keyword">operator</span>--( T2,<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure>
<p>但是在没有后置运算符重载而有前置重载的情况下，在vs中，obj++ 也调用前置重载，而dev则令 obj ++ 编译出错</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>C++不允许定义新的运算符</p>
<p>重载不改变优先级顺序</p>
<p>重载(),[],-&gt;,=时，重载函数必须声明为类的成员函数。</p>
<h1 id="继承和派生"><a href="#继承和派生" class="headerlink" title="继承和派生"></a>继承和派生</h1><p>派生类是通过对基类进行修改和扩充得到的。在派生类中，可以扩充新的成员变量 和成员函数。</p>
<p>派生类拥有基类的全部成员函数和成员变量，不论是private、protected、public 。</p>
<p>在派生类的各个成员函数中，不能访问 基类中的private成员。</p>
<h2 id="继承关系和复合关系"><a href="#继承关系和复合关系" class="headerlink" title="继承关系和复合关系"></a>继承关系和复合关系</h2><p>继承：B继承A，A是基类，B对象也是A对象</p>
<p>复合：C中有成员变量k，k是D对象</p>
<h2 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h2><p> 派生类可以定义一个和基类成员同名的成员，这叫 覆盖。</p>
<p>在派生类中访问这类成员时，缺省的情况是 访问派生类中定义的成员。要在派生类中访问由基 类定义的同名成员时，要使用作用域符号::。</p>
<h2 id="类的保护成员"><a href="#类的保护成员" class="headerlink" title="类的保护成员"></a>类的保护成员</h2><p>基类的private成员：可以被下列函数访问 </p>
<ul>
<li>基类的成员函数 </li>
<li>基类的友员函数 </li>
</ul>
<p>基类的protected成员：可以被下列函数访问 </p>
<ul>
<li>基类的成员函数 </li>
<li>基类的友员函数 </li>
<li>派生类的成员函数可以访问<strong>当前对象的基类</strong>的保护成员</li>
</ul>
<h2 id="派生类的构造函数"><a href="#派生类的构造函数" class="headerlink" title="派生类的构造函数"></a>派生类的构造函数</h2><p>构造函数不能访问基类的private变量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bug</span> &#123;</span> </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="keyword">int</span> nLegs; <span class="keyword">int</span> nColor; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="keyword">int</span> nType; </span><br><span class="line">    Bug (<span class="keyword">int</span> legs, <span class="keyword">int</span> color); </span><br><span class="line">&#125;; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlyBug</span>:</span> <span class="keyword">public</span> Bug <span class="comment">// FlyBug是Bug的派生类 </span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">int</span> nWings; </span><br><span class="line"> <span class="keyword">public</span>: </span><br><span class="line">    FlyBug(<span class="keyword">int</span> legs,<span class="keyword">int</span> color, <span class="keyword">int</span> wings); </span><br><span class="line">&#125;;</span><br><span class="line">Bug::Bug(<span class="keyword">int</span> legs, <span class="keyword">int</span> color) &#123; nLegs = legs; nColor = color; &#125;</span><br><span class="line"><span class="comment">//正确的FlyBug构造函数： </span></span><br><span class="line">FlyBug::FlyBug(<span class="keyword">int</span> legs, <span class="keyword">int</span> color, <span class="keyword">int</span> wings):Bug( legs, color) &#123; nWings = wings; &#125;</span><br></pre></td></tr></table></figure>
<p>在创建派生类的对象时，需要调用基类的构造函数：初始化派 生类对象中从基类继承的成员。在执行一个派生类的构造函数 之前，总是先执行基类的构造函数。</p>
<p>调用基类构造函数的两种方式 </p>
<ul>
<li>显式方式：在派生类的构造函数中，为基类的构造函数提供参数. </li>
<li>隐式方式：在派生类的构造函数中，省略基类构造函数时， 派生类的构造函数则自动调用基类的默认构造函数.</li>
</ul>
<p>派生类的析构函数被执行时，执行完派生类的析构函数后，自动调用基类的析构函数。</p>
<p>封闭派生类对象构造先基类构造函数，然执行对象成员的构造函数，最后执行自己的构造函数。析构时与之相反。</p>
<h2 id="public继承的赋值兼容规则"><a href="#public继承的赋值兼容规则" class="headerlink" title="public继承的赋值兼容规则"></a>public继承的赋值兼容规则</h2><p>派生类的对象可以赋值给基类对象 </p>
<p>派生类对象可以初始化基类引用</p>
<p>派生类对象的地址可以赋值给基类指针</p>
<p>如果派生方式是 private或protected，则上述三条不可行</p>
<p><u>protected继承时，基类的public成员和protected成员成为派生类的protected成员。</u></p>
<p><u>private继承时，基类的public成员成为派生类的private成员，基类的protected成员成 为派生类的不可访问成员</u></p>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><h2 id="虚函数和多态"><a href="#虚函数和多态" class="headerlink" title="虚函数和多态"></a>虚函数和多态</h2><p>类的定义中，有virtual关键字的成员函数是虚函数</p>
<p>virtual关键字只用在类定义的函数声明中，写函数体时不用。</p>
<p>通过基类指针调用基类和派生类中的同名同参虚函数时: </p>
<ul>
<li>若该指针指向一个基类的对象，那么被调用是基类的虚 函数；</li>
<li>若该指针指向一个派生类的对象，那么被调用的是派生 类的虚函数。</li>
</ul>
<p>这种机制就叫做<strong>“多态”</strong>。</p>
<p>两种表现形式</p>
<ul>
<li><p>派生类的指针可以赋给基类指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span>&#123; </span><br><span class="line">    CDerived ODerived; </span><br><span class="line">    CBase * p = &amp; ODerived; </span><br><span class="line">    p -&gt; SomeVirtualFunction(); <span class="comment">//调用哪个虚函数取决于p指向哪种类型的对象 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>派生类的对象可以赋给基类引用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span>&#123; </span><br><span class="line">    CDerived ODerived; </span><br><span class="line">    CBase &amp; r = ODerived; </span><br><span class="line">    r.SomeVirtualFunction(); <span class="comment">//调用哪个虚函数取决于r引用哪种类型的对象 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><u>在非构造函数，非析构函数的成员 函数中调用虚函数，是多态!!!</u></p>
<p>在构造函数和析构函数中调用虚函数，不是多态。编 译时即可确定，调用的函数是自己的类或基类中定义 的函数，不会等到运行时才决定调用自己的还是派生 类的函数。</p>
<p>派生类中和基类中虚函数同名同参数表的函数，不加virtual也自动成为虚函数</p>
<p><u>虚函数的访问权限根据基类定义所决定。</u></p>
<h2 id="多态的实现原理"><a href="#多态的实现原理" class="headerlink" title="多态的实现原理"></a>多态的实现原理</h2><p>“多态”的关键在于通过基类指针或引用调用 一个虚函数时，编译时不确定到底调用的是基类还 是派生类的函数，运行时才确定——这叫<strong>“动态联编”</strong>。</p>
<p><u>多态实现的关键 —- 虚函数表</u></p>
<p>每一个有虚函数的类（或有虚函数的类的派生类） 都有一个虚函数表，该类的任何对象中都放着虚函数 表的指针。虚函数表中列出了该类的虚函数地址。</p>
<p>多态的函数调用语句被 编译成一系列根据基类指 针所指向的（或基类引用 所引用的）对象中存放的 虚函数表的地址，在虚函 数表中查找虚函数地址， 并调用虚函数的指令。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>   &#123;</span> </span><br><span class="line"><span class="keyword">public</span>: <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Func</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"A::Func"</span> &lt;&lt; <span class="built_in">endl</span>; &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A  &#123; </span><br><span class="line"><span class="keyword">public</span>: <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Func</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"B::Func"</span> &lt;&lt; <span class="built_in">endl</span>; &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span>&#123; </span><br><span class="line">	A a; </span><br><span class="line">	A * pa = <span class="keyword">new</span> B(); </span><br><span class="line">	pa-&gt;Func(); <span class="comment">//若是64位程序,指针为8字节，则应为long long </span></span><br><span class="line">	<span class="keyword">long</span> * p1 = (<span class="keyword">long</span> * ) &amp; a; </span><br><span class="line">	<span class="keyword">long</span> * p2 = (<span class="keyword">long</span> * ) pa; </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; * p1 &lt;&lt; <span class="string">" "</span> &lt;&lt; * p2 &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">	* p2 = * p1; </span><br><span class="line">	pa-&gt;Func(); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出为：</span></span><br><span class="line"><span class="comment">// B::Func</span></span><br><span class="line"><span class="comment">// A::Func</span></span><br></pre></td></tr></table></figure>
<h2 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h2><p>通过基类的指针删除派生类对象时，通常情况下只调用基类的析构函数。但是，删除一个派生类的对象时，应该先调用派生类的析构函 数，然后调用基类的析构函数。 </p>
<p>解决办法：把基类的析构函数声明为virtual </p>
<p>派生类的析构函数可以virtual不进行声明</p>
<ul>
<li>通过基类的指针删除派生类对象时，首先调用派生类的析构函 数，然后调用基类的析构函数 </li>
<li>一般来说，一个类如果定义了虚函数，则应该将析构函数也定义成 虚函数。</li>
</ul>
<p>或者，一个类打算作为基类使用，也应该将析构函数定义 成虚函数。 </p>
<p><u>注意：不允许以虚函数作为构造函数</u></p>
<h2 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h2><p>纯虚函数：没有函数体的虚函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br></pre></td></tr></table></figure>
<p>包含纯虚函数的类叫抽象类</p>
<p>不能创建抽象类的对象</p>
<p>抽象类只能作为基类来派生新类</p>
<p>在抽象类的成员函数内可以调用纯虚函数，但是在构造函数或析构函数内部 不能调用纯虚函数。</p>
<h1 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h1><p>输入输出相关的类</p>
<p>istream/ostream/iostream 流类</p>
<p>ifstream/ofstream/fstream 文件类</p>
<h2 id="标准流对象"><a href="#标准流对象" class="headerlink" title="标准流对象"></a>标准流对象</h2><p>输入流cin从键盘读入</p>
<p>输出流cout、cerr、clog向屏幕输出（缺省情况下三者一样）</p>
<p>可以被重新向为向文件读/写数据</p>
<p>可以用如下方法判输入流结束</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span>&gt;&gt;x)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>如果从键盘输入，则在单独一行输入ctrl+z代表输入流结束</p>
<h2 id="istream类成员函数"><a href="#istream类成员函数" class="headerlink" title="istream类成员函数"></a>istream类成员函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream &amp; <span class="title">getline</span><span class="params">(<span class="keyword">char</span> * buf, <span class="keyword">int</span> bufSize)</span></span>;</span><br><span class="line"><span class="comment">// 从输入流中读取bufSize-1个字符到缓冲区buf，或读到碰到‘\n’ 为止（哪个先到算哪个）</span></span><br><span class="line"><span class="function">istream &amp; <span class="title">getline</span><span class="params">(<span class="keyword">char</span> * buf, <span class="keyword">int</span> bufSize,<span class="keyword">char</span> delim)</span></span>;</span><br><span class="line"><span class="comment">// 从输入流中读取bufSize-1个字符到缓冲区buf，或读到碰到delim字 符为止（哪个先到算哪个）</span></span><br></pre></td></tr></table></figure>
<p>两个函数都会自动在buf中读入数据的结尾添加\0’。</p>
<p>‘\n’或 delim都不会被读入buf，但会被从输入流中取走。如果输入流中 ‘\n’或delim之前的字符个数达到或超过了bufSize个，就导致读 入出错，其结果就是：虽然本次读入已经完成，但是之后的读入就 都会失败了</p>
<p>可以用 <code>if(!cin.getline(…))</code> 判断输入是否结束</p>
<p><code>bool eof();</code>判断输入流是否结束 </p>
<p><code>int peek();</code> 返回下一个字符,但不从流中去掉. </p>
<p><code>istream &amp; putback(char c);</code>将字符ch放回输入流 </p>
<p><code>istream &amp; ignore( int nCount = 1, int delim = EOF );</code> 从流中删掉最多nCount个字符，遇到EOF时结束。</p>
<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">freopen(<span class="string">"test.txt"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);  <span class="comment">//将标准输出重定向到 test.txt文件 </span></span><br><span class="line">freopen(“t.txt”,“r”,<span class="built_in">stdin</span>);  <span class="comment">//cin被改为从 t.txt中读取数据</span></span><br></pre></td></tr></table></figure>
<h2 id="流操纵算子"><a href="#流操纵算子" class="headerlink" title="流操纵算子"></a>流操纵算子</h2><p><u>使用流操纵算子需要 <code>#include &lt;iomanip&gt;</code></u></p>
<p>整数流的基数：流操纵算子dec,oct,hex </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">10</span>; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; hex &lt;&lt; n &lt;&lt; “\n” <span class="comment">// a </span></span><br><span class="line">    &lt;&lt; dec &lt;&lt; n &lt;&lt; “\n”  <span class="comment">// 10</span></span><br><span class="line">    &lt;&lt; oct &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 12</span></span><br></pre></td></tr></table></figure>
<p>指定输出浮点数有效位数（非定点方式输出）/小数点后有效位数（定点方式输出）：</p>
<p>precision是成员函数，调用方式为<code>cout.precision(5);</code></p>
<p>setprecision是流操作算子，调用方式为<code>cout&lt;&lt;setprecision(5);</code></p>
<p><code>setiosflags(ios::fixed)</code>定点输出模式</p>
<p><code>resetiosflags(ios::fixed)</code>非定点输出模式</p>
<p>设置域宽的流操作算子：</p>
<p>setw是流算子<code>cin&gt;&gt;setw(4);</code></p>
<p>width是成员函数<code>cin.width(5);</code></p>
<p><u>宽度设置有效性是一次性的，在每次读入和 输出之前都要设置宽度。</u></p>
<p>其他操作算子</p>
<p><code>showpos</code>显示正负号/<code>noshowpos</code>不显示正负号</p>
<p><code>left</code>、<code>right</code>、<code>internal</code>左/右/中</p>
<p><code>scientific</code>科学计数法</p>
<p>用户自定义算子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ostream &amp;<span class="title">tab</span><span class="params">(ostream &amp;output)</span></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> output &lt;&lt; <span class="string">'\t'</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 这是因为iostream对&lt;&lt;进行了重载</span></span><br><span class="line">ostream &amp; <span class="keyword">operator</span> &lt;&lt;(  ostream &amp; ( * p ) ( ostream &amp; ) ) ;</span><br></pre></td></tr></table></figure>
<h2 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h2><p><code>#include&lt;fstream&gt;</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ofstream <span class="title">outFile</span><span class="params">(<span class="string">"clients.dat"</span>, ios::out|ios::binary)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>ios::out</code> 删除原有内容 <code>ios::app</code>保留原有内容</p>
<p>也可以先出创建ofstream对象，再用<code>open</code>函数打开</p>
<p><code>tellp()</code>获得指针位置</p>
<p><code>seekp(location)</code>将指针移到location处</p>
<p><code>seekp(location, ios::beg)</code>从开头数，<code>seekp(location, ios::cur)</code>从当前数，<code>seekp(location, ios::end)</code>从结尾数</p>
<p>location可以是负数</p>
<p>关闭文件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"1.dat"</span>, ios::in)</span></span>;</span><br><span class="line">fin.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"1.dat"</span>, ios::out)</span></span>;</span><br><span class="line">fout.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure>
<p>二进制读文件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream&amp; <span class="title">read</span> <span class="params">(<span class="keyword">char</span>* s, <span class="keyword">long</span> n)</span></span>;</span><br><span class="line"><span class="comment">// 将文件读指针指向的地方的n个字节内容，读入到内存地址s，然后将文件读指针向后移动n字节</span></span><br><span class="line"><span class="function">ostream&amp; <span class="title">write</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s, <span class="keyword">long</span> n)</span></span>;</span><br><span class="line"><span class="comment">// 将内存地址s处的n个字节内容，写入到文件中写指针指向的位置， 然后将文件写指针向后移动n字节</span></span><br></pre></td></tr></table></figure>
<p><u>二进制文件和文本文件的区别</u></p>
<p>Linux,Unix下的换行符号：‘\n’  (ASCII码:  0x0a) </p>
<p>Windows 下的换行符号：‘\r\n’  (ASCII码： 0x0d0a)    endl 就是 ‘\n’ </p>
<p>Mac OS下的换行符号： ‘\r’  (ASCII码：0x0d)</p>
<p>二进制和Linux下一致</p>
<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">Swap</span>(<span class="title">T</span> &amp; <span class="title">x</span>,<span class="title">T</span> &amp; <span class="title">y</span>) &#123;</span> </span><br><span class="line">    T tmp = x; </span><br><span class="line">    x = y; </span><br><span class="line">    y = tmp; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以不通过参数实例化函数模板</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">Inc</span>(<span class="title">T</span> <span class="title">n</span>) &#123;</span> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + n; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Inc&lt;<span class="keyword">double</span>&gt;(<span class="number">4</span>)/<span class="number">2</span>;  <span class="comment">//输出 2.5 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数模板可以重载，只要它们的形参表或类型参数表不同即可</p>
<p>在有多个函数和函数模板名字相同的情况下，编译器如下处理一 条函数调用语句</p>
<ol>
<li>先找参数完全匹配的普通函数(非由模板实例化而得的函数)。 </li>
<li>再找参数完全匹配的模板函数。 </li>
<li>再找实参数经过自动类型转换后能够匹配的普通函数。 </li>
<li>都找不到，则报错。</li>
</ol>
<p>匹配模板函数时，不进行类型自动转换</p>
<h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">class</span> <span class="title">T2</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Pair</span> &#123;</span> </span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    T1 key;  <span class="comment">//关键字 </span></span><br><span class="line">    T2 value;     <span class="comment">//值 </span></span><br><span class="line">    Pair(T1 k,T2 v):key(k),value(v) &#123; &#125;; </span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; ( <span class="keyword">const</span> Pair&lt;T1,T2&gt; &amp; p) <span class="keyword">const</span>; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">class</span> <span class="title">T2</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">Pair</span>&lt;T1,T2&gt;:</span>:<span class="keyword">operator</span> &lt; ( <span class="keyword">const</span> Pair&lt;T1,T2&gt; &amp; p) <span class="keyword">const</span> <span class="comment">//Pair的成员函数 operator &lt; </span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">return</span> key &lt; p.key;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器由类模板生成类的过程叫类模板的实例化。</p>
<p>由类 模板实例化得到的类，叫模板类。</p>
<p><u>同一个类模板的两个模板类是不兼容的。</u></p>
<p>类模板的“&lt;类型参数表&gt;”中可以出现非类型参数： <code>template &lt;class T, int size&gt;</code></p>
<h2 id="类模板和派生"><a href="#类模板和派生" class="headerlink" title="类模板和派生"></a>类模板和派生</h2><p>类模板从类模板派生</p>
<p>类模板从普通类派生</p>
<p>类模板从模板类派生</p>
<p>普通类从模板类派生</p>
<h2 id="类模板和友元"><a href="#类模板和友元" class="headerlink" title="类模板和友元"></a>类模板和友元</h2><p> 函数、类、类的成员函数作为类模板的友元 </p>
<p>函数模板作为类模板的友元 </p>
<p>函数模板作为类的友元 </p>
<p>类模板作为类模板的友元</p>
<h1 id="标准模板库（STL）"><a href="#标准模板库（STL）" class="headerlink" title="标准模板库（STL）"></a>标准模板库（STL）</h1><p>C++ 语言的核心优势之一就是便于软件的重用</p>
<p>C++中有两个方面体现重用：</p>
<ol>
<li><p>面向对象的思想：继承和多态，标准类库</p>
</li>
<li><p>泛型程序设计(generic programming) 的思想： 模板机制，以及标准模板库 STL</p>
</li>
</ol>
<p>将一些常用的数据结构（比如链表，数组，二叉树）和算法（比如排序，查找）写成模板，以后则不论数据结构里放的是什么对象，算法针对什么样的对象，则都不必重新实现数据结构，重新编写算法。</p>
<p><strong>标准模板库 (Standard Template Library) </strong>就是一些常用数据结构和算法的模板的集合。</p>
<p><strong>有了STL，不必再写大多的标准数据结构和算法，并且可获得非常高的性能。</strong></p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>容器</strong>：可容纳各种数据类型的通用数据结构，是类模板</p>
<p><strong>迭代器：</strong>可用于依次存取容器中元素，类似于指针</p>
<p><strong>算法：</strong>用来操作容器中的元素的函数模板</p>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>对象被插入容器中时，被插入的是对象的一个<strong>复制品</strong>。许多算法，比如排序，查找，要求对容器中的元素进行比较，有的容器本身就是排序的，所以，放入容器的对象所属的类，往往还应该重载 == 和 &lt; 运算符。</p>
<h3 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h3><p>vector, deque, list</p>
<p><strong>vector</strong></p>
<p>头文件<code>&lt;vector&gt;</code></p>
<p>动态数组。元素在内存连续存放。随机存取任何元素都能在<strong>常数时间</strong>完成。在尾端增删元素具有较佳的性能</p>
<p><strong>deque</strong></p>
<p>头文件<code>&lt;deque&gt;</code></p>
<p>双向队列。元素在内存连续存放。随机存取任何元素都能在常数时间完成(但次于vector)。在两端增删元素具有较佳的性能(大部分情况下是常数时间）。</p>
<p>所有适用于 vector的操作都适用于 deque。</p>
<p>deque还有 push_front（将元素插入到前面） 和 pop_front(删除最前面的元素）操作。</p>
<p><strong>list</strong></p>
<p>头文件<code>&lt;list&gt;</code></p>
<p>双向链表。元素在内存<strong>不连续存放</strong>。在任何位置增删元素都能在常数时间完成。<strong>不支持随机存取。</strong></p>
<p> 除了具有所有顺序容器都有的成员函数以外，还支持8个成员函数：</p>
<ul>
<li>push_front: 在前面插入</li>
<li>pop_front:  删除前面的元素</li>
<li>sort:    排序 ( list 不支持 STL 的算法 sort)</li>
<li>remove:    删除和指定值相等的所有元素</li>
<li>unique:   删除所有和前一个元素相同的元素</li>
<li>merge:    合并两个链表，并清空被合并的那个</li>
<li>reverse:    颠倒链表</li>
<li>splice:   在指定位置前面插入另一链表中的一个或多个元素,并在另一链表中删除被插入的元素</li>
</ul>
<h3 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h3><p>元素是排序的</p>
<p>插入任何元素，都按相应的排序规则来确定其位置</p>
<p>在查找时具有非常好的性能</p>
<p>通常以平衡二叉树方式实现，插入和检索的时间都是 O(log(N))</p>
<p>set, multiset, map, multimap</p>
<p>内部元素有序排列，新元素插入的位置取决于它的值，查找速度快。</p>
<p>除了各容器都有的函数外，还支持以下成员函数：</p>
<ul>
<li>find: 查找等于某个值 的元素(x小于y和y小于x同时不成立即为相等)</li>
<li>lower_bound : 查找某个下界</li>
<li>upper_bound : 查找某个上界</li>
<li>equal_range : 同时查找上界和下界</li>
<li>count :计算等于某个值的元素个数(x小于y和y小于x同时不成立即为相等)</li>
<li>insert: 用以插入一个元素或一个区间</li>
</ul>
<p><strong>set/multiset</strong></p>
<p>头文件<code>&lt;set&gt;</code> </p>
<p>区别在于是否允许存储相同元素</p>
<p>multiset的定义如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">Pred</span> = <span class="title">less</span>&lt;Key&gt;, </span></span><br><span class="line"><span class="class">	        <span class="title">class</span> <span class="title">A</span> = <span class="title">allocator</span>&lt;Key&gt; &gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">multiset</span> &#123;</span> …… &#125;;</span><br></pre></td></tr></table></figure>
<p>Pred类型的变量决定了multiset 中的元素，“一个比另一个小”是怎么定义的。multiset运行过程中，比较两个元素x,y的大小的做法，就是生成一个 Pred类型的变量，假定为 op,若表达式op(x,y) 返回值为true,则 x比y小。 Pred的缺省类型是<code>less&lt;Key&gt;</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// less模板的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">less</span> :</span> <span class="keyword">public</span> binary_function&lt;T, T, <span class="keyword">bool</span>&gt; </span><br><span class="line">&#123; <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y)</span> </span>&#123; <span class="keyword">return</span> x &lt; y ; &#125; <span class="keyword">const</span>;   &#125;;</span><br></pre></td></tr></table></figure>
<p>multiset用法如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="built_in">multiset</span>&lt;A&gt; a;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="built_in">multiset</span>&lt;A, less&lt;A&gt;&gt; a;</span><br></pre></td></tr></table></figure>
<p>由于less模板默认&lt;比较大小，所以A不可比较时需要重载&lt;</p>
<p><strong>map/multimap</strong></p>
<p>头文件<code>&lt;map&gt;</code></p>
<p>map与set的不同在于map中存放的元素有且仅有两个成员变量，一个名为first,另一个名为second, map根据first值对元素进行从小到大排序，并可快速地根据first来检索元素。</p>
<p>pair模板如下，map/multimap里放着都是pair模板类的对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">T1</span>, <span class="title">class</span> _<span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class">   <span class="title">struct</span> <span class="title">pair</span></span></span><br><span class="line"><span class="class">   &#123;</span></span><br><span class="line">     <span class="keyword">typedef</span> _T1 first_type;  </span><br><span class="line">     <span class="keyword">typedef</span> _T2 second_type; </span><br><span class="line">     _T1 first;               </span><br><span class="line">     _T2 second;              </span><br><span class="line">     pair(): first(), second() &#123; &#125;</span><br><span class="line">     pair(<span class="keyword">const</span> _T1&amp; __a, <span class="keyword">const</span> _T2&amp; __b)</span><br><span class="line">     : first(__a), second(__b) &#123; &#125;</span><br><span class="line">     <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">U1</span>, <span class="title">class</span> _<span class="title">U2</span>&gt;</span></span><br><span class="line"><span class="class">     <span class="title">pair</span>(<span class="title">const</span> <span class="title">pair</span>&lt;_U1, _U2&gt;&amp; __<span class="title">p</span>)</span></span><br><span class="line"><span class="class">:</span> first(__p.first), second(__p.second) &#123; &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
<p>multimap定义如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Pred</span> = <span class="title">less</span>&lt;Key&gt;,</span></span><br><span class="line"><span class="class">		 <span class="title">class</span> <span class="title">A</span> = <span class="title">allocator</span>&lt;T&gt; &gt; </span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">multimap</span> &#123;</span> </span><br><span class="line">	….</span><br><span class="line">	<span class="keyword">typedef</span> pair&lt;<span class="keyword">const</span> Key, T&gt; value_type; </span><br><span class="line">	…….	</span><br><span class="line"> &#125;;    <span class="comment">//Key 代表关键字的类型</span></span><br></pre></td></tr></table></figure>
<p>multimap中的元素由 &lt;关键字,值&gt;组成，每个元素是一个pair对象，关键字就是first成员变量,其类型是Key</p>
<p>multimap 中允许多个元素的关键字相同。元素按照first成员变量从小到大排列，缺省情况下用 <code>less&lt;Key&gt;</code> 定义关键字的“小于”关系。</p>
<h3 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h3><p>stack, queue, priority_queue</p>
<ul>
<li>push 插入元素</li>
<li>pop 弹出元素</li>
<li>top 返回栈顶元素的引用</li>
</ul>
<p><strong>stack</strong></p>
<p>头文件<code>&lt;stack&gt;</code></p>
<p>后进先出</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Cont</span> = <span class="title">deque</span>&lt;T&gt; &gt;  </span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">stack</span> &#123;</span> </span><br><span class="line">	…..</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可用 vector, list, deque来实现。缺省情况下，用deque实现。用 vector和deque实现，比用list实现性能好。</p>
<p><strong>queue</strong></p>
<p>头文件<code>&lt;queue&gt;</code></p>
<p>先进先出</p>
<p>和stack 基本类似，可以用 list和deque实现。缺省情况下用deque实现。</p>
<p><strong>priority_queue</strong></p>
<p>头文件<code>&lt;queue&gt;</code></p>
<p>优先级队列。最高优先级元素总是第一个出列</p>
<p>和 queue类似，可以用vector和deque实现。缺省情况下用vector实现。</p>
<p>priority_queue 通常用堆排序技术实现，保证最大的元素总是在最前面。即执行pop操作时，删除的是最大的元素；执行top操作时，返回的是最大元素的引用。默认的元素比较器是 <code>less&lt;T&gt;</code>。</p>
<h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><p>begin 第一个元素的迭代器</p>
<p>end 最后一个元素后面的迭代器</p>
<p>rbegin 最后一个元素的迭代器</p>
<p>rend 第一个元素前面的迭代器</p>
<p>erase</p>
<p>clear</p>
<p>front 第一个元素的引用</p>
<p>back 最后一个元素的引用</p>
<p>push_back</p>
<p>pop_back</p>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>用于指向顺序容器和关联容器中的元素</p>
<p>迭代器用法和指针类似</p>
<p>有const 和非 const两种</p>
<p>通过迭代器可以读取它指向的元素</p>
<p>通过非const迭代器还能修改其指向的元素</p>
<p>定义一个容器类的迭代器的方法可以是：</p>
<p> <code>容器类名::iterator  变量名;</code></p>
<p>或：</p>
<p> <code>容器类名::const_iterator 变量名;</code></p>
<p>访问一个迭代器指向的元素：</p>
<p> <code>* 迭代器变量名</code></p>
<p>迭代器可以执行++，—</p>
<p>可以判断是否相等</p>
<p>如果是随机访问迭代器，可以+i，-i， p[i]，可以判断大小</p>
<p>容器适配器（stack、queue、priority_queue）不支持迭代器</p>
<p>vector/deque 随机访问，list/set/map 双向</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>算法就是一个个<strong>函数模板</strong>, 大多数在<code>&lt;algorithm&gt;</code> 中定义</p>
<p>STL中提供能在各种容器中通用的算法，比如查找，排序等</p>
<p>算法通过迭代器来操纵容器中的元素。许多算法可以对容器中的一个局部区间进行操作，因此需要两个参数，一个是起始元素的迭代器，一个是终止元素的后面一个元素的迭代器。比如，排序和查找</p>
<p>有的算法返回一个迭代器。比如 find() 算法，在容器中查找一个元素，并返回一个指向该元素的迭代器</p>
<p>算法可以处理容器，也可以处理普通数组</p>
<p><strong>find</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InIt</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">InIt</span> <span class="title">find</span>(<span class="title">InIt</span> <span class="title">first</span>, <span class="title">InIt</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">val</span>);</span></span><br></pre></td></tr></table></figure>
<p>first 和 last 这两个参数都是容器的迭代器，它们给出了容器中的查找区间起点和终点[first,last)。区间的起点是位于查找范围之中的，而终点不是。find在[first,last)查找等于val的元素</p>
<p>用 == 运算符判断相等</p>
<p>函数返回值是一个迭代器。如果找到，则该迭代器指向被找到的元素。如果找不到，则该迭代器等于last</p>
<p><strong>STL中“大”“小” 的概念</strong></p>
<p>关联容器内部的元素是从小到大排序的</p>
<p>有些算法要求其操作的区间是从小到大排序的，称为“有序区间算法”，例如<code>binary_search</code></p>
<p>有些算法会对区间进行从小到大排序，称为“排序算法”，例如<code>sort</code></p>
<p>还有一些其他算法会用到“大”，“小”的概念</p>
<p>使用STL时，在缺省的情况下，以下三个说法等价：</p>
<ul>
<li>x比y小</li>
<li>表达式“x&lt;y”为真</li>
<li>y比x大</li>
</ul>
<h2 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h2><p>是个对象，但是用起来看上去象函数调用，实际上也执行了函数调用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyAverage</span>  &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">( <span class="keyword">int</span> a1, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3 )</span> </span>&#123; <span class="comment">//重载 () 运算符</span></span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">double</span>)(a1 + a2+a3) / <span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> CMyAverage average;  <span class="comment">//函数对象</span></span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; average(<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>); <span class="comment">// average.operator()(3,2,3) 用起来看上去象函数调用 输出 2.66667</span></span><br></pre></td></tr></table></figure>
<p>STL里有以下模板</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InIt</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Pred</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">accumulate</span>(<span class="title">InIt</span> <span class="title">first</span>, <span class="title">InIt</span> <span class="title">last</span>, <span class="title">T</span> <span class="title">val</span>, <span class="title">Pred</span> <span class="title">pr</span>);</span></span><br></pre></td></tr></table></figure>
<p>pr 就是个函数对象。</p>
<p>对[first,last)中的每个迭代器 I, </p>
<p>执行 val = pr(val,* I) ,返回最终的val。</p>
<p>Pr也可以是个函数。</p>
<p><strong>greater 函数对象类模板</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">greater</span> :</span> <span class="keyword">public</span> binary_function&lt;T, T, <span class="keyword">bool</span>&gt;&#123; </span><br><span class="line"> <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> x &gt; y;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//binary_function定义：</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Arg1</span>, <span class="title">class</span> <span class="title">Arg2</span>, <span class="title">class</span> <span class="title">Result</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">binary_function</span> &#123;</span> </span><br><span class="line">	<span class="keyword">typedef</span> Arg1 first_argument_type;</span><br><span class="line">	<span class="keyword">typedef</span> Arg2 second_argument_type; </span><br><span class="line">	<span class="keyword">typedef</span> Result result_type;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h2><p>STL中的算法大致可以分为以下七类：</p>
<ul>
<li><p>不变序列算法</p>
<p>此类算法不会修改算法所作用的容器或对象，适用于所有容器。它们的时间复杂度都是O(n)的。</p>
<p>min、max、for_each、count、count_if、find、find_if、find_end、find_first_of、adjacent_find，search、search_n、equal</p>
</li>
<li><p>变值算法</p>
<p>此类算法会修改源区间或目标区间元素的值。值被修改的那个区间，不可以是属于关联容器的。</p>
<p>for_each、copy、copy_backward、transform、swap_ranges、fill、fill_n、generate、replace、replace_if、replace_copy、replace_copy_if</p>
</li>
<li><p>删除算法</p>
<p>删除算法会删除一个容器里的某些元素。这里所说的“删除”，并不会使容器里的元素减少，其工作过程是：将所有应该被删除的元素看做空位子，然后用留下的元素从后往前移，依次去填空位子。元素往前移后，它原来的位置也就算是空位子，也应由后面的留下的元素来填上。最后，没有被填上的空位子，维持其原来的值不变。删除算法不应作用于关联容器。</p>
<p>remove、remove_if、remove_copy、remove_copy_if、unique、unique_copy</p>
</li>
<li><p>变序算法</p>
<p>变序算法改变容器中元素的顺序，但是不改变元素的值。变序算法不适用于关联容器。此类算法复杂度都是O(n)的。</p>
<p>reverse、reverse_copy，rotate（左移）、next_permutation（下一个排列）、prev_permutation、random_shuffle（需要预设随机种子）、partition</p>
</li>
<li><p>排序算法</p>
<p>排序算法比前面的变序算法复杂度更高，一般是O(n×log(n))。排序算法需要随机访问迭代器的支持，因而不适用于关联容器和list。</p>
<p>sort（快排）、stable_sort（归并）、partial_sort（部分排序，直到最小的n个元素就位）、nth_element、make_heap、push_heap、pop_heap、sort_heap</p>
</li>
<li><p>有序区间算法</p>
<p>有序区间算法要求所操作的区间是已经从小到大排好序的，而且需要随机访问迭代器的支持。所以有序区间算法不能用于关联容器和list。</p>
<p>binary_search、includes、lower_bound、upper_bound、merge、set_union、set_intersection、set_difference、</p>
</li>
<li><p>数值算法</p>
</li>
</ul>
<p>大多重载的算法都是有两个版本的，其中一个是用“==”判断元素是否相等，或用“&lt;”来比较大小；而另一个版本多出来一个类型参数“Pred”，以及函数形参“Pred op”,该版本通过表达式“op(x,y)”的返回值是ture还是false，来判断x是否“等于”y，或者x是否“小于”y。如下面的有两个版本的min_element:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterate <span class="title">min_element</span><span class="params">(iterate first,iterate last)</span></span>;</span><br><span class="line"><span class="function">iterate <span class="title">min_element</span><span class="params">(iterate first,iterate last, Pred op)</span></span>;</span><br></pre></td></tr></table></figure>
<h1 id="C-11特性"><a href="#C-11特性" class="headerlink" title="C++11特性"></a>C++11特性</h1><p>统一的是初始化方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">3</span>]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; </span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; iv&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; </span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;  mp&#123;&#123;<span class="number">1</span>, <span class="string">"a"</span>&#125;, &#123;<span class="number">2</span>, <span class="string">"b"</span>&#125;&#125;; </span><br><span class="line"><span class="built_in">string</span> str&#123;<span class="string">"Hello World"</span>&#125;; </span><br><span class="line"><span class="keyword">int</span> * p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span> </span><br><span class="line">    <span class="keyword">int</span> i,j;  </span><br><span class="line">    A(<span class="keyword">int</span> m,<span class="keyword">int</span> n):i(m),j(n) &#123; &#125;  </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    A * pa = <span class="keyword">new</span> A &#123;<span class="number">3</span>,<span class="number">7</span>&#125;; </span><br><span class="line">    A a[] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>&#125;&#125;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>成员变量默认初始值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span> </span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">1234</span>; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>auto关键字：用于定义变量，编译起可以自动判断变量的类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span></span><br></pre></td></tr></table></figure>
<p>decltype 关键字：求表达式的类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span></span><br></pre></td></tr></table></figure>
<p>智能指针shared_ptr：通过shared_ptr的构造函数，可以让shared_ptr对象托管一个new运算符返 回的指针,此后ptr就可以像 T<em> 类型的指针一样来使用，即 </em>ptr 就是用new动态分配的那 个对象，而且不必操心释放内存的事。多个shared_ptr对象可以同时托管一个指针，系统会维护一个托管计数。当 无shared_ptr托管该指针时，delete该指针。 <u>shared_ptr对象不能托管指向动态分配的数组的指针，否则程序运行会出错</u></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt; </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;A&gt; sp1(<span class="keyword">new</span> A(<span class="number">2</span>)); <span class="comment">//sp1托管A(2) </span></span><br><span class="line">    sp1.reset();           <span class="comment">//sp1放弃托管 A(2) </span></span><br><span class="line">    A * q = <span class="keyword">new</span> A(<span class="number">3</span>); </span><br><span class="line">    sp1.reset(q); <span class="comment">// sp1托管q </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于范围的for循环</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> ary[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> &amp; e: ary)  </span><br><span class="line">        e*= <span class="number">10</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> e : ary) </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="string">","</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>右值引用和move语义：一般来说，不能取地址的表达式，就是右值， 能取地址的，就是左值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span> &#125;; </span><br><span class="line">A &amp; r = A(); <span class="comment">// error , A()是无名变量，是右值 </span></span><br><span class="line">A &amp;&amp; r = A(); <span class="comment">//ok, r 是右值引用</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">MoveSwap</span>(<span class="title">T</span>&amp; <span class="title">a</span>, <span class="title">T</span>&amp; <span class="title">b</span>)   &#123;</span> </span><br><span class="line">    <span class="function">T <span class="title">tmp</span><span class="params">(<span class="built_in">move</span>(a))</span></span>; <span class="comment">// std::move(a)为右值，这里会调用move constructor </span></span><br><span class="line">    a = <span class="built_in">move</span>(b);    <span class="comment">// move(b)为右值，因此这里会调用move assigment </span></span><br><span class="line">    b = <span class="built_in">move</span>(tmp);  <span class="comment">// move(tmp)为右值，因此这里会调用move assigment </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无序容器(哈希表) </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt; </span></span></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; turingWinner; <span class="comment">//图灵奖获奖名单</span></span><br></pre></td></tr></table></figure>
<p>正则表达式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="function">regex <span class="title">reg</span><span class="params">(<span class="string">"b.?p.*k"</span>)</span></span>; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; regex_match(<span class="string">"bopggk"</span>,reg) &lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>Lambda表达式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[外部变量访问方式说明符](参数表) -&gt;返回值类型 &#123; 语句组 &#125;</span><br><span class="line"><span class="comment">// “-&gt;返回值类型”也可以没有， 没有则编译器自动判断返回值类型</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[] 不使用任何外部变量 </span></span><br><span class="line"><span class="comment">[=] 以传值的形式使用所有外部变量 </span></span><br><span class="line"><span class="comment">[&amp;] 以引用形式使用所有外部变量 </span></span><br><span class="line"><span class="comment">[x, &amp;y] x 以传值形式使用，y 以引用形式使用 </span></span><br><span class="line"><span class="comment">[=,&amp;x,&amp;y] x,y 以引用形式使用，其余变量以传值形式使用 </span></span><br><span class="line"><span class="comment">[&amp;,x,y] x,y 以传值的形式使用，其余变量以引用形式使用</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>多线程 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;thread&gt;</span><br></pre></td></tr></table></figure>
<h1 id="C-11高级特性"><a href="#C-11高级特性" class="headerlink" title="C++11高级特性"></a>C++11高级特性</h1><h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><p>static_cast、reinterpret_cast、const_cast和dynamic_cast</p>
<p>static_cast用来进用行比较“自然”和低风险的转换，比 如整型和实数型、字符型之间互相转换。static_cast不能来在不同类型的指针之间互相转换，也不 能用于整型和指针之间的互相转换，也不能用于不同类型的 引用之间的转换。</p>
<p>reinterpret_cast用来进行各种不同类型的指针之间的转换、不同 类型的引用之间转换、以及指针和能容纳得下指针的整数类型之间 的转换。转换的时候，执行的是逐个比特拷贝的操作。</p>
<p>const_cast用来进行去除const属性的转换。将const引用转换成同类型的非 const引用，将const指针转换为同类型的非const指针时用它。</p>
<p>dynamic_cast专门用于将多态基类的指针或引用，强 制转换为派生类的指针或引用，而且能够检查转换的 安全性。对于不安全的指针转换，转换结果返回NULL 指针。 </p>
<p>dynamic_cast不能用于将非多态基类的指针或引用， 强制转换为派生类的指针或引用</p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;... <span class="keyword">throw</span> ...&#125;</span><br><span class="line"><span class="keyword">catch</span>(...)&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>C++标准库中有一些类代表异常，这些类都是从exception类派生而来</p>
<p>bad_typeid</p>
<p>bad_cast</p>
<p>bad_alloc</p>
<p>ios_base::failure</p>
<p>logic_error/out_of_range</p>
<h2 id="运行时类型检查"><a href="#运行时类型检查" class="headerlink" title="运行时类型检查"></a>运行时类型检查</h2><p> C++运算符typeid是单目运算符，可以在程序运行过程中获取一个表达式的值的 类型。typeid运算的返回值是一个type_info类的对象，里面包含了类型的信息。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt; //要使用typeinfo，需要此头文件</span></span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"1) int is: "</span> &lt;&lt; <span class="keyword">typeid</span>(<span class="keyword">int</span>).name() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出 1) int is: in</span></span><br></pre></td></tr></table></figure>
<h2 id="Boost-Any"><a href="#Boost-Any" class="headerlink" title="Boost.Any"></a>Boost.Any</h2><p> 实现任意类型的存储 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">any a = <span class="number">10</span>;        <span class="comment">// 存储一个 int  </span></span><br><span class="line">a = <span class="built_in">string</span>(“hello world”); <span class="comment">// 存储字符串  </span></span><br><span class="line">a = myclass(); <span class="comment">// 存储自己的对象  </span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; any_cast&lt;<span class="keyword">int</span>&gt;(a); <span class="comment">// 转换为需要的类型</span></span><br></pre></td></tr></table></figure>
<p>关于 any_cast </p>
<p> 存储的类型与转换的类型不一致会抛出bad_any_cast </p>
<p>指针版不一致返回空指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/any.hpp&gt; </span></span></span><br><span class="line"><span class="comment">//成员函数： </span></span><br><span class="line">any(); </span><br><span class="line">~any(); </span><br><span class="line">any(<span class="keyword">const</span> any&amp;); </span><br><span class="line">any&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> any&amp;); </span><br><span class="line"><span class="function">any&amp; <span class="title">swap</span><span class="params">(any&amp;)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span>; </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ValueType&gt; any(<span class="keyword">const</span> ValueType&amp;); </span><br><span class="line">any&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> ValueType&amp;); </span><br><span class="line"><span class="comment">// 独立函数： </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ValueType&gt; </span><br><span class="line"><span class="function">ValueType <span class="title">any_cast</span><span class="params">(<span class="keyword">const</span> any&amp;)</span></span>; <span class="comment">// Throw bad_any_cast </span></span><br><span class="line"><span class="function"><span class="keyword">const</span> ValueType* <span class="title">any_cast</span><span class="params">(<span class="keyword">const</span> any*)</span></span>; <span class="comment">// Return NULL </span></span><br><span class="line"><span class="function">ValueType* <span class="title">any_cast</span><span class="params">(any*)</span></span>;</span><br></pre></td></tr></table></figure>
<p><u> 抽象基类 + 模板派生 = 编译时的多态</u></p>
<h2 id="多文件共享全局变量"><a href="#多文件共享全局变量" class="headerlink" title="多文件共享全局变量"></a>多文件共享全局变量</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span></span><br></pre></td></tr></table></figure>
<h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><p>一个类可以有多个直接基类，这叫多继承 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span><span class="keyword">public</span> A, <span class="keyword">public</span> B &#123; &#125;;</span><br></pre></td></tr></table></figure>
<p>多继承可能导致二义性，因此需要把直接基类继承base声明为<strong>虚拟基类</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span> : </span><br><span class="line">    <span class="keyword">int</span> va;   </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123; &#125; </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A  &#123;  <span class="keyword">int</span> vb;    &#125;;     </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A  &#123;  <span class="keyword">int</span> vc;    &#125;;         </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;  <span class="keyword">int</span>  vd ; &#125;;</span><br></pre></td></tr></table></figure>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>调用C函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">void</span> <span class="title">c_func</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>python调用C++</p>
<p>编译成动态链接库c.so，然后拷贝到调用它的python程序的文件夹下: g++ -o c.so -shared -fPIC c.cpp</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes </span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> * <span class="comment"># c类型库 </span></span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line">libc = CDLL(<span class="string">'c.so'</span>) <span class="comment">#装入动态链接库 </span></span><br><span class="line">libc.cpp_func1(c_char_p(bytes(<span class="string">"this高达"</span>,encoding=<span class="string">"utf-8"</span>)));</span><br></pre></td></tr></table></figure>
<h2 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(#define XXX/#undef XXX)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> XXX/#<span class="meta-keyword">ifndef</span> XXX</span></span><br><span class="line">...</span><br><span class="line">(#<span class="keyword">else</span> ...)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h1 id="STL-Review"><a href="#STL-Review" class="headerlink" title="STL(Review)"></a>STL(Review)</h1><p>六大部件</p>
<ul>
<li>容器</li>
<li>分配器</li>
<li>算法</li>
<li>迭代器</li>
<li>适配器</li>
<li>仿函式</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ia[<span class="number">6</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>, allocator&lt;<span class="keyword">int</span>&gt;&gt; vi(ia, ia+<span class="number">6</span>);</span><br><span class="line">    <span class="comment">// 容器vector，分配器allocator（可以不写）</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; count_if(vi.<span class="built_in">begin</span>(), vi.<span class="built_in">end</span>(),</span><br><span class="line">                    not1(bind2nd(less&lt;<span class="keyword">int</span>&gt;(), <span class="number">40</span>))));</span><br><span class="line">    <span class="comment">// 算法count_if 迭代器.begin .end </span></span><br><span class="line">    <span class="comment">// 函数适配器negator binder 函数less</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="容器-1"><a href="#容器-1" class="headerlink" title="容器"></a>容器</h2><p>Set/Map 都是用红黑树实现的 </p>
<p>单向列表<code>forward_list</code>（和GNU_C中的<code>slist</code>完全一样），只有<code>push_front</code></p>
<p><code>array</code>无法扩充，<code>vector</code>两倍扩充</p>
<p><code>deque</code>是一个本质是map到buffer的一些指针，</p>
<p><code>unordered_multimap</code>相当于hash_map</p>
<p><code>hash_set</code> <code>hash_map</code> <code>hash_multiset</code> <code>hash_multimap</code>并不是规范C++语言，但在编译器中实现（注意include的头文件位置） </p>
<p>容器分类：</p>
<p>序列式容器：</p>
<ul>
<li>array</li>
<li>vector<ul>
<li>heap<ul>
<li>priority_queue</li>
</ul>
</li>
</ul>
</li>
<li>list</li>
<li>slist（非标准）</li>
<li>dequeue（分段连续）<ul>
<li>stack</li>
<li>queue</li>
</ul>
</li>
</ul>
<p>关联式容器</p>
<ul>
<li>rb_tree（非公开）<ul>
<li>set</li>
<li>map</li>
<li>multiset</li>
<li>multimap</li>
</ul>
</li>
<li>hashtable（非公开、非标准）<ul>
<li>hash_set</li>
<li>hash_map</li>
<li>hash_multiset</li>
<li>hash_multimap</li>
</ul>
</li>
</ul>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p><strong>GNU2.9</strong> sizeof=4</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>=<span class="title">alloc</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">list</span>&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">typedef</span> __list_node&lt;T&gt; list_node;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> list_node* link_type;</span><br><span class="line">    <span class="keyword">typedef</span> __list_iterator&lt;T, T&amp;, T*&gt; iterator;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    link_type node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中list node定义为（这里void pointer是有明显问题的）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">list_node</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">void</span>* void_pointer;</span><br><span class="line">    void_pointer prev;</span><br><span class="line">    void_pointer next;</span><br><span class="line">    T data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中list iterator定义为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Ref</span>, <span class="title">class</span> <span class="title">Ptr</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">list_iterator</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> __list_iterator&lt;T, Ref, Ptr&gt; self;</span><br><span class="line">    <span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category; <span class="comment">// necessary</span></span><br><span class="line">    <span class="keyword">typedef</span> T value_type; <span class="comment">// necessary</span></span><br><span class="line">    <span class="keyword">typedef</span> Ptr pointer; <span class="comment">// necessary</span></span><br><span class="line">    <span class="keyword">typedef</span> Ref reference; <span class="comment">// necessary</span></span><br><span class="line">    <span class="keyword">typedef</span> __list_node&lt;T&gt;* link_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> differnece_type; <span class="comment">// necessary</span></span><br><span class="line">    </span><br><span class="line">    link_type node;</span><br><span class="line">    </span><br><span class="line">    reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123;<span class="keyword">return</span> (*node).data;&#125;</span><br><span class="line">    pointer operato r-&gt;() <span class="keyword">const</span> &#123;<span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*())&#125;</span><br><span class="line">    self&amp; <span class="keyword">operator</span>++()&#123;node=(link_type)((*node).next);<span class="keyword">return</span> *<span class="keyword">this</span>&#125;</span><br><span class="line">    self <span class="keyword">operator</span>++(<span class="keyword">int</span>)&#123;self tmp=*<span class="keyword">this</span>; ++*<span class="keyword">this</span>; <span class="keyword">return</span> tmp;&#125; </span><br><span class="line">    <span class="comment">// tmp=*this 并不会调用重载的*，因为赋值操作被重载，this被解释为参数 </span></span><br><span class="line">    <span class="comment">// __list_iterator(const iterator&amp; x): node(x.node)&#123;&#125;</span></span><br><span class="line">    <span class="comment">// 之后++*this 也不会调用重载的*，因为*this已被解释为参数 </span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>GNU4.9</strong></p>
<p>修改了iterator和node的定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// list 定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc=<span class="built_in">std</span>::allocator&lt;_Tp&gt;&gt;</span><br><span class="line">class <span class="built_in">list</span>: <span class="keyword">protected</span> _List_base&lt;_Tp, _Alloc&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> __list_iterator&lt;_Tp&gt; iterator;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// iterator 定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">List_iterator</span>&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> _Tp* pointer;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp&amp; reference;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// node 定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">List_node_base</span>&#123;</span></span><br><span class="line">    _List_node_base* _M_next;</span><br><span class="line">    _List_node_base* _M_prev;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">List_node</span>:</span> <span class="keyword">public</span> _List_node_base &#123;</span><br><span class="line">    _Tp _M_data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>list的父类定义<code>_List_base</code>有成员<code>_List_impl&lt;_Tp,_A&gt;</code>继承自<code>_A&lt;List_node&lt;_Tp&gt;&gt;</code></p>
<p><u>list的实际实现是<strong>双向、环状</strong>的，为了符合“前闭后开”的要求。</u></p>
<h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>两倍扩张</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (finish != end_of_storage)&#123;</span><br><span class="line">        construct(finish, x);</span><br><span class="line">        ++finish;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        insert_aux(<span class="built_in">end</span>(), x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">vector</span>&lt;T, Alloc&gt;:</span>:insert_aux(iterator <span class="built_in">position</span>, <span class="keyword">const</span> T&amp; x)&#123;</span><br><span class="line">    <span class="keyword">if</span> (finish != end_of_storage)&#123; <span class="comment">// 和push_back里的检查是一样的</span></span><br><span class="line">        construct(finish, *(finish - <span class="number">1</span>));</span><br><span class="line">        ++finish;</span><br><span class="line">        T x_copy = x;</span><br><span class="line">        copy_backward(<span class="built_in">position</span>, finish - <span class="number">2</span>, finish - <span class="number">1</span>);</span><br><span class="line">        *<span class="built_in">position</span> = x_copy</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> size_type old_size = <span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">const</span> size_type len = old_size != <span class="number">0</span> ? <span class="number">2</span> * old_size : <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        iterator new_start = data_allocator::allocate(len);</span><br><span class="line">        iterator new_finish = new_start;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            new_finish = uninitialized_copy(start, <span class="built_in">position</span>, new_start);</span><br><span class="line">            construct(new_finish, x);</span><br><span class="line">            ++new_finish;</span><br><span class="line">            new_finish = uninitialized_copy(<span class="built_in">position</span>, finish, new_finish); <span class="comment">//拷贝安插点之后的内容，因为insert也可能需要扩充</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> () &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 销毁原vector</span></span><br><span class="line">        destroy(<span class="built_in">begin</span>(), <span class="built_in">end</span>());</span><br><span class="line">        deallocate();</span><br><span class="line">        <span class="comment">// 更新</span></span><br><span class="line">        start = new_start;</span><br><span class="line">        finish = new_finish;</span><br><span class="line">        end_of_storage = new_start + len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>vector的iterator（GNU4.9：舍近求远）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc = <span class="built_in">std</span>::allocator&lt;_Tp&gt;&gt;</span><br><span class="line">class <span class="built_in">vector</span> : <span class="keyword">protected</span> _Vector_base&lt;_Tp, _Alloc&gt;&#123;</span><br><span class="line">    <span class="keyword">typedef</span> _Vector_Base&lt;_Tp, _Alloc&gt; _Base;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> _Base::pointer pointer;</span><br><span class="line">    <span class="keyword">typedef</span> __gnu_cxx::__normal_iterator&lt;pointer, <span class="built_in">vector</span>&gt; iterator;</span><br><span class="line">    <span class="comment">// _M_current:_Tp* 本质与GNU2.9相同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3><p>TR1版本（C++1之后）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="built_in">std</span>::<span class="keyword">size_t</span> _Nm&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">array</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> _Tp value_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp* pointer;</span><br><span class="line">    <span class="keyword">typedef</span> value_type* iterator;</span><br><span class="line">    </span><br><span class="line">    value_type _M_instance[_Nm ? _Nm : <span class="number">1</span>]; <span class="comment">// 长度为0的默认为1</span></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> iterator(&amp;_M_instance[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> iterator(&amp;_M_instance[_Nm]);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GNU4.9中的定义方式本质与之相同，变得更加复杂，但没有明显好处</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="built_in">std</span>::<span class="keyword">size_t</span> _Nm&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">array</span>&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//support for zero-sized array</span></span><br><span class="line">    <span class="keyword">typedef</span> _GLIIBCXX_STD_C::__array_traits&lt;_Tp, _Nm&gt; _AT_Type;</span><br><span class="line">    <span class="keyword">typename</span> _AT_Type::_Type _M_elems;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="built_in">std</span>::<span class="keyword">size_t</span> _Nm&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">array_traits</span>&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> _Tp _Type[_Nm];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">100</span>]; <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">int</span>[<span class="number">100</span>] b; <span class="comment">// fail</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> T[<span class="number">100</span>]; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><p>看上去连续，其实是分段的：多个buffer（或者称为node）</p>
<p>有一个中控（称为map）维护这些buffer，map是个vector</p>
<p>iterator分为四格：cur,first,last,node（前三个都是指向node中的位置）</p>
<h2 id="迭代器-1"><a href="#迭代器-1" class="headerlink" title="迭代器"></a>迭代器</h2><p>例：以<code>rotate</code>函数为例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _ForwardIterator&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(_ForwardIterator __first,</span></span></span><br><span class="line"><span class="function"><span class="params">                  _ForwardIterator __middle,</span></span></span><br><span class="line"><span class="function"><span class="params">                  _ForwardITerator __last)</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::__rotate(__first, __middle, __last,</span><br><span class="line">                  <span class="built_in">std</span>::__iterator_category(__first));    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>rotate</code>需要知道iterators的三个associated types：为了回答iterator的类型，在C++标准库中设计出5种，<code>iterator_category</code>，<code>difference_type</code>， <code>value_type</code>，<code>reference</code>， <code>pointer</code>，后两种在STL中从未使用过。</p>
<p>回答的方式：<code>typedef</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GNU2.9</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Ref</span>, <span class="title">class</span> <span class="title">Ptr</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">list_iterator</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category; <span class="comment">// necessary</span></span><br><span class="line">    <span class="keyword">typedef</span> T value_type; <span class="comment">// necessary </span></span><br><span class="line">    <span class="keyword">typedef</span> Ptr pointer; <span class="comment">// necessary</span></span><br><span class="line">    <span class="keyword">typedef</span> Ref reference; <span class="comment">// necessary</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> differnece_type; <span class="comment">// necessary</span></span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// GNU4.9</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">List_iterator</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::bidirectional_iterator_tag iterator_category; <span class="comment">// necessary</span></span><br><span class="line">    <span class="keyword">typedef</span> _Tp value_type; <span class="comment">// necessary </span></span><br><span class="line">    <span class="keyword">typedef</span> _Tp* pointer; <span class="comment">// necessary</span></span><br><span class="line">    <span class="keyword">typedef</span> _Tp&amp; reference; <span class="comment">// necessary</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> differnece_type; <span class="comment">// necessary</span></span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>萃取机<code>traits</code></p>
<p>分辨iterator是class还是pointer</p>
<p>实现方法：<em>偏特化</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type value_type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 偏特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">sturct</span> <span class="title">iterator_traits</span>&lt;T*&gt;&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&lt;const *T&gt;&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><u>标准库中有各式各样的萃取机</u></p>
<h2 id="分配器"><a href="#分配器" class="headerlink" title="分配器"></a>分配器</h2><p>除了默认的allocator之外还有</p>
<p>mt_allocator，debug_allocator，pool_allocator，bitmap_allocator，malloc_allocator，new_allocator，要<code>include&lt;ext\相应的头文件&gt;</code></p>
<p><u>分配器可以直接使用，但没有必要</u></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">allocator&lt;<span class="keyword">int</span>&gt; alloc;</span><br><span class="line">p = alloc.allocate(<span class="number">1</span>); <span class="comment">// 1个元素</span></span><br><span class="line">alloc.deallocate(p, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>所有分配内存（包括<code>new</code>）都会归结到<code>malloc</code></p>
<p>由于malloc需要记录指针和<em>分配内存大小</em>，这是额外开销。但在容器中，利用元素大小相同这一点，G2.9 标准库 alloc对<code>allocator</code>的实现设计了16个链表，以节省这一部分开销。G4.9中命名为pool_allocator可以调用（不再是默认）。</p>
<h2 id="泛型编程（GP）"><a href="#泛型编程（GP）" class="headerlink" title="泛型编程（GP）"></a>泛型编程（GP）</h2><p>面向对象编程（OOP）把方法放进对象</p>
<p>泛型编程（GP）却将datas和methods分开</p>
<p><em>算法</em>通过<em>迭代器</em>确定操作范围，并通过<em>迭代器</em>取用<em>容器</em>元素。这样<em>算法</em>和<em>容器</em>可以独立开发。</p>
<p>所有的算法，最终涉及元素本身的操作，就是<u>比大小</u></p>
<p>Template模板（略）</p>
<p>Specialization特化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">type_traits</span>&#123;</span>...&#125;</span><br><span class="line"><span class="comment">// 特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">type_traits</span>&lt;int&gt;&#123;</span>...&#125;</span><br></pre></td></tr></table></figure>
<p>Partial Specialization偏特化：可以特化一部分template（个数偏特化），也可以改变template</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Iterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span> &#123;</span>...&#125;</span><br><span class="line"><span class="comment">// 偏特化为指针</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&lt;T*&gt; &#123;</span>...&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/20/complexity/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hulieu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hulieu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/20/complexity/" class="post-title-link" itemprop="url">复杂性问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-20 10:54:11" itemprop="dateCreated datePublished" datetime="2020-03-20T10:54:11+08:00">2020-03-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-22 11:03:12" itemprop="dateModified" datetime="2020-03-22T11:03:12+08:00">2020-03-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%8C%AB%E7%88%AA%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">猫爪记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%8C%AB%E7%88%AA%E8%AE%B0/Computer-Science/" itemprop="url" rel="index"><span itemprop="name">Computer-Science</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>P/NP</p>
<h3 id="PCP-History"><a href="#PCP-History" class="headerlink" title="PCP History"></a>PCP History</h3><p>PCP Theorem begins at MIT in the early 1980s: <em>The Knowledge Complexity of Interactive Proof Systems(Goldwasser, Micali, Rackoff)</em>，文中给出如下定义：</p>
<p>定义 1：<strong>IP（Interactive Proofs）</strong>定义为一个验证者（verifier）和全能的证明者（prover）进行多项式轮交互，正确的论述一定通过 (“completeness”)，错误的论述会有至少1/2的概率不通过 (“soundness”)  </p>
<p>独立于上述工作的<em>Arthur-Merlin Games: A Randomized Proof System, and a Hierarchy of Complexity Classes(Babai, Moran)</em>，定义如下：</p>
<p>定义 2：<strong>AM[k]</strong>是k轮的交互过程。</p>
<p>Babai证明了（定理 1）对任何常数k，AM[k]=AM[2]，因此AM[2]也被写作AM。AM[poly]和IP很相似，区别在于coin是否public，Goldwasser和Sipser很快证明了他们等价。</p>
<p>定义 3：Graph Non-Isomorphism是给定两个图的邻接表，判断他们是否同构</p>
<p>定理 2： Graph Non-Isomorphism是IP问题。（证明：随机重命名图，然后给prover判断是哪个）</p>
<p>定义 4：<strong>MIP</strong>是和多个独立Prover的交互问题。（Ben-Or, Goldwasser, Kilian, Wigderson, 1988）（他们还证明了多个Prover和两个Prover等价）</p>
<p>定理 3：$P^{井P}\subseteq IP$（Lund, Fortnow, Karloff, Nisan, 1990）</p>
<p>定理 4：IP=PSPACE（Shamir, 1990）</p>
<p>定理 5：MIP=NEXP（Babai, Fortnow, Lund, 1990）</p>
<p>人们试图给Verifier加限制，比如空间限制，Condon证明了NP是Verifier有对数空间和单向读权限的IP，另一个限制是时间，但是B-F-L-S证明了Prover用特定语言来写证明就可以在多项式时间内证明所有NP。最有趣的是同时限制Verifier的随机数数量和Proof的大小，其定义如下</p>
<p>定义 5：$PCP[r(n),q(n)]$是PCP系统，使用$O(r(n))$字节的Randomness，$O(q(n))$字节的Proof，并且completeness 1，soundness 1/2。</p>
<p>在这个定义下，$MIP=NEXP$的结果等价于$NEXP\subseteq PCP[poly, poly]$。B-F-L-S关于时间的限制的结论等价于$NP\subseteq PCP[polylog, polylog]$。</p>
<p>定理 6：$NP\subseteq PCP(f(n), f(n))$，其中$f(n)=log(n)log(log(n))$，进一步，MAX-CLIQUE无法近似除非$NP\subseteq DTIME(n^{log(log(n))})$（FGLSS，FOCS，1991）</p>
<p>看上去$NP\subseteq PCP[log(n),log(n)]$是必然的，最终在1992年得到证明，query的数量约$10^6$</p>
<p>定理 7： $NP\subseteq PCP[log(n), log(n)]$，实际上$NP\subseteq PCP[log(n), log(n)^{.5+\epsilon}]$（Arora，Safra，1992）</p>
<p>定理 8（<strong>PCP定理</strong>）：$NP\subseteq PCP[log(n), 1]$（Arora-Lund-Motwani-Sudan-Szegedy，1992）</p>
<h3 id="算子代数"><a href="#算子代数" class="headerlink" title="算子代数"></a>算子代数</h3><p><strong>Connes‘ embeddings conjecture（CEC）</strong>是算子代数最有名的开放问题之一，猜测任意有限冯诺依曼代数可以被有限维矩阵代数接近。</p>
<p>CEC有很多等价形式，其中之一是<strong>Tsirelson’s Problem</strong>，这个问题从Einstein-Podolsky-Rosen的问题出发，定义希尔伯特空间H，一个Projection valued measure（PVM）定义为H上投影的有限集合$\{P_1,…,P_m\}$满足$\sum P_i=Id$。对于有限指标集$X,Y,A,B$，Tsirelson考虑凸子集$Q_{ABXY}^C$（commuting）和$Q_{ABXY}^S$（spatial），定义如下</p>
<script type="math/tex; mode=display">
Q_{ABXY}^C=\{(<\phi,A_a^xB_b^y\phi>)_{a,b,x,y}:\phi\in H,\\
\{A_a^x\}_{a\in A},\{B_b^y\}_{b\in B}PVM,[A_a^x,B_b^y]=0\}</script><script type="math/tex; mode=display">
Q_{ABXY}^S=\{(<\phi,A_a^x\otimes B_b^y\phi>)_{a,b,x,y}:\phi\in H_A\otimes H_B,\\
\{A_a^x\}_{a\in A},\{B_b^y\}_{b\in B}PVM\:on\:H_A,H_B,\:resp.\}</script><p>Tsirelson起初声称两者相等，但很快他把两者是否相等重新设定为开放问题。约25年后Slofstra证明了两者不等，但$\bar{Q_{ABXY}^S}=Q_{ABXY}^C$是否成立依旧开放。Ozawa证明了这个问题和CEC等价，这样将这个问题从量子力学领域转移到算子代数领域。</p>
<p>Tsirelson的问题的提出源自量子力学的<strong>entanglement</strong>现象。在E-P-R之后30年，Bell提出<strong>Bell实验</strong>，假设两个物理系统从任意状态初始，假设两个系统可以分别被有限集合$A^x,x\in X$和$B^y,y\in Y$度量，假设通过度量产生$(a,b)\in A\times B$，定义<strong>correlation set</strong>为包含所有$p_{abxy}$的凸集$K_{ABXY}\subseteq [0,1]^{A\times B\times X\times Y}$。Bell实验需要联合可测性，冯诺依曼证明这等价于$A^x\in O_A$和$B^y\in O_B$可交换。谱分解为$A^x=\sum_a\lambda_aA_a^x$和$B^y=\sum_b\mu_bB_b^y$，然后可以定义观测到$(a,b)$的概率，可以证明这是well-defined分布族，也即上文定义的$Q_{ABXY}^C$。Bell实验可以表示为<strong>nonlocal game</strong>。</p>
<p><strong>从IP到MIP</strong>（上文PCP已详述）Babai证明了$NEXP\subseteq MIP$，进而有PCP定理。</p>
<p>一个nonlocal game有一个Verifier和两个Prover（这里也是Player），每次Verifier从$X\times Y$中选择一对问题$(x,y)$，然后分别发送给两个Prover，得到$a\in A$和$b\in B$两个答案，然后评价$V(a,b|x,y)\in \{0,1\}$。如果V=1，那么认为Prover获胜，否则他们失败。Verifier的问题分布$\pi$已知，V公开，Player可以有预先设定的策略。Player的两个策略函数$f_A:X\times \Omega\to A$，$f_B:Y\times\Omega\to B$，在经典意义下</p>
<script type="math/tex; mode=display">
\omega(G)=\sup_{f_A,f_B}\sum_{x,y}\pi(x.y)\sum_{a,b}V(a,b|x,y)\times\int_\Omega1_{f_A(x,\omega)=a}1_{f_B(y,\omega)=b}d\omega</script><p>Spatial value</p>
<script type="math/tex; mode=display">
\omega^S(G)=\sup_{A^x,b^y}\sum_{x,y}\pi(x,y)\sum_{a,b}V(a,b|x,y)\times<\phi,(A_a^x\otimes B_b^y)\phi></script><p>Commuting value</p>
<script type="math/tex; mode=display">
\omega^C(G)=\sup_{A^x,b^y}\sum_{x,y}\pi(x,y)\sum_{a,b}V(a,b|x,y)\times<\phi,A_a^xB_b^y\phi></script><p>$\omega(G)\leq \omega^S(G)\leq\omega^C(G)$，上文Tsirelson问题等价于$\omega^S(G)=\omega^C(G)$</p>
<p>我们首先证明$\omega(G)&lt;\omega^S(G)$，以Magic Square(MS)为例，游戏规则如下</p>
<p><img src="ms.png" alt=""></p>
<p>可以得到classical value $\omega(MS)=17/18&lt;1$，而spatial value $\omega^S(MS)=1$</p>
<p>一系列复杂性理论提出了技术来抵抗Prover对entanglement的利用。现在我们知道任何证明系统都可以使得entanglement不再有用，并得出结论$NEXP=MIP\subseteq MIP^*$。前一半等号的证明由Babai等给出。Natarajan和Wright证明了MIP<em>严格大于NEXP，并且$NEEXP\subseteq MIP^\</em>$。</p>
<p>From below，$O(|X|log|A|+|Y|log|B|)$在多项式时间内，所以$MIP\subseteq NEXP$。在entanglement的情况下，对固定维数d，可以找到一连串有限网络$N_1\subseteq … \subseteq N_k\subseteq …$，$N_k$的大小为$k^{O(d^2)}$，那么对d维的任意策略，有$N_k$中的策略和其误差在$1/k$。令$\omega_{\leq n}^S$表示$d,k\leq n$时$N_k$在d维下的最高准确率。那么$\{\omega_{\leq n}^S\}$是个有界非减数列，并收敛到Spatial Value $\omega^S(G)$。这里Commuting value并没有有限维逼近。</p>
<p>From above，有一种”dual approach”，最简单的方法就是用一个系数$\alpha_{abxy}$代替$&lt;\phi,A_a^xB_b^y\phi&gt;$，然后考虑其最大值，当然这回极大的高估，所以可以通过引入限制来修正，比如对任意x,y，系数对a,b求和为1，又如增加层次性限制，引入了形如$&lt;\phi,(A_{a_1}^{x_1}B_{b_1}^{y_1}A_{a_2}^{x_2}…B_{b_k}^{y_k})\phi&gt;$，然后考虑在所有乘积长度小于等于n的约束下的最大值，得到非降数列$\{\omega_{\leq n}^C\}$，它收敛到$\omega^C(G)$。</p>
<p>如果$\bar{Q^S}=Q^C$，现在考虑MIP<em>中的问题L，这意味着有方法可以将问题的实例转换为$G=\{\pi(x,y)V(a,b|x,y)\}$，如果是正例，$\omega^S(G)$接近1，否则会小很多。执行G的算法，可以发现任何L的成员可以被可停机的算法决定，这就是说明$MIP\</em>$是<strong>decidable</strong>。Slofstra证明了如果没有2/3-1/3 promise，那么$\omega^S(G)=1$是<strong>undecidable</strong>，这样就没有<strong>finite gap $\delta$</strong>使得下界达到$1-\delta$。</p>
<p><strong>2020年1月已经证明了$MIP^*=RE$</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/17/design-pattern/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hulieu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hulieu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/17/design-pattern/" class="post-title-link" itemprop="url">设计模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-17 22:44:28" itemprop="dateCreated datePublished" datetime="2020-03-17T22:44:28+08:00">2020-03-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-20 11:01:00" itemprop="dateModified" datetime="2020-03-20T11:01:00+08:00">2020-03-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%8C%AB%E7%88%AA%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">猫爪记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%8C%AB%E7%88%AA%E8%AE%B0/Computer-Science/" itemprop="url" rel="index"><span itemprop="name">Computer-Science</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>两种手段</p>
<ul>
<li>抽象</li>
<li>分解</li>
</ul>
<p>八大原则</p>
<ul>
<li>依赖倒置原则（DIP）</li>
<li>开放封闭原则（OCP）</li>
<li>单一职责原则（SRP）</li>
<li>Liskov替换原则（LSP）</li>
<li>接口隔离原则（ISP）</li>
<li>对象组合优于类继承</li>
<li>封装变化点</li>
<li>面向接口编程</li>
</ul>
<p>五个重构技巧</p>
<ul>
<li>静态改为动态</li>
<li>早绑定改为晚绑定</li>
<li>继承改为组合</li>
<li>编译时依赖改为运行时依赖</li>
<li>紧耦合改为松耦合</li>
</ul>
<p>二十三个模式分类<em>（斜体为不常用）</em></p>
<ul>
<li>组件协作<ul>
<li>模板（Template Method）</li>
<li>策略（Strategy）</li>
<li>观察者（Observer）</li>
</ul>
</li>
<li>单一职责<ul>
<li>装饰器（Decorator）</li>
<li>桥（Bridge）</li>
</ul>
</li>
<li>对象创建<ul>
<li>工厂模式（Factory Method）</li>
<li>抽象工厂（Abstract Factory）</li>
<li>原型（Prototype）</li>
<li><em>构建器（Builder）</em></li>
</ul>
</li>
<li>对象性能<ul>
<li>Singleton</li>
<li>Flyweight</li>
</ul>
</li>
<li>接口隔离<ul>
<li>门面（Facade）</li>
<li>代理（Proxy）</li>
<li><em>中介模式（Mediator）：中介对象的具体实现过于复杂</em></li>
<li>转换器（Adapter）</li>
</ul>
</li>
<li>状态变化<ul>
<li><em>备忘录（Memento）：被序列化所替代</em></li>
<li>状态模式（State）</li>
</ul>
</li>
<li>数据结构<ul>
<li>组合器（Composite）</li>
<li><em>迭代器（Iterator）：编译时多态</em></li>
<li><em>职责链（Chain of Responsibility）</em></li>
</ul>
</li>
<li>行为变化<ul>
<li><em>命令模式（Command）：Function Object</em></li>
<li><em>访问者（Visitor）：前提苛刻</em></li>
</ul>
</li>
<li>领域问题<ul>
<li><em>编译器（Interpreter）</em></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/12/algorithms-for-big-data-analysis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hulieu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hulieu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/12/algorithms-for-big-data-analysis/" class="post-title-link" itemprop="url">大数据分析中的算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-12 10:59:23" itemprop="dateCreated datePublished" datetime="2020-03-12T10:59:23+08:00">2020-03-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-01 21:39:35" itemprop="dateModified" datetime="2020-05-01T21:39:35+08:00">2020-05-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%8C%AB%E7%88%AA%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">猫爪记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%8C%AB%E7%88%AA%E8%AE%B0/Mathematics/" itemprop="url" rel="index"><span itemprop="name">Mathematics</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>优化算法四种基本方法</p>
<ul>
<li>Taylor展开</li>
<li>考虑对偶</li>
<li>split（拆分问题，比如换元法）</li>
<li>交替极小（BCD）</li>
</ul>
<h3 id="凸优化"><a href="#凸优化" class="headerlink" title="凸优化"></a>凸优化</h3><p>强对偶/KKT条件</p>
<p>单纯形法</p>
<p>内点法</p>
<h3 id="压缩感知"><a href="#压缩感知" class="headerlink" title="压缩感知"></a>压缩感知</h3><p>稀疏表示问题：</p>
<script type="math/tex; mode=display">
min\:||x||\\
s.t.\:Ax=b</script><p><u>L0范数是NP难问题，L1范数可以等价为线性规划</u></p>
<p>稀疏表示=好的压缩感知</p>
<p><strong>第一个基础结论：（感知稀疏信号）</strong></p>
<p><strong>x是s-稀疏的</strong>（s个非零元），通过m个随机感知，$b_k=<a_k, x>,\:k=1,2,…,m$，通过L1最小化重建</p>
<p>如果$m\geq slog(n)$就可以精确重建</p>
<p><strong>第二个基础结论：（非适应性感知可压缩的信号）</strong></p>
<p>$m\geq slog(n)$甚至$m\geq slog(n/s)$，就可以达到</p>
<script type="math/tex; mode=display">
||\hat{x}-x||_2\leq ||x-x_s||_2</script><p>其中$x_s$是s个最大的系数。</p>
<p><strong>第三个基础结论：（对比Lasso或Dantzig）</strong></p>
<p>令$\bar{s}=m/log(n/m)$</p>
<script type="math/tex; mode=display">
||\hat{x}-x||_2^2\leq\inf_{1\leq s\leq\bar{s}}||x-x_s||_2^2+log(n\frac{s\delta^2}{m})</script><p><strong>SPARK</strong></p>
<p>spark(A)定义为A最小的线性相关列个数，一般情况下，$spark(A)\neq rank(A)+1$</p>
<p>定理（Gorodnitsky&amp;Rao 1997）：如果$Ax=b$有一个解x满足$||X||_0\leq spark(A)/2$，那么x是最稀疏的解。（证明思路：$||x||_0+||y||_0\geq ||x-y||_0\geq spark(A)$）</p>
<p><strong>Coherence</strong></p>
<p>Coherence定义为A列向量间最大的正则内积（夹角大小）：$\mu(A)=max\frac{|a_k^Ta_j|}{||a_k||_2||a_j||_2}$</p>
<p>定理（Donoho&amp;Elad 2003）：$spark(A)\geq 1+\mu^{-1}(A)$</p>
<p>证明：$A$列正则化为$\bar{A}$，令$p=spark(A)$，$B=\bar{A}^T\bar{A}$的$p\times p$的主子式。所以B对角线为1，且$\sum_{j\neq i}|B_{ij}|\leq(p-1)\mu(A)$。如果$p<1+\mu^{-1}(A)$，那么$|B_{ii}|>\sum_{j\neq i}|B_{ij}|$，所以$B\succ 0$（Gershgorin circle theorem），$spark(A)&gt;p$矛盾。</p>
<p>推论：如果$Ax=b$有一个解x满足$||X||_0\leq (1+\mu^{-1}(A))/2$，那么x是<strong>唯一</strong>最稀疏的解。</p>
<p><strong>定理（Donoho&amp;Elad 2003）</strong>：如果A有正则化的列且$Ax=b$有一个解x满足$||X||_0\leq (1+\mu^{-1}(A))/2$，那么x是唯一最稀疏的解，<strong>在L0和L1条件下</strong>。</p>
<p>证明：由前面定理可知$x$是L0唯一解，设$S$为x张成的空间，设$y$为L1的解，令$h=y-x$，所以$Ah=0$且$||h||_1&lt;2||h_S||_1$（因为$||h_{S^C}||_1&lt;||h_S||_1$）。根据$A^TAh=0$和$||h||_1=\sum_{k\neq j}|h_k|+|h_j|$，得到</p>
<script type="math/tex; mode=display">
|h_j|\leq(1+\mu(A))^{-1}\mu(A)||h||_1</script><p>综合两式得到$|h_j|&lt;1$矛盾。</p>
<p><strong>null space相关性质</strong></p>
<p>引理：$0 &lt; p\leq 1$，如果$||(y-x)_{S^C}||_p>||(y-x)_S||_P$，那么$||x||_P&lt;||y||_p$。</p>
<p>定义：null space property（$NSP(k,\gamma)$），每个非零$h\in N(A)$满足$||h_S||_1&lt;\gamma||h_{S^C}||_1$对所有$|S|\leq k$。</p>
<p>定理（Donoho&amp;Huo 2001）L1范数问题可以唯一恢复k-sparse向量x从$b=Ax$当且仅当A满足 $NSP(k,1)$（证明：充分性S为x张成空间即可，必要性考虑等号成立条件$sgn(x_S)=-sgn(h_S)$。）</p>
<p>引理（Zhang 2008）：$||x||_1 &lt; ||y||_1$的一个充分条件是$||x||_0 &lt; \frac{1}{4}(\frac{||h||_1}{||h||_2})^2$</p>
<p>（证明：$||h_S||_1\leq\sqrt{|S|}||h_S||_2\leq\sqrt{||x||_0}||h||_2$，因而上不等式意味着$||h_{S^C}||_1 &gt; ||h_S||_1$。）</p>
<p>定理（Zhang 2008）L1范数问题可以唯一恢复x如果</p>
<script type="math/tex; mode=display">
||x||_0<min\{\frac{1}{4}(\frac{||h||_1}{||h||_2})^2,h\in N(A)\backslash\{0\}\}</script><p><strong>RIP(Restriceted Isometry constants)</strong></p>
<p>定义：对k，$\delta_k$是最小的标量对所有k-sparse的x满足</p>
<script type="math/tex; mode=display">
(1-\delta_k)||x||_2^2\leq ||Ax||_2^2\leq(1+\delta_k)||x||_2^2</script><p>想法：稀疏恢复=远离零空间，如果A有2s线性相关列则不能恢复</p>
<p>$\delta_{2k}$是是最小的标量对所有k-sparse的$x_1,x_2$满足</p>
<script type="math/tex; mode=display">
(1-\delta_{2k})||x_1-x_2||_2^2\leq ||Ax_1-Ax_2||_2^2\leq(1+\delta_{2k})||x_1-x_2||_2^2</script><p>那么如果有s-sparse的解x满足Ax=b</p>
<ul>
<li>如果$\delta_{2s}&lt;1$则L0最优解唯一</li>
<li>如果$\delta_{2s}&lt;0.414$，那么LP relaxtion的解唯一且相等</li>
<li>(Cai-Wang-Wu)$\delta_{2s}&lt;0.307$是充分的</li>
<li>(Cai-Zhang)$\delta_{2s}&lt;1/3$是L1重建的充要条件。</li>
</ul>
<p><strong>L1解的特征</strong></p>
<p>x是解等价于$||x+h||_1\geq ||x||_1$对任意属于A零空间的h</p>
<p>L1重建的充要条件为对所有属于零空间的h，</p>
<script type="math/tex; mode=display">
\sum_{i\in T}sgn(x_i)h_i\leq\sum_{i\in T^C}|h_i|</script><p><strong>KKT条件的性质</strong></p>
<script type="math/tex; mode=display">
L(x,\lambda)=f(x)+<\lambda,b-Ax></script><p>x是解当且仅当x可行，存在$\lambda$</p>
<script type="math/tex; mode=display">
\nabla f(x)-A^*\lambda=0</script><p>即$\nabla f(x)\perp null(A)$。当$f(x)$不可微时，可用<strong>次梯度</strong>同样成立。</p>
<p>推论：那么L1解x是最优的当且仅当存在$u=A^*\lambda$，满足</p>
<script type="math/tex; mode=display">
u_i=sgn(x_i),x_i\neq 0(i\in T)\\
|u_i|\leq 1,x_i=0(i\in T^C)</script><p>如果$|u_i|<1$且$A^T$列满秩则x唯一。（只需证零空间的h，$||x+h||_1 > ||x||_1$）</p>
<p>T=supp(x)且$A_T$列满秩，定义valid dual certificate u（作用是证明可以达到）</p>
<script type="math/tex; mode=display">
u:=A^*A_T(A_T^*A_T)^{-1}sgn(x_T)</script><p>则y是$A^*\lambda$的形式，且$u_i=sgn(x_i)$（$i\in T$）。对$i\in T^C$，$|u_i|&lt;1$的证明如下</p>
<p>定义常数$\theta_{S,S’}$满足对所有不相交的集合$T,T’$，$|T|\leq S$，$|T’|\leq S’$，满足</p>
<script type="math/tex; mode=display">
<A_{T}c,A_{T'}c'>\leq \theta_{S,S'}||c||||c'||</script><p>如果$S\geq 1$且$\delta_S+\theta_{S,S’}+\theta_{S,2S}&lt;1$，那么如果$|supp(x)|\leq S$，x唯一。</p>
<p>引理：令$S\geq 1$满足$\delta_S+\theta_{S,2S}&lt;1$，那么存在$\lambda$满足对所有$j\in T$，$\lambda^*A_j=sgn(x_j)$，且对所有$j\in T^C$</p>
<script type="math/tex; mode=display">
|u_j|=|\lambda^*A_j|\leq\frac{\theta_{S,S'}}{(1-\delta_S-\theta_{S,2S})\sqrt{S}}||sgn(x)||\leq 1</script><h3 id="压缩感知（算法）"><a href="#压缩感知（算法）" class="headerlink" title="压缩感知（算法）"></a>压缩感知（算法）</h3><p>L1正则的最小二乘问题</p>
<script type="math/tex; mode=display">
min\:\mu||x||_1+\frac{1}{2}||Ax-b||_2^2</script><h5 id="Proximal-Gradient-Method-ISTA-FPC"><a href="#Proximal-Gradient-Method-ISTA-FPC" class="headerlink" title="Proximal Gradient Method/ISTA/FPC"></a>Proximal Gradient Method/ISTA/FPC</h5><p><strong>Proximal Gradient Method</strong></p>
<script type="math/tex; mode=display">
x^{k+1}:=\arg\min\mu||x||_1+(\nabla f(x^k))^T(x-x^k)+\frac{1}{2r}||x-x^k||_2^2\\
=\arg\min\mu||x||_1+\frac{1}{2r}||x-(x^k-r\nabla f(x^k))||_2^2\\
=shrink(x^k-r\nabla f(x^k),\mu r)</script><p>定义$shrink(y,v)=sgn(y)max(|y|-v,0)$</p>
<p><strong>Proximal Gradient Method for General Problems</strong></p>
<script type="math/tex; mode=display">
\min F(x):=f(x)+r(x)</script><p>其中r(x)可以是不可微凸函数（甚至可以是离散的如L0范数），同样可以得到</p>
<script type="math/tex; mode=display">
x^{k+1}:=prox_{\gamma r}(x^k-r\nabla f(x^k))</script><p>其中代理算子</p>
<script type="math/tex; mode=display">
prox_r(y):=argmin\:r(x)+\frac{1}{2}||x-y||_2^2</script><p><u>Proximal Gradient也叫投影梯度法。</u></p>
<p>代理算子的性质：</p>
<script type="math/tex; mode=display">
x=prox_r(y)\Leftrightarrow y-x\in\partial r(x)</script><p>然后由Cauchy-Schwarz不等式得到</p>
<script type="math/tex; mode=display">
||prox_r(y)-prox_r(x)||_2\leq ||x-y||_2</script><p><strong>收敛性问题</strong></p>
<p>在一定假设下，$h(x)=x-\gamma\nabla f(x)$满足</p>
<script type="math/tex; mode=display">
||h(x)-h(x')||\leq||x-x'||</script><p><strong>线性搜索</strong></p>
<script type="math/tex; mode=display">
x^k(r^k)=shrink(x^k-r^k\nabla f^k,\mu r^k)</script><p>那么设定</p>
<script type="math/tex; mode=display">
x^{k+1}=x^k+\alpha^k(x^k(r^k)-x^k)=x^k+\alpha^k d^k</script><p>$r^k$的选择：Barzilai-Borwein法（$\min||rs-y||^2$）</p>
<script type="math/tex; mode=display">
s^{k-1}=x^k-x^{k-1},y^{k-1}=\nabla f^k-\nabla f^{k-1}\\
r^k=\frac{(s^{k-1})^Ts^{k-1}}{(s^{k-1})^Ty^{k-1}}or\frac{(s^{k-1})^Ty^{k-1}}{(y^{k-1})^Ty^{k-1}}</script><p>$r^k$需要通过truncation限制大小</p>
<p>$\alpha^k$的选择：Armijo-like线性搜索（能够达到超线性收敛速度）</p>
<p>（Armijo-Goldstein：$C^k=F(x^k)$）</p>
<script type="math/tex; mode=display">
F(x^k+\alpha^k d^k)\leq C^k+\sigma a^k\Delta^k</script><ul>
<li>FPC：$\Delta^k=(\nabla f^k)^Td^k</li>
<li>FPC_AS：$\Delta^k=(\nabla f^k)^Td^k+\mu||x^k(r^k)||_1-\mu||x^k||_1</li>
<li>non-monotone line search(Zhang and Hagar)：$C^k=(\eta Q^{k-1}C^{k-1}+F(x^k))/Q^k$，$Q^k=\eta Q^{k-1}+1$，$C^0=F(x^0)$，$Q^0=1$</li>
</ul>
<p><strong>三种名称</strong></p>
<ul>
<li>proximal gradient method</li>
<li>ISTA: iterative shrinkage thresholding algorithm</li>
<li>FPC: fixed-point continuation method</li>
</ul>
<p>如果$f(x)$满足Lipschitz连续条件$||\nabla f(x)-\nabla f(y)||_2\leq L||x-y||_2$，那么可以得到</p>
<script type="math/tex; mode=display">
p_L(y)=prox_{r, 1/L}(y-\frac{1}{L}\nabla f(y))</script><p><strong>复杂性分析</strong></p>
<script type="math/tex; mode=display">
F(x^k)-F(x^*)\leq \frac{L||x_0-x^*||_2^2}{2k}</script><p>(证明：引理$F(x)-F(pl(y))\geq \frac{L}{2}(||pl(y)-x||_2^2-||x-y||_2^2)$)</p>
<p><strong>FISTA: accelerated proximal gradient(APG)</strong></p>
<p><u>FISTA/APG的理论收敛性质较好，但实际中不如B-B算法</u></p>
<p>令$y^1=x_0$，$t^1=1$</p>
<script type="math/tex; mode=display">
x^k=pL(y^k)\\
t^{k+1}=\frac{1+\sqrt{1+4(t^{k})^2}}{2}\\
y^{k+1}=x^k+\frac{t^k-1}{t^{k+1}}(x^k-x^{k-1})</script><p>复杂性结果</p>
<script type="math/tex; mode=display">
F(x^k)-F(x^*)\leq \frac{2L||x_0-x^*||_2^2}{(k+1)^2}</script><p>证明：令$v_k=F(x^k)-F(x^*)$，$u_k=t^kx^k-(t^k-1)x^{k-1}-x^*$，那么</p>
<script type="math/tex; mode=display">
\frac{2}{L}(t_k^2v_k-t_{k+1}^2v_{k+1})\geq ||u_{k+1}||_2^2-||u_k||_2^2</script><p><strong>APG的几个变体</strong></p>
<p>Variant 1</p>
<p>$x_{-1}=x_0$，$\theta_{-1}=\theta_0=1$</p>
<script type="math/tex; mode=display">
y_k=x_k+\theta_k(\theta_{k-1}^{-1}-1)(x_k-x_{k-1})\\
x_{k+1}=\arg\min l(x,y_k)+\frac{L}{2}||x-y_k||_2^2\\
\theta_{k+1}=\frac{\sqrt{\theta_k^4+4\theta_k^2}-\theta_k^2}{2}</script><p>($\theta_k$其实相当于$t_k$的倒数)</p>
<p>Variant 2</p>
<p>用Bregman distance $D(x,y_k)$来代替$\frac 12||x-y_k||_2^2$，并且令$x_0=z_0=\theta_0=1$</p>
<script type="math/tex; mode=display">
y_k=(1-\theta_k)x_k+\theta_kz_k\\
z_{k+1}=\arg\min l(x,y_k)+\theta_kL D(x,z_k)\\
x_{k+1}=(1-\theta_k)x_k+\theta_kz_{k+1}\\
\theta_{k+1}=\frac{\sqrt{\theta_k^4+4\theta_k^2}-\theta_k^2}{2}</script><p>Variant 3</p>
<p>$x_0=z_0=\arg\min h(x)$，$\theta_0=1$</p>
<script type="math/tex; mode=display">
y_k=(1-\theta_k)x_k+\theta_kz_k\\
z_{k+1}=\arg\min \sum_{i=0}^k\frac{l(x,y_i)}{\theta_i}+Lh(x)\\
x_{k+1}=(1-\theta_k)x_k+\theta_kz_{k+1}\\
\theta_{k+1}=\frac{\sqrt{\theta_k^4+4\theta_k^2}-\theta_k^2}{2}</script><p>三个变体收敛性都是$\sim \frac{1}{k^2}LD(….)$</p>
<h5 id="增广拉格朗日框架"><a href="#增广拉格朗日框架" class="headerlink" title="增广拉格朗日框架"></a>增广拉格朗日框架</h5><script type="math/tex; mode=display">
\min||x||_1,s.t.Ax=b</script><p>对偶问题</p>
<script type="math/tex; mode=display">
\max b^T\lambda,s.t.||A^T\lambda||_\infty\leq 1</script><p>等价于</p>
<script type="math/tex; mode=display">
\max b^T\lambda,s.t.A^T\lambda=s,||s||_\infty\leq 1</script><p>Augmented Lagrangian (Bregman) function</p>
<script type="math/tex; mode=display">
L(\lambda,s,x)=-b^T\lambda+x^T(A^T\lambda-s)+\frac{1}{2\mu}||A^T\lambda-s||^2</script><p>算法框架</p>
<ol>
<li><p>第k次迭代计算$\lambda^{k+1},s^{k+1}$</p>
<script type="math/tex; mode=display">
\min_{\lambda,s}L(\lambda,s,x^k),s.t.||s||_\infty\leq 1</script></li>
<li><p>更新(计算导数易得)</p>
<script type="math/tex; mode=display">
x^{k+1}=x^k+(A^T\lambda^{k+1}-s^{k+1})/\mu</script></li>
</ol>
<p><u>缺点是求min太慢</u></p>
<p> ADMM（An alternating direction minimization scheme）</p>
<script type="math/tex; mode=display">
\lambda^{k+1}=\arg\min_\lambda L(\lambda,s^k,x^k)\\
s^{k+1}=\arg\min_s L(\lambda^{k+1},s,x^k),s.t.||s||_\infty\leq 1\\
x^{k+1}=x^k+(A^T\lambda^{k+1}-s^{k+1})/\mu</script><p><u>在x更新步乘以步长1.618性能提升30%左右</u></p>
<p>Bregman method（实际与Augmented Lagrangian等价，但是计算更复杂）</p>
<script type="math/tex; mode=display">
D_J^{p^k}(x,x^k)=||x||_1-||x^k||_1-<p^k,x-x^k>\\
x^{k+1}=\arg\min_x\mu D_j^{p^k}(x,x^k)+\frac12 ||Ax-b||_2^2\\
p^{k+1}=p^k+\frac1\mu A^T(b-Ax^{k+1})</script><p><strong>Linearized ADMM</strong></p>
<p>Review of Bregman method</p>
<script type="math/tex; mode=display">
\min ||x||_1,s.t.Ax=b</script><p>Bregman method:</p>
<script type="math/tex; mode=display">
D_J^{n^k}(x,x^k)=||x||_1-||x^k||_1-<p^k,x-x^k>\\x^{k+1}=\arg\min_x\mu D_J^{n^k}(x,x^k)+\frac12||Ax-b||_2^2\\p^{k+1}=p^k+\frac1\mu A^T(b-Ax^{k+1})</script><p>（等价于</p>
<script type="math/tex; mode=display">
\min\mu\{||x||_1-<p^k,x-x^k>\}+\frac12||Ax-b||_2^2\\0\in\mu \partial||x||_1-\mu p^k+A^T(Ax^{k+1}-b)\\p^{k+1}=p^k+\frac1\mu A^T(b-Ax^{k+1})</script><p>Linearized Bregman method</p>
<script type="math/tex; mode=display">
x^{k+1}=\arg\min\mu D_L^{p^k}(x,x^k)+(A^T(Ax^k-b))^T(x-x^k)+
frac1{2\delta}||x-x^k||_2^2\\
p^{k+1}=p^k-\frac1{\mu\delta}(x^{k+1}-x^k)-\frac1\mu A^T(Ax^k-b)</script><p>实际上$x^k$逼近</p>
<script type="math/tex; mode=display">
\arg \min\mu||x||_1+\frac1{2\delta}||x||_2^2,s.t.Ax=b</script><h3 id="矩阵恢复"><a href="#矩阵恢复" class="headerlink" title="矩阵恢复"></a>矩阵恢复</h3><p>常见于推荐系统</p>
<p>起源：Netflix电影推荐竞赛</p>
<h5 id="Collaborative-Filtering（协同过滤）"><a href="#Collaborative-Filtering（协同过滤）" class="headerlink" title="Collaborative Filtering（协同过滤）"></a>Collaborative Filtering（协同过滤）</h5><script type="math/tex; mode=display">
\hat{r}_{si}=b_{si}+\sum_{j\in N(i:x)}w_{ij}(r_{xj}-b_{xj})</script><p>权重的确定：</p>
<script type="math/tex; mode=display">
\min_{w_{ij}}F(w):=\sum_x([b_{xi}+\sum_jw_{ij}(r_{xj}-b_{xj})]-r_{xi})^2</script><p>求导可得</p>
<script type="math/tex; mode=display">
\nabla_{w_{ij}}F(w)=2\sum_x([b_{xi}+\sum_jw_{ij}(r_{xj}-b_{xj})]-r_{xi})(r_{xj}-b_{xj})=0</script><p>梯度下降求解：GD、SGD</p>
<h5 id="Latent-factor-models"><a href="#Latent-factor-models" class="headerlink" title="Latent factor models"></a>Latent factor models</h5><p>“SVD” on Netflix data: </p>
<script type="math/tex; mode=display">
R\approx Q\cdot P^T</script><p>预测</p>
<script type="math/tex; mode=display">
\hat{r}_{si}=q_i\cdot p_s^T</script><p>考虑到下式有显式解（奇异值分解）</p>
<script type="math/tex; mode=display">
\min_{Q,P}||R-QP^T||_F^2</script><p>所以将原问题</p>
<script type="math/tex; mode=display">
\min\sum_{(i,j)\in\Omega}(R_{ij}-(QP^T)_{ij})^2</script><p>等价于</p>
<script type="math/tex; mode=display">
\min ||P_\Omega(R-QP^T)||_F^2,P_\Omega为投影算子</script><p>进行求解。</p>
<p>梯度下降方法：异步迭代QP（矩阵导数）</p>
<p>另外还有加上bias的latent factor model。</p>
<h5 id="General-Matrix-Completion"><a href="#General-Matrix-Completion" class="headerlink" title="General Matrix Completion"></a>General Matrix Completion</h5><script type="math/tex; mode=display">
\min rank(X)\\
s.t. X_{ij}=M_{ij},(i.j)\in\Omega</script><p><u>这是个NP-hard问题</u></p>
<p>引入奇异值分解</p>
<script type="math/tex; mode=display">
X=\sum\sigma_ku_kv_k^*</script><p>(Eckart&amp;Young 1936) if k&lt;rank(A):</p>
<script type="math/tex; mode=display">
\min_{rank(B)=k}||A-B||_2=||A-\sum_{i=1}^k\sigma_iu_iv_i^*||_2</script><h5 id="Positive-semidefinite-unknown"><a href="#Positive-semidefinite-unknown" class="headerlink" title="Positive semidefinite unknown"></a>Positive semidefinite unknown</h5><p>假设X半正定，那么可以转换为半定规划</p>
<script type="math/tex; mode=display">
\min trace(X)\\
s.t.X_{ij}=M_{ij},(i,j)\in\Omega\\
X\succeq 0</script><p>Nuclear norm和spectral norms是对偶的</p>
<script type="math/tex; mode=display">
||X||=\sigma_1(X),||X||_*=\sum\sigma_i(X)</script><p>核范数最小化</p>
<script type="math/tex; mode=display">
\left.\begin{align}\min||X||_*\\
s.t.A(X)=b\end{align}\right.
\Leftrightarrow
\left.\begin{aligned}
\max b^Ty\\
s.t.||A^T(y)||\leq 1
\end{aligned}\right.</script><p>SDP reformulation</p>
<script type="math/tex; mode=display">
\left.\begin{align}
\min\frac12(trace(W_1)+trace(W_2))\\
s.t.A(X)=b\\
\begin{pmatrix}W_1&X\\X^T&W_2\end{pmatrix}\succeq 0
\end{align}\right.
\Leftrightarrow
\left.\begin{aligned}
\max b^Ty\\
s.t.\begin{pmatrix}I&A^*(y)\\(A^*(y))^T&I\end{pmatrix}\succeq 0
\end{aligned}\right.</script><h5 id="Matrix-Shrink-Operator"><a href="#Matrix-Shrink-Operator" class="headerlink" title="Matrix Shrink Operator"></a>Matrix Shrink Operator</h5><script type="math/tex; mode=display">
\min v||X||_*+\frac12||X-Y||_F^2</script><p>Optimal solution</p>
<script type="math/tex; mode=display">
X=S_v(Y)=UDiag(s_v(\sigma))V^T</script><p>其中</p>
<script type="math/tex; mode=display">
Y=UDiag(\sigma)V^T\\
s_v(x)=\max(x_i-v,0)</script><p>可以证明这是non-expansive的。</p>
<p>计算量在SVD上。—&gt;LANSVD、LMSVD、Randomized SVD等方法</p>
<p><strong>low-rank factorization model</strong></p>
<script type="math/tex; mode=display">
\min_{X,Y,Z}\frac12||XY-Z||_F^2,s.t.Z_{ij}=M_{ij},\forall(i,j)\in\Omega</script><p>优点：不需要SVD</p>
<p>Nonlinear Gauss-Seidel scheme</p>
<script type="math/tex; mode=display">
X_+\leftarrow ZY^+\\
Y_+\leftarrow (X_+)^+Z\\
Z_+\leftarrow X_+Y_++P_\Omega(M-X_+Y_+)</script><p>这个算法需要计算广义逆，注意到</p>
<script type="math/tex; mode=display">
X_+Y_+=P_{X_+}Z=P_{ZY^T}Z</script><p>由此推出第二个版本：</p>
<script type="math/tex; mode=display">
X_+\leftarrow ZY^T\\
Y_+\leftarrow (X_+)^+Z\\
Z_+\leftarrow X_+Y_++P_\Omega(M-X_+Y_+)</script><p>这里还是有广义逆，又有$V=orth(ZY^T)$，因而</p>
<script type="math/tex; mode=display">
X_+\leftarrow V\\
Y_+\leftarrow V^TZ\\
Z_+\leftarrow X_+Y_++P_\Omega(M-X_+Y_+)</script><h5 id="矩阵分离"><a href="#矩阵分离" class="headerlink" title="矩阵分离"></a>矩阵分离</h5><p>M=W+E，其中W为低秩矩阵，E为系数矩阵</p>
<script type="math/tex; mode=display">
\min_{W,E}||W||_*+\mu||E||_1,s.t.W+E=M</script><p>Robust PCA</p>
<p>（应用：监控录像分离人和背景）</p>
<p>增广拉格朗日函数</p>
<script type="math/tex; mode=display">
L(W,E,A)=||W||_*+\mu||E||_1+<A,W+E-M>+\frac1{2\beta}||W+E-M||_F^2</script><p>ADMM:</p>
<script type="math/tex; mode=display">
W^{i+1}=\arg\min_WL(W,E^i,A^i)\\
E^{i+1}=\arg\min_EL(W^{i+1},E,A^i)\\
A^{i+1}=A^i+\frac\gamma\beta(W^{i+1}+E^{i+1}-M)</script><p>W-子问题：</p>
<script type="math/tex; mode=display">
W^{i+1}=S_\beta(M-E^j-\beta A^i)</script><p>其中$S_\beta$是将SVD的特征值shrink，见上文”Matrix Shrink Operator”</p>
<p>E-子问题：</p>
<script type="math/tex; mode=display">
E^{i+1}=S_{\beta\mu}(M-W^{i+1}-\beta A^i)</script><p>其中$S_{\beta\mu}$是L1 shrink，见上文“Proximal Gradient Method”</p>
<p><strong>low-rank factorization model for matrix seperation</strong></p>
<p>考虑模型</p>
<script type="math/tex; mode=display">
\min_{Z,S}||S||_1,s.t.Z+S=D,rank(Z)\leq k</script><p>对Z进行低秩分解</p>
<script type="math/tex; mode=display">
\min_{U,V,Z}||P_\Omega(Z-D)||_1,s.t.UV-Z=0</script><p>这里的增广拉格朗日函数为</p>
<script type="math/tex; mode=display">
L_\beta(U,V,Z,A)=||P_\Omega(Z-D)||_1+<A,UV-Z>+\frac\beta2||UV-Z||_F^2</script><p>ADMM依次优化U、V、Z、A。</p>
<p><strong>非负矩阵低秩分解</strong></p>
<p>基本相似，更加复杂</p>
<p>ADMM</p>
<h3 id="运输优化"><a href="#运输优化" class="headerlink" title="运输优化"></a>运输优化</h3><p>Application：image color adaption、shape interpolation、word mover’s distance</p>
<h5 id="Kantorovitch’s-Formulation"><a href="#Kantorovitch’s-Formulation" class="headerlink" title="Kantorovitch’s Formulation"></a>Kantorovitch’s Formulation</h5><p>输入两个离散概率度量</p>
<script type="math/tex; mode=display">
\alpha=\sum_{i=1}^ma_i\delta_{x_i},\:\beta=\sum_{j=1}^nb_j\delta_{y_j}</script><p>其中$X=\{x_i\}_i,\:Y=\{y_j\}_j$是给定的<strong>点云</strong>，$x_i,y_j$是向量。</p>
<p>$a_i,\:b_j$是<strong>正权重</strong>，满足$\sum_{i=1}^ma_i=\sum_{j=1}^nb_j=1$</p>
<p>$C_{ij}$是<strong>花费</strong>，$C_{ij}=c(x_i,y_j)\geq 0$</p>
<p>定义<strong>Couplings</strong></p>
<script type="math/tex; mode=display">
U(a,b)=\{\Pi\in R_+^{m\times n}|\Pi 1_n=a,\Pi^T1_m=b\}</script><p>Transportation 问题</p>
<script type="math/tex; mode=display">
\min \sum P_{ij}C_{ij}\\
s.t. P\in U(a,b)</script><p>推广：<strong>Radon 度量</strong>$(\alpha,\beta)$ on $(X,Y)$</p>
<p>Transfer of measure by $T:X\to Y$</p>
<p>定义Y上的度量</p>
<script type="math/tex; mode=display">
T_\#\alpha(Y)=\alpha(T^{-1}(Y))\:\forall Y\:measurable</script><p>离散情形下</p>
<script type="math/tex; mode=display">
T_\#\alpha=\sum_i\alpha_i\delta_{T(x_i)}</script><p>连续情形下</p>
<script type="math/tex; mode=display">
d\alpha=\rho(x)dx,\:d\beta=e(x)dx\\
T_\#\alpha=\beta\Leftrightarrow \rho(T(x))|det(\partial T(x))|=e(x)</script><h5 id="Monge-Problem"><a href="#Monge-Problem" class="headerlink" title="Monge Problem"></a>Monge Problem</h5><p>找到这样的T，使得</p>
<script type="math/tex; mode=display">
b_j=\sum_{i:\:T(x_i)=y_j}a_i</script><p>离散情形下</p>
<script type="math/tex; mode=display">
\min_T\sum_ic(x_i,T(x_i))\:s.t.T_\#\alpha=\beta</script><p>连续情形下</p>
<script type="math/tex; mode=display">
\min_T\int_Xc(x,T(x))d\alpha(x)\:s.t.T_\#\alpha=\beta</script><h5 id="Wasserstein-Distance"><a href="#Wasserstein-Distance" class="headerlink" title="Wasserstein Distance"></a>Wasserstein Distance</h5><p>Kantorovitch Problem for General Measures</p>
<script type="math/tex; mode=display">
L(\alpha,\beta,c)=\min_{\pi\in U(\alpha,\beta)}\int_{X\times Y}c(x,y)d\pi(x,y)</script><p>花费满足$c(x,y)=d(x,y)^p$，定义W-distance</p>
<script type="math/tex; mode=display">
W_p(\alpha,\beta)=L(\alpha,\beta,d^p)^{1/p}</script><p>可以证明这是个距离，且</p>
<script type="math/tex; mode=display">
W_p(\alpha_n,\alpha)\to 0\Leftrightarrow \alpha_n\to^{weak}\alpha</script><p><strong>Wasserstein barycenter</strong></p>
<p>定义$C=M_{XY}$，那么W-距离等于</p>
<script type="math/tex; mode=display">
L(a,b,C)=\min\{\sum C_{ij}\Pi_{ij}|\Pi\in U(a,b)\}</script><p>给定Y，b，找到X，a使得</p>
<script type="math/tex; mode=display">
\min_{X,a}\frac1N\sum_{i=1}^NL(a,b^{k},M_{XY})</script><h5 id="Dual-form"><a href="#Dual-form" class="headerlink" title="Dual form"></a>Dual form</h5><script type="math/tex; mode=display">
\max f^Ta+g^Tb\\
s.t. f_i+g_j\leq C_{ij}</script><h5 id="Entropy-regularization"><a href="#Entropy-regularization" class="headerlink" title="Entropy regularization"></a>Entropy regularization</h5><p>定义</p>
<script type="math/tex; mode=display">
H(P)=-\sum_{i,j}P_{i,j}(log(P_{i,j})-1)</script><p>定义Lullback-Leibler divergence</p>
<script type="math/tex; mode=display">
KL(u||v)=-\sum_{i=1}^nu_ilog(v_i/u_i)</script><p>定义Entropy regularization问题</p>
<script type="math/tex; mode=display">
L^e(a,b,C)=\min_{P\in U(a,b)}(P,C)-eH(P)</script><p>可以证明这个问题当$e&gt;0$时解唯一。 </p>
<p>解法：考虑Lagrangian对偶，令关于P导数为0</p>
<script type="math/tex; mode=display">
P_{ij}=exp(-\frac{C_{ij}+a_i+\beta_j}{e})</script><p>因此可以解得</p>
<script type="math/tex; mode=display">
P_e=diag(e^{-\alpha/2})e^{-C/2}diag(e^{-\beta/2})</script><p>根据KKT条件，令$u=e^{-\alpha/2}$，$v=e^{-\beta/2}$，$K=e^{-C/2}$，那么</p>
<script type="math/tex; mode=display">
P_e=diag(u)Kdiag(v)\\
a=diag(u)Kv\\
b=diag(v)K^Tu</script><p>Sinkhorn算法就是交替优化uv</p>
<script type="math/tex; mode=display">
u^{k+1}=diag(Kv^k)^{-1}a\\
v^{k+1}=diag(K^Tu^{k+1})^{-1}b</script><p> Sinkhorn-Newton 法：令</p>
<script type="math/tex; mode=display">
F(\alpha,\beta)=\begin{pmatrix}diag(e^{-\alpha/e})Ke^{-\beta/2}-a\\
diag(e^{-\beta/e})Ke^{-\alpha/2}-b\end{pmatrix}</script><p>即找到$F(\alpha,\beta)=0$的解。由此Newton Iteration为</p>
<script type="math/tex; mode=display">
\begin{pmatrix}\alpha^{k+1}\\\beta^{k+1}\end{pmatrix}=
\begin{pmatrix}\alpha^k\\\beta^k\end{pmatrix}-J_F^{-1}(\alpha^k,\beta^k)F(\alpha^k,\beta^k)</script><p><u>Sinkhorn算法是忽略非对角元素的近似Sinkhorn-Newton算法</u></p>
<p>定义</p>
<script type="math/tex; mode=display">
U_\alpha(a,b)=\{P\in U(a,b)|KL(P||ab^T)\leq\alpha\}</script><p>定义<strong>Sinkhorn Distance</strong>如下</p>
<script type="math/tex; mode=display">
d_{C,\alpha}(a,b)=\min_{P\in U_\alpha(a,b)}(C,P)</script><p>这是一个距离。</p>
<h5 id="Shielding-Neighborhood-Method"><a href="#Shielding-Neighborhood-Method" class="headerlink" title="Shielding Neighborhood Method"></a>Shielding Neighborhood Method</h5><p>Proposed by Bernhard Schmitzer in 2016</p>
<p>把主问题分解为多个稀疏子问题</p>
<p>对$N\subset X\times Y$，（称N为Neighborhood），</p>
<p>如果</p>
<script type="math/tex; mode=display">
c(x_1,y_n)\geq c(x_1,y_2)+\sum_{i=2}^{n-1}(c(x_i,y_{i+1})-c(x_i,y_i))</script><p>则称为<strong>short-cut</strong></p>
<p>定义：<strong>shielding condition</strong>是指这样的$(x_s,y_s)$使得</p>
<script type="math/tex; mode=display">
c(x,y)+c(x_s,y_s)>c(x,y_s)+c(x_s,y)</script><p>定义：<strong>shielding neighborhood</strong>是指对给定的$\pi$，满足下列条件的N：任意$(x,y)\notin N$，存在$(x_s,y_s)\in\pi$，$x_s,y_s$ shield x,y。</p>
<p>定义：<strong>multiscale scheme</strong>是把集合X分为层级结构，$X_0=\{\{x\}|x\in X\}$，之后每层是从前一层合并而来。</p>
<p>我们假设有两个子算法：</p>
<ul>
<li>solveLocal</li>
<li>shield</li>
</ul>
<p>主算法(从粗网格到细网格)</p>
<ol>
<li>$\pi=solveDense(k)$</li>
<li>while k&gt;0 do</li>
<li>​    k-=1</li>
<li>​    N={}</li>
<li>​    对 $(x,y)\in\pi$，$N=N\cup(children(x)\times children(y))$</li>
<li>​    $\pi=solveSparse(k, N)$</li>
<li>return </li>
</ol>
<p>SolveSparse算法：利用当前等级k和可行邻居N来计算$\pi$</p>
<ol>
<li>i=1</li>
<li>while i=1 or $C(\pi_i)\neq C(\pi_{i-1})$ do</li>
<li>​    $\pi_{i+1}=solveLocal(N)$</li>
<li>​    $N_{i+1}=shield(\pi_{i+1},k)$</li>
<li>​    i+=1</li>
<li>return</li>
</ol>
<h3 id="Large-scale-ML"><a href="#Large-scale-ML" class="headerlink" title="Large-scale ML"></a>Large-scale ML</h3><script type="math/tex; mode=display">
(x,y)\sim P</script><p>给定一个数据集$D=\{(x,y)\},\:(x,y)\sim P$，找到</p>
<script type="math/tex; mode=display">
\min R[h_s]:=E[l(h_s(x),y)]</script><p>Empirical Risk Minimizor(ERM) —— Expected Risk Minimizor</p>
<p>对任意小的$\epsilon,\delta$，当n足够大的时候，有</p>
<script type="math/tex; mode=display">
P(|R[h_n]-R[h]|\geq\epsilon)<\delta</script><p>Hoeffding不等式：$X_i$是i.i.d.随机变量，且$E(X_i)=\mu$且$P(a\leq X_i\leq b)=1$，那么对任意$\epsilon&gt;0$</p>
<script type="math/tex; mode=display">
P(|\frac1n\sum_{i=1}^nX_i-\mu|\geq\epsilon)\leq2exp(-\frac{2n\epsilon^2}{(b-a)^2})</script><p>假设对于固定的h，根据Hoeffding不等式</p>
<script type="math/tex; mode=display">
P(|R_n[h]-R[h]|\geq\epsilon)\leq2e^{-2n\epsilon^2}</script><p>得到上界</p>
<script type="math/tex; mode=display">
P(\cup_{h\in H}\{|R_n[h]-R[h]|\geq\epsilon\})\leq2|H|e^{-2n\epsilon^2}</script><p>因此需要样本数量</p>
<script type="math/tex; mode=display">
n\geq\frac1{2\epsilon^2}log(2|H|/\delta)</script><h5 id="VC-dimension"><a href="#VC-dimension" class="headerlink" title="VC dimension"></a>VC dimension</h5><p>VC dimension是集合的集合</p>
<script type="math/tex; mode=display">
H\cap C:=\{h\cap C|h\in H\}</script><p>定义C被H <strong>shattered</strong>，如果$H\cap C=2^C$</p>
<p>H的VC dimension定义为最大的整数D，使得存在|C|=D被H shattered。</p>
<p>一个模型$f$的VC dimension定义为最大的点数可以被$f$ shattered。</p>
<p>根据VC dimension，可以控制泛化误差</p>
<script type="math/tex; mode=display">
\sup_{h\in H}|R_n[h]-R[h]|\leq O(\sqrt{\frac{VC[H]log(n/VC[H])+log(1/\delta)}{n}})</script><h5 id="次梯度方法"><a href="#次梯度方法" class="headerlink" title="次梯度方法"></a>次梯度方法</h5><p><strong>次梯度方法</strong></p>
<script type="math/tex; mode=display">
x_{k+1}=x_k-\alpha_kg_k,g_k\in \partial f(x_k)</script><p>定理1（次梯度的收敛性）：假设存在最小点，且次梯度有界M。那么</p>
<script type="math/tex; mode=display">
\sum_{k=1}^K\alpha_k[f(x_k)-f(x^*)]\leq \frac12||x_1-x^*||_2^2+\frac12\sum_{k=1}^K\alpha_k^2M^2</script><p>推论：令$A=\sum_{i=1}^k\alpha_i$，$\bar{x_K}=\frac{1}{A_K}\sum_{k=1}^K\alpha_kx_k$，那么</p>
<script type="math/tex; mode=display">
f(\bar{x_K})-f(x^*)\leq\frac{||x_1-x^*||_2^2+\sum \alpha_k^2M^2}{2\sum\alpha_k}</script><p><strong>投影次梯度方法</strong></p>
<script type="math/tex; mode=display">
x_{k+1}=\pi_C(x_k-\alpha_kg_k),g_k\in \partial f(x_k)</script><p>定理2（投影次梯度的收敛性）：假设$||x-x^*||_2\leq R&lt;\infty$，且次梯度有界M，那么</p>
<script type="math/tex; mode=display">
\sum_{k=1}^K\alpha_k[f(x_k)-f(x^*)]\leq \frac12||x_1-x^*||_2^2+\frac12\sum_{k=1}^K\alpha_k^2M^2</script><p><strong>随机次梯度方法</strong></p>
<p>问题</p>
<script type="math/tex; mode=display">
\min_{x\in C}f(x):=E_P[F(x;S)]</script><p>S是random space。</p>
<script type="math/tex; mode=display">
x_{k+1}=\pi_C(x_k-\alpha_kg_k),E[g_k|x_k]\in\partial f(x_k)</script><p>定理3（随机次梯度法的收敛性）：假设$||x-x^*||_2\leq R&lt;\infty$，且$E||g(x,S)||_2^2\leq M^2\leq\infty$，那么</p>
<script type="math/tex; mode=display">
\sum_{k=1}^K\alpha_kE[f(x_k)-f(x^*)]\leq \frac12E||x_1-x^*||_2^2+\frac12\sum_{k=1}^K\alpha_k^2M^2</script><p>推论：令$A=\sum_{i=1}^k\alpha_i$，$\bar{x_K}=\frac{1}{A_K}\sum_{k=1}^K\alpha_kx_k$，那么</p>
<script type="math/tex; mode=display">
E[f(\bar{X_K})-f(x^*)]\leq\frac{R^2+\sum \alpha_k^2M^2}{2\sum\alpha_k}</script><p>定理5（随机次梯度法的收敛性2）：$\alpha_k$不增，且定义$\bar{x_K}=\frac1K\sum x_k$，那么</p>
<script type="math/tex; mode=display">
E[f(\bar{X_K})-f(x^*)]\leq\frac{R^2}{2K\alpha_K}+\frac1{2K}\sum \alpha_k^2M^2</script><p>推论：令$\alpha_k=R/M\sqrt{k}$，那么</p>
<script type="math/tex; mode=display">
E[f(\bar{x_K})-f(x^*)]\leq \frac{3RM}{2\sqrt{K}}</script><p>定理6（随机次梯度法的收敛性3—依概率收敛）：在定理5的条件下，假定$||g||_2\leq M$，那么</p>
<script type="math/tex; mode=display">
E[f(\bar{X_K})-f(x^*)]\leq\frac{R^2}{2K\alpha_K}+\frac1{2K}\sum \alpha_k^2M^2+\frac{RM}{\sqrt{K}}\epsilon</script><p>至少以概率$1-e^{-\epsilon^2/2}$的概率成立。</p>
<p>（证明需要用到Azume-Hoeffding不等式）</p>
<p><strong>Adaptive stepsize</strong>—Variable metric methods</p>
<script type="math/tex; mode=display">
x_{k+1}=\arg\min_{x\in C}\{<g_k,x>+\frac12<x-x_k,H_k(x-x_k)>\}</script><ul>
<li>投影法：$H_k=\alpha_kI$ </li>
<li>Newton法：$H_k=\nabla^2f(x_k)$</li>
<li>AdaGrad：$H_k=\frac1\alpha diag(\sum g_{i.} g_i)^{1/2}$</li>
</ul>
<p>定理9（Variable metric method的收敛性）：$H_k&gt;0$为正定矩阵，$E[g_k|x_k]\in\partial f(x_k)$那么</p>
<script type="math/tex; mode=display">
E[\sum_{k=1}^K(f(x_k)-f(x^*))]\leq\frac12E[\sum_{k=2}^K(||x_k-x^*||_{H_k}^2-||x_k-x^*||_{H_{k-1}}^2)]+\frac12E[||x_1-x^*||_{H_1}^2+\sum_{k=1}^K||g_k||_{H_k^{-1}}^2]</script><p>(证明根据$||x_{k+1}-x^*||_{H_k}^2\leq||x_k-H_k^{-1}g_k-x^*||_{H_k}^2$)</p>
<p>推论（AdaGrad的收敛性）：在定理9的条件下，定义$R_\infty=\sup_{x\in C}||x-x^*||_\infty$，那么</p>
<script type="math/tex; mode=display">
E[\sum_{k=1}^K(f(x_k)-f(x^*))]\leq\frac1{2\alpha}R_\infty^2E[tr(M_K)]+\alpha E[tr(M_K)]</script><p>(证明利用$\sum_{k=1}^K\frac{a_k^2}{\sqrt{\sum^k a_i^2}}\leq 2\sqrt{\sum^K a_i^2}$)</p>
<p><u>总结：合适的步长策略可以提升收敛性。</u></p>
<h5 id="随机梯度下降"><a href="#随机梯度下降" class="headerlink" title="随机梯度下降"></a>随机梯度下降</h5><p>收敛性：假设f是L-光滑且$\mu$-强凸的</p>
<p>引理：</p>
<script type="math/tex; mode=display">
<\nabla f(x)-\nabla f(y),x-y>\geq \frac{L\mu}{L+\mu}||x-y||^2+\frac1{L+\mu}||\nabla f(x)-\nabla f(y)||^2</script><p>定理：梯度下降收敛速度：定义$\alpha_k=\frac2{L+\mu}$，$k=L/\mu$，$\Delta_k=||x_k-x^*||$，那么</p>
<script type="math/tex; mode=display">
f(x_{T+1})-f(x^*)\leq \frac{L\Delta_1^2}2exp(-\frac{4T}{k+1})</script><p>定理：随机梯度下降收敛速度：对于固定的步长$\alpha_k=\alpha&lt;\frac1{2\mu}$</p>
<script type="math/tex; mode=display">
E[f(x_{T+1})-f(x^*)]\leq\frac L2E[\Delta_{T+1}^2]\leq\frac L2[(1-2\alpha\mu)^T\Delta_1^2+\frac{\alpha M^2}{2\mu}]</script><p>定理：随机梯度下降收敛速度：对于$\alpha_k=\frac{\beta}{k+\gamma}$</p>
<script type="math/tex; mode=display">
E[f(x_T)-f(x^*)]\leq\frac L2E[\Delta_T^2]\leq\frac L2\frac{v}{\gamma+T}</script><h5 id="Variance-Reduction"><a href="#Variance-Reduction" class="headerlink" title="Variance Reduction"></a>Variance Reduction</h5><p>f(x)是L-光滑和$\mu$-强凸的</p>
<p>GD：</p>
<script type="math/tex; mode=display">
\Delta_{k+1}^2\leq(1-2\alpha\mu+\alpha^2L^2)\Delta_k^2</script><p>SGD:</p>
<script type="math/tex; mode=display">
E\Delta_{k+1}^2\leq (1-2\alpha\mu)E\Delta_k^2+\alpha^2E||\nabla f_{x_k}(x_k)||_2^2\\
\leq (1-2\alpha\mu+2\alpha^2L^2)E\Delta_k^2+2\alpha^2E||\nabla f_{x_k}(x_k)-\nabla f(x_k)||_2^2</script><p>GD和SGD相差在最后一项，因而要控制方差就要控制这一项</p>
<p><strong>SAG method</strong>（Le Roux，Schmidt， Bach，2012）</p>
<script type="math/tex; mode=display">
x_{k+1}=x_k-\frac{\alpha_k}n\sum_{k=1}^ng_k^i=x_k-\alpha_k(\frac1n(\nabla f_{s_k}(x_k)-g_{k-1}^{s_k})+\frac1n\sum_{i=1}^ng_{k-1}^i)</script><p>其中$g_k^i=\nabla f_i(x_k)$如果$i=s_k$，否则$g_k^i=\nabla g_{k-1}^i$。$s_k$是1~n的随机分布。</p>
<p><strong>SAGA method</strong>（Defazio，Bach， Julien，2014）：SAG的无偏改进</p>
<script type="math/tex; mode=display">
x_{k+1}=x_k-\alpha_k(\nabla f_{s_k}(x_k)-g_{k-1}^{s_k}+\frac1n\sum_{i=1}^ng_{k-1}^i)</script><p><strong>SVRG</strong>（Johnson，zhang，2013）</p>
<script type="math/tex; mode=display">
v_k=\nabla f_{s_k}(x_k)-\nabla f_{s_k}(y)+\nabla f(y)\\
x_{k+1}=x_k-\alpha_kv_k</script><p>相比SAG，隔断了$g_k$</p>
<p>定义condition number $k=L/\mu$</p>
<ul>
<li>SVRG：$E\sim log(1/e)$，复杂度$O((n+k)log(1/e))$</li>
<li>GD：$T\sim klog(1/e)$</li>
<li>SGD：$T\sim k/e$</li>
</ul>
<h5 id="DL-中的随机算法"><a href="#DL-中的随机算法" class="headerlink" title="DL 中的随机算法"></a>DL 中的随机算法</h5><script type="math/tex; mode=display">
\min_x\frac1n\sum_{i=1}^nf_i(x)</script><p>GD、SGD、SGD with momentum</p>
<p>Nesterov加速算法（外推算法）</p>
<p>Adagrad、Adadelta</p>
<h3 id="Randomized-Numerical-Linear-Algebra"><a href="#Randomized-Numerical-Linear-Algebra" class="headerlink" title="Randomized Numerical Linear Algebra"></a>Randomized Numerical Linear Algebra</h3><p>provably accurate algorithms for problems that are <strong>massive or computationally expensive</strong></p>
<h5 id="矩阵乘法近似"><a href="#矩阵乘法近似" class="headerlink" title="矩阵乘法近似"></a>矩阵乘法近似</h5><script type="math/tex; mode=display">
AB\approx CR</script><p>SVD分解取前k个特征值</p>
<p>CX分解：最小化A-CX，显然$X=C^-A$ </p>
<h5 id="sampling-rows-columns"><a href="#sampling-rows-columns" class="headerlink" title="sampling rows/columns"></a>sampling rows/columns</h5><script type="math/tex; mode=display">
AB=\sum_{i=1}^nA_iB_i</script><p>设定一系列概率$p_i$，$i=1,2,…,n$，总和为1。然后选取c列（下式左边需要正则化）</p>
<script type="math/tex; mode=display">
AB\approx\frac1c\sum_{j=1}^c\frac1{p_{i_j}}A_{i_j}B_{i_j}</script><p>有/无放回：i.i.d.更容易分析</p>
<p>概率选取</p>
<script type="math/tex; mode=display">
p_i=\frac{||A_i||_2||B_i||_2}{\sum_{j=1}^n||A_j||_2||B_j||_2}</script><p>include $A_j/(cp_j)^{1/2}$ as a column and $B_j/(cp_j)^{1/2}$ as a row，此时CR也可以表示为</p>
<script type="math/tex; mode=display">
CR=(AS)(S^TB)</script><p>如此得到F-范数的界限</p>
<script type="math/tex; mode=display">
E||AB-CR||_F\leq\frac1c||A||_F||B||_F</script><p>证明：</p>
<script type="math/tex; mode=display">
E[CR]=AB,\:Var[(CR)_{ij}]=\frac1c\sum_{k=1}^n\frac{A_{ik}^2B_{kj}^2}{p_k}-\frac1c(AB)_{ij}^2</script><p>因此</p>
<script type="math/tex; mode=display">
E||AB-CR||_F^2=\sum_{k=1}^n\frac{|A_k|^2|B_k|^2}{cp_k}-\frac1c||AB||_F^2\\
\leq\frac1c(\sum_{k=1}^n|A_k||B_k|)^2-\frac1c||AB||_F^2\\
\leq\frac1c||A||_F^2||B||_F^2</script><p>在$B=A^T$时，根据Chernoff/Bernstein不等式，当</p>
<script type="math/tex; mode=display">
c=\Omega(\frac{||A||_F^2}{e^2}ln(\frac{||A||_F^2}{e^2\sqrt{\delta}}))</script><p>此时下式成立的概率至少为$1-\delta$</p>
<script type="math/tex; mode=display">
E||AA^T-CC^T||_F\leq e</script><p><strong>Using a dense S</strong></p>
<ul>
<li>Reminiscent of random projections and the Johnson-Lindenstrauss transform</li>
<li>Bounds for the Frobenius norm are similar</li>
<li>need a sufficiently large value c</li>
</ul>
<h5 id="Approximate-SVD"><a href="#Approximate-SVD" class="headerlink" title="Approximate SVD"></a>Approximate SVD</h5><p>Linear Time SVD algorithm:</p>
<ol>
<li>input matrix A</li>
<li>for t = 1 to c，根据概率选择i，设定$C_t=A_i/\sqrt{cp_i}$</li>
<li>计算$C^TC$和它的SVD：$C^TC=\sum \sigma_t(C)^2y_ty_t^T$</li>
<li>计算$h_t=Cy_t/\sigma_t(C)$</li>
</ol>
<p><u>C的左特征向量很大概率近似A的左特征向量</u></p>
<p>之后可以得到近似的k-dominant SVD</p>
<p><strong>主要结论</strong></p>
<script type="math/tex; mode=display">
E[||A-H_kH_k^TA||_F^2]\leq||A-A_k||_F^2+\epsilon||A||_F^2</script><p>矩阵扰动定理（后者为Hoffman-Wielandt不等式）</p>
<script type="math/tex; mode=display">
max|\sigma_t(A+E)-\sigma_t(A)|\leq||E||_2\\
\sum_{k=1}^n(\sigma_k(A+E)-\sigma_k(A))^2\leq||E||_F^2</script><p>引理：</p>
<script type="math/tex; mode=display">
||A-H_kH_k^TA||_F^2\leq||A-A_k||_F^2+2\sqrt{k}||AA^T-CC^T||_F\\
||A-H_kH_k^TA||_2^2\leq||A-A_k||_2^2+2||AA^T-CC^T||_2</script><p>第一个引理由$||X||_F^2=Tr(X^TX)$和Cauchy-Schwartz不等式和Hoffman-Wielandt不等式得到。</p>
<p>根据引理和F-范数的界限得到主要结论</p>
<p><u>CX分解也有相应的方法/结论</u></p>
<p><u>Fewer sampling</u></p>
<h5 id="Random-Sampling-for-SVD"><a href="#Random-Sampling-for-SVD" class="headerlink" title="Random Sampling for SVD"></a>Random Sampling for SVD</h5><p>Range finding problem：找到Q，$A\approx QQ^TA$</p>
<p>input A，draw a random matrix X，Y=AX，</p>
<p>对Y做QR分解，Y=QR</p>
<p>对$Q^TAQ$做SVD分解得到$T^TDT$，那么QT是U的估计。</p>
<h5 id="Single-View-Algorithm-for-Matrix-Approximation"><a href="#Single-View-Algorithm-for-Matrix-Approximation" class="headerlink" title="Single View Algorithm for Matrix Approximation"></a>Single View Algorithm for Matrix Approximation</h5><p>低秩矩阵重建：</p>
<p>given A，given random matrices k列的$\Omega$, l行的$\Phi$，compute</p>
<script type="math/tex; mode=display">
Y=A\Omega,W=\Phi A</script><p>Y=QR，$X=(\Phi Q)^-W$，近似</p>
<script type="math/tex; mode=display">
\hat{A}=QX</script><p>如果k=2r+1,l=4r+2，那么</p>
<script type="math/tex; mode=display">
E||A-\hat{A}||_F\leq2\min_{rank(Z)\leq r}||A-Z||_F</script><p><u>应用到一些问题上避免了对原矩阵A的revisit</u></p>
<p>应用：低秩投影</p>
<p>投影到凸集C上：</p>
<script type="math/tex; mode=display">
\Pi_C(M)=\arg\min_{X\in C}||X-M||_F^2</script><p>Conjugate Symmetric Approximation：凸集$C=H^n=\{X=X^*\}$。此时$\Pi_{H^n}(M)=\frac12(M+M^*)$，所以对A=QX，$[Q,X^*]=U[T_1,T_2]$，那么得到投影</p>
<script type="math/tex; mode=display">
\hat{A_{sym}}=U(\frac12(T_1T_2^*+T_2T_1^*))U^*\triangleq USU^*</script><p>PSD近似：对于半正定矩阵A，特征值分解$S=VDV^*$，计算$\hat{A}_{sym}=(UV)D(UV)^*$，构造</p>
<script type="math/tex; mode=display">
\hat{A_+}=\Pi_{H_+^n}(\hat{A})=(UV)D_+(UV)^*</script><h3 id="相位恢复"><a href="#相位恢复" class="headerlink" title="相位恢复"></a>相位恢复</h3><script type="math/tex; mode=display">
|Ax|=b\in C^m</script><p>即为多元二次方程求根：NP难问题，非凸优化最值问题</p>
<p>应用：物理问题如Xray/天文观察，一般不能观测到辅角</p>
<h5 id="classical-phase-retrieval"><a href="#classical-phase-retrieval" class="headerlink" title="classical phase retrieval"></a>classical phase retrieval</h5><script type="math/tex; mode=display">
find\:x\in S\cap M\\
M:=\{x(r)||\hat{x}(\omega)|=b(\omega)\},\:\hat{x}(\omega)=Fourier(x(r))\\
S:=\{x(r)|x(r)=0\:for\:x\notin D\}</script><p><strong>Error Reduction</strong>：交替投影法</p>
<script type="math/tex; mode=display">
x^{k+1}=P_SP_M(x^k)</script><p>之后有五种变体</p>
<ul>
<li>Basic input-output (BIO)：$x^{k+1}=(P_SP_M+I-P_M)(x^k)$</li>
<li>Hybrid input-output (HIO)：$x^{k+1}=((1+\beta)P_SP_M+I-P_S-\beta P_M)(x^k)$</li>
<li>Hybrid projection reflection (HPR)：$x^{k+1}=((1+\beta)P_{S_+}P_M+I-P_{S_+}-\beta P_M)(x^k)$</li>
<li>Relaxed average alternating reflection (RAAR)：$x^{k+1}=(2\beta P_{S_+}P_M+\beta I-\beta P_{S_+}-(1-2\beta) P_M)(x^k)$</li>
<li>Difference Map(DF)：$x^{k+1}=(I+\beta(P_S((1-\gamma_2)P_M-\gamma_2 I)+P_M((1-\gamma_1)P_S-\gamma_1 I)))(x^k)$</li>
</ul>
<p><u>收敛性难以保证</u></p>
<p><strong>ADMM</strong></p>
<script type="math/tex; mode=display">
find\:x,y\:s.t.x=y,x\in X\:and\:y\in Y</script><p>增广拉格朗日函数</p>
<script type="math/tex; mode=display">
L(x,y,\lambda)=\lambda^T(x-y)+\frac12||x-y||^2</script><p>ADMM与HIO/HPR在一些假设下等价</p>
<h5 id="Discrete-model"><a href="#Discrete-model" class="headerlink" title="Discrete model"></a>Discrete model</h5><script type="math/tex; mode=display">
find\: x\\
s.t.\:|<a_k,x_0>|^2=b_k</script><p>一般情况下NP难</p>
<p><strong>PhaseLift</strong></p>
<p>令$X=xx^*$，那么$b_k=<a_ka_k^\*,X>$，</p>
<script type="math/tex; mode=display">
find\:X\\
s.t.A(X)=b,X\succeq0</script><p>（这里去掉了约束rank(X)=1）</p>
<p>如此回到半定规划问题</p>
<p>Theorem（C and Li 2012，C Strohmer and Voronisnski 2011）</p>
<p>如果$a_k$独立均匀地分布在单位圆上，且个数m&gt;n，那么至少概率为$1-O(e^{-\gamma m})$唯一可行解即是原来的x（即<em>精确恢复</em>）。</p>
<p><strong>PhaseCut</strong></p>
<p>变形为</p>
<script type="math/tex; mode=display">
\min_{x,u}\frac12||Ax-diag(b)u||_2^2=\min_u u^*(diag(b)(I-AA^*)diag(b))u</script><p>是MAXCUT问题</p>
<script type="math/tex; mode=display">
\min_U Tr(UM)</script><h5 id="Phase-retrieval-by-non-convex-optimization"><a href="#Phase-retrieval-by-non-convex-optimization" class="headerlink" title="Phase retrieval by non-convex optimization"></a>Phase retrieval by non-convex optimization</h5><script type="math/tex; mode=display">
\min_z f(z)=\frac1{4m}\sum_{k=1}^m(y_k-|<a_k,z>|^2)^2</script><p>复数求梯度：根据Wirtinger 梯度即$\frac{\partial}{\partial z}=\frac12(\frac{\partial}{\partial x}-i\frac{\partial}{\partial y})$</p>
<script type="math/tex; mode=display">
\nabla f(z)=\frac1m\sum_{k=1}^m(|<a_k,z>|^2-y_k)(a_ka_k^*)z</script><p><u>梯度下降法线性收敛速度要求强凸</u></p>
<p>定义距离</p>
<script type="math/tex; mode=display">
dist(z,x)=\min_\phi||z-e^{i\phi}x||</script><p>Convergence for Gaussian model：</p>
<p>假设sample $m&gt;nlog(n)$，step size $\mu&lt;c/n$</p>
<p>那么以至少$1-10e^{-\gamma n}-8/n^2-me^{-1.5n}$的概率$dist(z_0,x)\leq \frac18||x||$，在$\tau$步迭代之后</p>
<script type="math/tex; mode=display">
dist(z_\tau,x)\leq\frac18(1-\mu/4)^{\tau/2}||x||</script><p>引理1：假设f满足$RC((\alpha,\beta,\epsilon))$ for all $z\in E(\epsilon)$。进一步假设$z_0\in E(\epsilon)$，$0&lt;\mu\leq 2/\beta$，考虑更新</p>
<script type="math/tex; mode=display">
z_{\tau+1}=z_\tau-\mu\nabla f(z_\tau)</script><p>那么所有$z_\tau\in E(\epsilon)$，且</p>
<script type="math/tex; mode=display">
dist^2(z_\tau,x)\leq(1-\frac{2\mu}{\alpha})^\tau dist^2(z_0,x)</script><p>上面f的正则条件$RC((\alpha,\beta,\epsilon))$是说对任意$z\in E(\epsilon)$</p>
<script type="math/tex; mode=display">
Re(<\nabla f(z),z-xe^{i\phi(z)}>)\geq \frac1\alpha dist^2(z,x)+\frac1\beta||\nabla f(z)||^2</script><p>引理2：假设$||x||=1$，又假设$m\geq c(\delta)nlog(n)$ in Gaussian model 或 $L\geq c(\delta)log^3(n)$ in CD model</p>
<script type="math/tex; mode=display">
||\nabla^2f(x)-E\nabla^2f(x)||\leq \delta</script><p>以至少$1-10e^{-\gamma n}-8/n^2$或$1-(2L+1)/n^3$的概率成立。</p>
<p>（需要Local Curvature Condition或者Local smoothness condition）</p>
<p>原式的证明：</p>
<p>根据引理2：</p>
<script type="math/tex; mode=display">
||Y-(xx^*+||x||^2I)||\leq\epsilon=0.001</script><p>设Y的最大的特征值为$\lambda_0$</p>
<script type="math/tex; mode=display">
|\lambda_0-(|\bar{z_0}x|^2+1)|=|\bar{z_0}^*(Y-(xx^*+I))\bar{z_0}|\leq\epsilon</script><p>因此</p>
<script type="math/tex; mode=display">
|\bar{z_0}^*x|^2\geq\lambda_0-1-\epsilon</script><p>同时有</p>
<script type="math/tex; mode=display">
\lambda_0\geq x^*Yx=x^*(Y-(I+x^*x))x+2\geq2-\epsilon</script><p>所以</p>
<script type="math/tex; mode=display">
|\bar{z_0}^*x|^2\geq 1-2\epsilon\Rightarrow dist^2(\bar{z_0},x)\leq2-2\sqrt{1-2\epsilon}</script><h5 id="Gauss-Newton-Method"><a href="#Gauss-Newton-Method" class="headerlink" title="Gauss-Newton Method"></a>Gauss-Newton Method</h5><p>Nonlinear least square problem</p>
<script type="math/tex; mode=display">
\min_z f(z)=\frac1{4m}\sum_{k=1}^m(y_k-|<a_k,z>|^2)^2</script><p>根据Wirtinger导数</p>
<script type="math/tex; mode=display">
z:=\begin{pmatrix}z\\\bar{z}\end{pmatrix}\\
g(z):=\nabla_cf(z)=\frac1m\sum_{r=1}^m(|a_r^Tz|^2-y_r)\begin{pmatrix}(a_ra_r^T)z\\(\bar{a_r}a_r^T)\bar{z}\end{pmatrix}\\
J(z):=\frac1{\sqrt{m}}\begin{pmatrix}|a_1^*z|a_1&|a_2^*z|a_2&...&|a_m^*z|a_m\\|a_1^*z|\bar{a_1}&|a_2^*z|\bar{a_2}&...&|a_m^*z|\bar{a_m}\end{pmatrix}^T\\
\Phi(z):=J(z)^TJ(z)</script><p>modified LM method for Phase Retrieval：Levenberg-Marquardt Iteration</p>
<script type="math/tex; mode=display">
z_{k+1}=z_k-(\Phi(z_k)+\mu_kI)^{-1}g(z_k)</script><p>Convergence of the Gaussian Model：</p>
<p>假设$m\geq cnlog(n)$，如果$f(z_k)\geq\frac{||z_k||^2}{900n}$，$\mu_k=70000n\sqrt{nf(z_k)}$，否则$\mu_k=\sqrt{f(z_k)}$，那么很高的概率</p>
<script type="math/tex; mode=display">
dist(z_{k+1},x)\leq c_1dist(z_k,x)</script><p>当$f(z_s)&lt;\frac{||z_s||^2}{900n}$时</p>
<script type="math/tex; mode=display">
dist(z_{k+1},x)<c_2dist(z_k,x)^2</script><h5 id="Cryo-Electron-Microscopy"><a href="#Cryo-Electron-Microscopy" class="headerlink" title="Cryo-Electron Microscopy"></a>Cryo-Electron Microscopy</h5><p>冷冻光镜问题</p>
<p>傅里叶切片定理</p>
<p>Detection of Common Line of Two photos </p>
<p>—— Weighted Least Square Approach</p>
<script type="math/tex; mode=display">
\min_{R_1,R_2,...,R_K}\sum_{i\neq j}w_{ij}||R_i(c_{ij},0)^T-R_j(c_{ji},o)^T||^2\\
=\max_{R_1,R_2,...,R_K}\sum_{i\neq j}w_{ij}<R_i(c_{ij},0)^T,R_j(c_{ji},0)^T></script><p>半定规划（SDR）</p>
<script type="math/tex; mode=display">
\max trace((W\cdot S)G\\
G=R^TR,\:S_{ij}=c_{ji}^Tc_{ij},\:W_{ij}=w_{ij}\begin{pmatrix}1&1\\1&1\end{pmatrix}</script><p>即要求</p>
<script type="math/tex; mode=display">
G_{ii}=I_2,G\succeq 0</script>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/06/database/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hulieu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hulieu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/06/database/" class="post-title-link" itemprop="url">数据库概论</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-06 21:22:46" itemprop="dateCreated datePublished" datetime="2020-03-06T21:22:46+08:00">2020-03-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-04 16:32:49" itemprop="dateModified" datetime="2020-05-04T16:32:49+08:00">2020-05-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%8C%AB%E7%88%AA%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">猫爪记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%8C%AB%E7%88%AA%E8%AE%B0/Computer-Science/" itemprop="url" rel="index"><span itemprop="name">Computer-Science</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h3><p>关系模型三要素：</p>
<ul>
<li>静态</li>
<li>动态关系</li>
<li>约束</li>
</ul>
<p>关系代数六种基本操作</p>
<ul>
<li>一元操作<ul>
<li>选择$\sigma$</li>
<li>投影$\pi$</li>
<li>重命名$\rho$</li>
</ul>
</li>
<li>多元操作<ul>
<li>并集$\cup$</li>
<li>差集$-$（先排序减少查重次数）</li>
<li>笛卡尔积$\times$</li>
</ul>
</li>
</ul>
<p>其他操作：</p>
<ul>
<li>交运算：虽然可以用差集表示，但底层直接实现</li>
<li>$\theta$连接：笛卡尔积代价很大，所以连接表操作时并非笛卡尔积+选择而是先排序+连接</li>
<li>自然连接：选取相同属性列上取值相等的元组</li>
<li>除操作：满足$q\times s\subseteq r$的最大关系q（可以表示为笛卡尔积+差集，实现是排序）</li>
<li>赋值运算：临时表，不支持递归定义（连接次数和数据相关）</li>
<li>外连接：</li>
<li>聚集函数：五个函数 sum、count、mean、max、mean（-distinct）</li>
<li>分组和聚集函数</li>
<li>广义投影：投影+计算</li>
</ul>
<p>删除/修改操作</p>
<p>空值返回Unknown，计算为false</p>
<p>视图View：虚表，限制数据访问范围，作为基本表和外模式之间的映像；更新原表需要满足列数一样等限制</p>
<p>物化视图：1、频繁使用的；2、固定的</p>
<p>关系代数表达式的等价规则：oracle有约50条等价优化规则</p>
<p>关系代数树：合并投影，投影/选择尽可能移向叶节点</p>
<p>元组关系演算：存在/任意/否</p>
<p><u>元组关系演算与关系代数等价</u></p>
<h3 id="SQL概述"><a href="#SQL概述" class="headerlink" title="SQL概述"></a>SQL概述</h3><ul>
<li>数据操作：SELECT，INSERT，UPDATE，DELETE</li>
<li>数据定义：CREATE，ALTER，DROP</li>
<li>数据控制：GRANT，REVOKE</li>
</ul>
<p><strong>SQL查询和关系模型</strong></p>
<ul>
<li>SQL Parser</li>
<li>Query Optimization and Execution</li>
<li>Relational Operators（基本运算实现）</li>
<li>Files and Access Methods（堆文件、顺序文件、B+树）</li>
<li>Buffer Management（数据库特性的缓存管理）</li>
<li>Disk Space Management（定长纪录、非定长纪录）</li>
</ul>
<p>SQL和关系代数的差别</p>
<ul>
<li>SQL引入排序符号</li>
<li>SQL支持单值集合直接使用</li>
<li>SQL投影默认不去重（去重加distinct），集合默认去重（不去重加All）</li>
<li>SQL支持递归、group by等操作</li>
</ul>
<p>SQL查询语句</p>
<ul>
<li>SELECT子句：支持*、支持四则运算、支持不加FROM实现数值运算</li>
<li>FROM子句</li>
<li>WHERE子句</li>
</ul>
<p>其他语句</p>
<ul>
<li><p>去重distinct</p>
</li>
<li><p>ORDER BY排序</p>
</li>
<li><p>AS重命名（可省略AS）</p>
</li>
<li><p>字符串操作：(not) like “”，</p>
<p><code>%</code>匹配零个或多个，<code>_</code>匹配任意单个字符，<code>escape \</code>转义字符</p>
</li>
</ul>
<p>关系连接</p>
<ul>
<li>连接类型：<code>inner join</code> <code>left outer join</code> <code>right outer join</code> <code>full outer join</code></li>
<li>链接条件：<code>nature</code> <code>on&lt;谓词&gt;</code> `using(A1,A2,..,An)</li>
</ul>
<p><u>写法比较简单，并不标准，执行和集合操作等价</u></p>
<p>集合操作</p>
<p>union/intersect/except</p>
<p><u>集合操作是自动去重的，不去重要加上<code>all</code></u></p>
<p>聚集函数</p>
<p><code>max</code> <code>min</code> <code>avg</code> <code>sum</code> <code>count</code></p>
<p>如果select后有聚集函数，则非聚集函数列必须在<code>group by</code>中出现</p>
<p>分组</p>
<p><code>group by 列名 [having 条件表达式]</code></p>
<p>空值</p>
<p><code>is [not] null</code></p>
<p>空值参与算术运算，结果也为null，逻辑运算为false，聚集函数直接忽略</p>
<p><code>ISNULL(check_expression,replacement)</code>：如果check_expression为空则用replacement替代</p>
<p>嵌套子查询</p>
<ul>
<li>集合成员资格：<code>in</code></li>
<li>集合之间比较：<code>&gt;= all</code> <code>some</code> </li>
<li>集合基数的测试<ul>
<li>测试集合是否为空 <code>[not] exists</code></li>
<li>测试集合是否存在重复元组 <code>unique</code> 没有重复元组则返回true（可用count替代所以并不常用）</li>
</ul>
</li>
</ul>
<p>派生关系</p>
<p><code>AS</code>命名为临时关系 </p>
<p>临时视图</p>
<p><code>with ... as ..., ... as ... select ...</code> </p>
<p><strong>SQL修改功能</strong></p>
<p><code>insert into 表名 [列名] values (...)</code> 插入一条指定好值的元组</p>
<p><code>insert into 表名 [列名] (子查询)</code>插入子查询结果的若干条元组</p>
<p>多行数据的插入可以用union实现</p>
<p><code>delete from 表名 [where 条件表达式]</code></p>
<p><code>truncate table</code>删除表中所有行（比delete快，但不能带条件）</p>
<p><code>update 表名 set 列名=表达式|子查询 [where 条件表达式]</code></p>
<p> ORACLE数据库支持 <code>case</code> <code>when</code>根据条件update</p>
<p>SQL Servert支持用其他表更新某个表的数据（注意可能出现结果不确定的情况）</p>
<p><strong>视图</strong></p>
<p><code>create view view_name [列名] as (查询表达式) [with check option]</code></p>
<p>取消视图<code>drop view view_name</code></p>
<p>用视图更新原表需要满足很多条件，视图更新约束如下</p>
<ul>
<li>有主码</li>
<li>select子句目标列不能包括聚集函数，不能有group by</li>
<li>select子句不能用distinct</li>
<li>不能包括计算出的列</li>
</ul>
<p><strong>事务</strong></p>
<p>大多是数据库中，每个SQL执行成功后自动提交</p>
<p>每个事务包含一个语句</p>
<p>我们可以取消自动提交，使之支持多事务</p>
<p><strong>数据定义语言（DDL）</strong></p>
<p>域定义：</p>
<p>基本表的定义：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名 (</span><br><span class="line">    列名 数据类型 [<span class="keyword">default</span> 缺省值] [<span class="keyword">not</span> <span class="literal">null</span>] </span><br><span class="line">    [, primary <span class="keyword">key</span> (列名)] </span><br><span class="line">    [, <span class="keyword">foreign</span> <span class="keyword">key</span> (列名)] </span><br><span class="line">    [, <span class="keyword">check</span>(约束条件)]</span><br><span class="line">)<span class="string">`</span></span><br></pre></td></tr></table></figure>
<p>修改表的定义</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名</span><br><span class="line">[<span class="keyword">add</span> 子句] 增加新列和约束</span><br><span class="line">[<span class="keyword">drop</span> 子句] 删除列和约束 某些数据库不支持</span><br><span class="line">[<span class="keyword">modify</span> 子句] 修改列定义</span><br></pre></td></tr></table></figure>
<p>删除表 <code>drop table 表名</code></p>
<p>索引的定义</p>
<p><code>create [unique] [clustr] index 索引名 on 表名 (列名[asc/desc])</code></p>
<p>unique：唯一性索引，不允许不同行索引值相同</p>
<p>cluster：聚集索引，影响物理存储位置，一张表只能有一个聚集索引（主要影响区间查询速度）</p>
<p><u>如果是非unique且非cluster的索引可能速度反而更慢</u></p>
<p>删除索引 <code>drop index 索引名</code></p>
<h3 id="高级SQL"><a href="#高级SQL" class="headerlink" title="高级SQL"></a>高级SQL</h3><h4 id="完整性"><a href="#完整性" class="headerlink" title="完整性"></a>完整性</h4><h5 id="域约束："><a href="#域约束：" class="headerlink" title="域约束："></a>域约束：</h5><p><code>create domain 域名 域定义</code></p>
<p>还可以通过<code>constraint value-test check(value &gt; 4)</code>或者更复杂的<code>constraint account-type-test check(value in (&#39;A&#39;, &#39;B&#39;))</code>甚至还可以使用动态check</p>
<h5 id="引用完整性："><a href="#引用完整性：" class="headerlink" title="引用完整性："></a>引用完整性：</h5><p>删除操作根据外码定义方式决定<code>restrict</code> 不能删除 <code>cascade</code>  一起删除 <code>set null</code>设为空值</p>
<h5 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h5><p><code>create assertion 断言名 check 语句</code> ：表明数据库所满足的条件，实现一般性约束。check约束、主码约束、外键约束可以看作其特例。</p>
<p>断言会导致显著的代价。目前数据库一般不支持assertion。</p>
<h4 id="功能增强"><a href="#功能增强" class="headerlink" title="功能增强"></a>功能增强</h4><h5 id="SQL数据分析-递归SQL："><a href="#SQL数据分析-递归SQL：" class="headerlink" title="SQL数据分析/递归SQL："></a>SQL数据分析/递归SQL：</h5><p>扩展<code>Group by</code>按照不同标准聚集—&gt;多维数据分析模型：</p>
<ul>
<li><code>rollup</code>  在指定属性列表的每个前缀上分组聚集的并集（相当于依次<code>group by</code>结果合集）</li>
<li><code>cube</code>：2^n次<code>group by</code>合集</li>
</ul>
<h5 id="支持排序、支持扩展聚集函数"><a href="#支持排序、支持扩展聚集函数" class="headerlink" title="支持排序、支持扩展聚集函数"></a>支持排序、支持扩展聚集函数</h5><p>基本分析句法 <code>&lt;function name&gt; () OVER ([partition by &lt;exp1&gt;] order by &lt;exp2&gt; [ASC|DESC] [NULLS FIRST|NULLS LAST])</code> 其中<code>partition by</code>用以分组，<code>NULL FIRST</code>确定空值的处理</p>
<p>排序函数<code>rank</code> <code>dense_rank</code>具体例子是<code>select student, rank() over (order by marks desc) from ...</code> <u>否则实现需要用连接+count</u></p>
<p>滑动窗口<code>AVG(price) OVER (Order by date ROWS BETWEEN 3 PRECEDING AND 3 FOLLOWING)</code></p>
<p>递归SQL <code>with A as (select ...(初始条件) union all select ... from A where ...)</code> 结束条件是A不再变化，<u>考虑到具体执行方式是分层执行，内层不支持聚集函数</u> </p>
<h5 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h5><p>在SQL 99被引入，机制包括三点</p>
<ul>
<li>E 执行时机：触发动作为insert、delete或者update</li>
<li>C 执行条件</li>
<li>A 完成动作</li>
</ul>
<p><code>create trigger 触发器名字 after|before insert|delete|update [of 列名] on 表名</code></p>
<p><code>referencing old|new table</code> 指定新旧数据</p>
<p>示例</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> overdraft-<span class="keyword">trigger</span> <span class="keyword">AFTER</span> <span class="keyword">UPDATE</span> <span class="keyword">ON</span> <span class="keyword">account</span></span><br><span class="line"><span class="keyword">REFERENCING</span> <span class="keyword">NEW</span> <span class="keyword">ROW</span> <span class="keyword">AS</span> nrow <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span></span><br><span class="line"><span class="keyword">WHEN</span> nrow.balance &lt; <span class="number">0</span></span><br><span class="line"><span class="keyword">BEGIN</span> atomic</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> ...</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>
<p><u>功能强大，对数据库负担也很大</u></p>
<p>可以用于实现数据一致性、维护概要表、完成特定审计、记录关键变化</p>
<p>但是很难被优化、判定触发链终止条件比较复杂</p>
<h5 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h5><p>数据库中的一段程序，执行代码会存储到数据库</p>
<p>适合功能单一、逻辑复杂、相对集中的任务</p>
<p>应用：手机月度账单计算</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> <span class="keyword">Move</span>(</span><br><span class="line">    <span class="keyword">IN</span> oldAddr <span class="built_in">VARCHAR</span>[<span class="number">255</span>],</span><br><span class="line">    <span class="keyword">IN</span> newAddr <span class="built_in">VARCHAR</span>[<span class="number">255</span>]</span><br><span class="line">)</span><br><span class="line"><span class="keyword">UPDATE</span> MovieStar</span><br><span class="line"><span class="keyword">SET</span> address = newAddr</span><br><span class="line"><span class="keyword">WHERE</span> address = oldAddr;</span><br></pre></td></tr></table></figure>
<p>使用方式<code>CALL Move(&quot;old&quot;, &quot;new&quot;)</code></p>
<p>安全性+性能+可维护性</p>
<h5 id="嵌入式SQL"><a href="#嵌入式SQL" class="headerlink" title="嵌入式SQL"></a>嵌入式SQL</h5><p>SQL提供的预编译器将SQL语句预编译为C语句</p>
<p>如果返回只有一条记录可以用<code>select ... into ...</code></p>
<p>返回多个记录用<u>游标</u>（相当于迭代器）<code>fetch</code></p>
<p>游标分为滚动游标（可以取任意元组）、非滚动游标（只能顺序取下一个元组）、更新游标（增加更新锁）</p>
<p>使用游标需要先声明，再打开，然后检索。之后需要关闭和释放。</p>
<p><code>declare 游标名[scroll] cursor for select ... [for update]</code></p>
<p><code>open</code>  <code>fetch ... from 游标名</code> <code>close</code> <code>free</code></p>
<p>通过游标更新<code>update ... where current of 游标名</code></p>
<h5 id="SQL模块化"><a href="#SQL模块化" class="headerlink" title="SQL模块化"></a>SQL模块化</h5><p>ODBC（Open Database Connectivity）标准：微软提出的应用程序和数据库交互的标准</p>
<p>JDBC基于ODBC+跨平台</p>
<p>好处：易实用，易移植，不需要预编译</p>
<p>缺点：动态绑定，执行效率低，运行时检查SQL语法</p>
<h5 id="图数据查询"><a href="#图数据查询" class="headerlink" title="图数据查询"></a>图数据查询</h5><p>创建点<code>CREATE TABLE 表名 (...) AS NODE;</code></p>
<p>创建边<code>CREATE TABLE 表名 (...) AS EDGE;</code></p>
<p>查询：<code>... WHERE MATCH (点名-(边名)-&gt;点名[-...-&gt;...])</code></p>
<h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><p>防止不合法使用造成的数据<em>泄露</em>和<em>破坏</em></p>
<h5 id="安全性控制"><a href="#安全性控制" class="headerlink" title="安全性控制"></a>安全性控制</h5><p>DBA</p>
<p>完备的策略是收回用户权限的时候，删除用户给出的权限和<u>不是从管理员出发的给这用户的权限</u>。</p>
<p>每一个权限应该形成从管理员出发的完整的权限链</p>
<p>授权命令<code>GRANT 表级权限 ON 表名|视图名 TO 用户 [WITH GRANT OPTION]</code></p>
<p>表级权限包括select,update,…,以及 all。select和update可以指定列名</p>
<p><code>with grant option</code>表示用户可以再把权限授予其他用户</p>
<p>收回权限 <code>REVOKE</code> 用法和授权一样</p>
<p>GRANTh和REVOKE权限不能细化到某个元组，但是可以通过<u>和视图结合支持元组级别授权</u></p>
<p>基于<u>角色</u>的安全访问控制：<code>CREATE ROLE 角色名</code> <code>GRANT 角色名 TO 用户</code></p>
<h5 id="自主访问控制"><a href="#自主访问控制" class="headerlink" title="自主访问控制"></a>自主访问控制</h5><p>DAC：基于用户-对象权限访问矩阵和授权机制</p>
<p>桔皮书C1级别</p>
<h5 id="强制访问控制"><a href="#强制访问控制" class="headerlink" title="强制访问控制"></a>强制访问控制</h5><p>MAC：每一个数据库对象有安全级别，用户也有安全级别</p>
<p>桔皮书B1级别</p>
<p>两条规则：</p>
<ul>
<li><p>主体级别&gt;=客体 才能读</p>
</li>
<li><p>主体=客体 才能写</p>
</li>
</ul>
<p>修正规则：</p>
<ul>
<li>主体级别 &lt;= 客体 才能写</li>
<li>用户可以为写入数据对象赋予高于自己的级别</li>
</ul>
<p>共同点</p>
<ul>
<li>禁止高级别主体更新低级别数据</li>
<li>禁止低级别主体查询高级别数据</li>
</ul>
<p><u>Multilevel Relation</u>：每个数据用标签表明写入的级别（可以有相同主码）</p>
<h5 id="审计"><a href="#审计" class="headerlink" title="审计"></a>审计</h5><p>DBA事前，审计事后</p>
<p>审计权限在DBA之外</p>
<h5 id="SQL注入攻击"><a href="#SQL注入攻击" class="headerlink" title="SQL注入攻击"></a>SQL注入攻击</h5><p>例1</p>
<p>在username输入<code>&#39;;DROP TABLE USERS; --</code></p>
<p>那么后台验证时执行 </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">password</span> <span class="keyword">FROM</span> <span class="keyword">USERS</span> <span class="keyword">WHERE</span> username <span class="keyword">IS</span> <span class="string">''</span>;<span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">USERS</span>; <span class="comment">--'</span></span><br></pre></td></tr></table></figure>
<p>(<code>--</code>是SQL注释符号，保证语句正确性)</p>
<p>例2</p>
<p>在参数输入 <code>0 OR 1=1</code> 获得更多数据</p>
<p>其他</p>
<ul>
<li>通过特殊函数，使得服务器反馈详细信息，如版本和补丁信息</li>
<li>分析反馈错误信息，获取模式信息，例如 <code>union select top 1 name from sysobjects</code>报错将’admin’转换为int时失败</li>
</ul>
<p>解决方法</p>
<ul>
<li>动态绑定SQL语句：应用程序+后台数据，将输入作为参数接收</li>
<li>验证所有的输入：验证输入有效性，防止注释符号等</li>
<li>设置合理权限</li>
</ul>
<h3 id="实体关系模型"><a href="#实体关系模型" class="headerlink" title="实体关系模型"></a>实体关系模型</h3><p>标准Entity-Relationship图</p>
<p>E-R图：用以交流，需要表达</p>
<ul>
<li>实体（方形）</li>
<li>关系（菱形）</li>
<li>属性（椭圆）</li>
<li>多值属性（双椭圆）</li>
<li>派生属性（虚椭圆）</li>
<li>码（主码）</li>
<li>参与（单线）/完全参与（双线）</li>
<li>多对一/一对一（箭头）：此时不一定需要关系表</li>
</ul>
<p>扩展属性（<em>微妙</em>）</p>
<ul>
<li>存在依赖（一个实体存在依赖于另一个实体）</li>
<li>弱实体集（实体自身的属性不足以区分自己）（双长方形，需要以双菱形标识联系）</li>
<li>父类-子类（标记为ISA三角形）<ul>
<li>成员资格由条件定义/用户定义</li>
<li>子类不相交/有重叠</li>
</ul>
</li>
</ul>
<p>E-R图转换为表关系</p>
<ul>
<li>一般情况：属性对应多列</li>
<li>复合属性：不支持</li>
<li>多值属性：新的关系表</li>
<li><p>一对一联系：</p>
<ul>
<li>均部分参与：定义为新的关系</li>
<li>一方全部参与：作为一列，省略关系表</li>
</ul>
</li>
<li><p>一对多：作为列</p>
</li>
<li>多对多：关系表</li>
<li>弱实体：加入依赖强实体的码</li>
<li>ISA：三表方案/两表方案</li>
</ul>
<p><strong>E-R模型的设计</strong></p>
<ol>
<li>需求分析</li>
<li>确定局部结构范围</li>
<li>实体定义</li>
<li>联系定义</li>
<li>属性分配</li>
<li>局部E-R设计</li>
</ol>
<p>…之后…</p>
<ol>
<li>局部E-R图</li>
<li>确定公共实体类型</li>
<li>合并局部E-R</li>
<li>检查并消除冲突（属性冲突、命名冲突、结构冲突）</li>
<li>全局E-R优化</li>
</ol>
<p>工具：PowerDesigner</p>
<h3 id="关系数据库设计"><a href="#关系数据库设计" class="headerlink" title="关系数据库设计"></a>关系数据库设计</h3><ol>
<li>需求分析</li>
<li>概要设计（E-R图）</li>
<li>逻辑设计（DBMS模型）</li>
<li><strong>模式细化</strong>（规范化操作/逆规范化）</li>
<li>物理设计</li>
<li>安全设计</li>
</ol>
<p>不良设计—&gt;范式—&gt;模式分解—&gt;去范式的模式设计</p>
<h5 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h5><p>问题：数据冗余、插入/删除异常（限制信息表达能力）</p>
<p>问题本质是<strong>函数依赖</strong>：对客观世界的提炼（而非根据数据得出）</p>
<p>函数依赖分类</p>
<ul>
<li>平凡依赖：$Y\subset X$，$X\to Y$显然成立</li>
<li>完全/部分依赖：是否存在X的子集$X’$，$X’\to Y$</li>
<li>传递函数依赖：$X\to Y$，$Y\to Z$，且X不依赖于Y，$(X\cup Y)\cap Z=null$，称Z对X传递函数依赖。</li>
</ul>
<p><u>SQL没用提供函数依赖的支持，但是可以通过断言实现</u></p>
<p><strong>多值依赖</strong>：</p>
<p>关系U=(X,Y,Z)，给定(x,z)，有一组y，这组y仅仅取决于x而与z无关，此时y、z都是多值依赖于x（具有对称性），如果z是空集，则为平凡的多值依赖。函数依赖是多值依赖的特例。</p>
<p>多值依赖的有效性与属性集范围有关（增加属性不一定成立，而减少属性一定成立）</p>
<p>这是1NF范式的要求导致的</p>
<p><strong>码的术语</strong>：</p>
<ul>
<li>属性K决定关系U，称K为<strong>超码</strong></li>
<li>U完全依赖于K，称K为<strong>候选码</strong></li>
<li>候选码中选一个作为<strong>主码</strong></li>
<li>包括在任一候选码中的属性称为<strong>主属性</strong></li>
<li>关系模式的码由整个属性组成，称为<strong>全码</strong>，（此时不存在非平凡的函数依赖）</li>
</ul>
<h5 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h5><ul>
<li>1NF：元素不可再分（考虑查询代价）</li>
<li>2NF：非主属性完全依赖于码（考虑数据冗余及插入/删除异常）</li>
<li>3NF：不存在非主属性对码<em>传递依赖</em>（同上）</li>
<li>BCNF：不存在主属性对码的依赖</li>
<li>4NF：不存在对码的多值依赖（主要是冗余）</li>
<li>5NF</li>
</ul>
<p>一般3NF/BCNF综合收益最高</p>
<script type="math/tex; mode=display">
BCNF\subset 3NF\subset 2NF</script><p>模式分解</p>
<p>模式分解的要求</p>
<ul>
<li>无损</li>
<li>保持依赖</li>
<li>无冗余</li>
</ul>
<h5 id="Armstrong公理系统"><a href="#Armstrong公理系统" class="headerlink" title="Armstrong公理系统"></a>Armstrong公理系统</h5><p>正确的、完备的推理规则集</p>
<p>Armstrong公理：</p>
<ul>
<li>自反律：$Y\subset X\Rightarrow X\to Y$</li>
<li>增广律：$X\to Y\Rightarrow XZ\to YZ$</li>
<li>传递性</li>
</ul>
<p>根据公理导出的规则</p>
<ul>
<li>合并律：$X\to Y,\:X\to Z\Rightarrow X\to YZ$</li>
<li>分解律：上式反向</li>
<li>伪传递率：$X\to Y,\: YW\to Z\Rightarrow XW\to Z$</li>
</ul>
<p><u>闭包的概念</u></p>
<h5 id="候选码的计算"><a href="#候选码的计算" class="headerlink" title="候选码的计算"></a>候选码的计算</h5><p>考察属性出现在依赖F左边还是右边</p>
<p>启发式规则</p>
<ul>
<li>左部属性必是主属性</li>
<li>右部属性必是非主属性</li>
<li>外部属性必是主属性</li>
</ul>
<h5 id="模式分解相关算法"><a href="#模式分解相关算法" class="headerlink" title="模式分解相关算法"></a>模式分解相关算法</h5><p><strong>正则覆盖</strong>：没有冗余依赖的等价依赖集合</p>
<p><strong>无损连接分解定理</strong>：分解$\rho=\{R_1,R_2\}$是无损连接分解的条件是$R_1\cap R_2\to R_1-R_2$或者$R_1\cap R_2\to R_2-R_1$</p>
<p><strong>函数依赖保持</strong>：分解之后不需要连接表也可以验证函数依赖</p>
<p><strong>BCNF分解算法</strong></p>
<p>如果模式$R_i$不属于BCNF，那么找到$R_i$上的非平凡函数依赖$\alpha\to\beta$使得$\alpha\to R_i$不属于$F^+$（即$\alpha$不是码），那么将$R_i$分解为$R_i-\beta$和$(\alpha,\beta)$</p>
<p><strong>3NF分解算法</strong></p>
<p>正则覆盖的每个依赖是一张表</p>
<p>如果没有模式包含R的候选码，则再加一张表</p>
<p><u>3NF分解是函数依赖保持的</u></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/05/KMT-History/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hulieu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hulieu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/05/KMT-History/" class="post-title-link" itemprop="url">国民党党员、党章与组织制定</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-05 23:53:33" itemprop="dateCreated datePublished" datetime="2020-03-05T23:53:33+08:00">2020-03-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-08 18:38:37" itemprop="dateModified" datetime="2020-03-08T18:38:37+08:00">2020-03-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%96%B5%E5%90%8E%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">喵后记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="国民党的改组"><a href="#国民党的改组" class="headerlink" title="国民党的改组"></a>国民党的改组</h2><p>国民党改组效仿苏共的组织制度，特别是注重发展群众。国民党基本照抄了苏共党章纪律，而中共的纪律更加严格。</p>
<p>国民党改组之后修改的党章改用通俗的白话文，虽然孙文本人对此不太认同，但是默认了以之在基层发展党员。</p>
<p>国民党党员的组成成分在广东一地以工农为主，而纵观全国，则大多是青年知识分子，特别是中小知识分子。他们热切的想要参与政治，也有想要谋个工作的含义。吸引力远超共产党，青年视共产党为洪水猛兽。</p>
<p>1923年前后国民党改组前党员20万，国内仅5万，群众基础薄弱。26年统计党员达到54.4万，且其中82%为国内党员，27年初党员人数应在百万以上。</p>
<p>但是国民党组织结构松散，在四一二清党之后，蒋、胡都认识到了这一点。国民党重视上层，忽视基层，就连广州亦是如此。基层经费不足，只能任由豪绅包办，或者豪绅直接伪装加入国民党把持党部。国民党来者不拒，导致党员滥化。一些人利用党籍作为升职工具或者争夺地方权力。这远非孙文所愿。</p>
<h2 id="国共合作"><a href="#国共合作" class="headerlink" title="国共合作"></a>国共合作</h2><p>关于“容共”，共产党明确是“合作”关系（强调自身独立性），而过国民党方面只是孙中山表明“容共”立场，认为中共是国际组织，与国民党不矛盾，打消党内顽固派的顾虑。</p>
<p>24年8月国民党中央全会上，瞿秋白与鲍罗廷与会，会议设立国民党下属国际联络委员会，协调两党问题，导致上海中共中央震怒。25年秋冬间，瞿秋白首次提出“联共”的说法，26年3月出现在中共中央正式文件中，在此前后国民党正式承认合作关系。26年5月二中全会设立5+3人的两党联席会议，国民党承认联共，这是蒋、鲍妥协的结果。</p>
<p>实际上，在青年中共产主义还是很有吸引力的，乃至孙中山要声称三民主义就是社会主义。</p>
<p>中共对于两党合作的态度是居高临下的“扶持”“诱导”“掖进”。</p>
<p>中共这时期的《向导》面向底层，但因为底层文化程度且不是免费的，实则面向了非底层。</p>
<p>即使如此，中共保持了其独立性，而国民党反而缺失机关刊物。国民党在宣传方面自愧不如，就连北伐时期的“三大政策”“国民革命”也源自中共。除此之外，中共提出的“打倒帝国主义”“打倒军阀”也深入民心。甚至在中共的影响下，国民党青年也相信宁左勿右，以右派为耻。四一二之后，蒋介石就明令禁止使用这些中共的怪词语。</p>
<p>虽然国共的骨干都是中小知识分子，但国民党向上层，共产党向下层。</p>
<p>26年1月国民党二大召开前后，国共实力已经逆转，特别是共产党对国民党地方组织控制更深入。</p>
<p>1924年5月中共中央执委会扩大会议之后，中共逐渐改变策略，开始注意在国民党内部发展组织力量，此事也引起国民党高层注意。对此陈独秀并不否认，还表示“在国民党内成立一个左派，只算是进步，不是破坏”。26年国民党二大以决议的形式限制国民党员转党。25年1月中共四大决定除了工作需要，共产党员不应当加入国民党。事实上，此前中共党员仅有950人，而在26年4月之后一年增加了4.5万。26年5月，蒋介石要求共产党提供党员名单，但中共没有提交。国共两党主客易位在两党合作末期已成为共识，这一事件的根源在孙中山想要创立列宁主义的严密政党而又能包容另一列宁主义政党时就已经注定。</p>
<h2 id="四一二"><a href="#四一二" class="headerlink" title="四一二"></a>四一二</h2><p>四一二对国共两党都是重大打击。中共六大统计，27年4月至28年上半年清党杀害31万人，其中共产党员2万余人，中共党员从5.7万减少到1万余人。清党前国民党党员总数在100万以上，29年10月统计总数降至65万（考虑新加入的投机分子等，实际清洗、脱党可能不止35万）。</p>
<p>关于清党到底逮捕、杀害了多少人，分歧很大，大约在10万人以上。但可以肯定的是，被捕被杀的人数远超中共党员人数。</p>
<p>“逆淘汰”——左派青年被清洗，下层工农阶级脱党 </p>
<p>“组织瘫痪”——国民党地方党务原多由共党包办，原共党控制的省市党部职位成为权力斗争的目标。而基层组织遭到土豪劣绅侵夺。</p>
<p>清党之后，党务人才奇缺，地方上听任豪绅和投机分子侵夺资源，上层只能依赖武力来弥补党力虚脱。</p>
<h2 id="执政党"><a href="#执政党" class="headerlink" title="执政党"></a>执政党</h2><p>27年国民党执掌全国政权以后，与工农民众割裂开来。28年2月撤销农、工、商、青年、妇女五部，对民众运动加以限制。</p>
<p>原来上层国民党-中层共产党-下层民众的结构打破后，民众团体成为国民党的装饰物。比如农会，主要成分从佃农转为“有农地者”以及“习农业者”等。究其原因主要是对民众运动的恐惧、认为民众运动是共党产物。</p>
<p>清党之后，国民党分为两派，对待民众运动的态度截然不同，分别为胡汉民为首的元老派，汪精卫陈公博为首的改组派，蒋先生立于其间。</p>
<p>实则在孙中山的思想里，人分先知先觉和后知后觉的，他并不赞同国民党以工农为基础。改组派提出国民党应以工农为基础，蒋先生则认为所有被压迫的人都是（全民都被帝国主义压迫），但是造成了“两不讨好”的局面，比如《工厂法》在劳资双方都有意见。国民党成为执政党之后抛弃了工农联盟，却也没能赢得资本阶级的支持。</p>
<p>事实上，国民党与资本家阶级一直存在着矛盾。1932-1933期间，由三友实业的劳资纠纷，转变为上海整个劳资两大阵营的正面冲突，上海绝大多数工会都卷入其中。这其中也有资方与国民党中央的较量，引起南京党部28年以来首次对资本家阶级大张挞伐的“卅电”，但政治强权依旧未能把资方压服。资方在法律上完全失败，1932年上海地方法院驳回上诉，1933年1月最高法院再次驳回。但资方仍旧拖延不履行判决，上海当局也显得软弱，最后1933年12月在杜月笙调停下以资方支付解雇金、工人放弃复工告终。</p>
<p>可以看到，一则国民党的统治力比较有限，二则国民党太想讨好所有的人民了，最后反而都不能讨好。</p>
<h2 id="党治"><a href="#党治" class="headerlink" title="党治"></a>党治</h2><p>国民党清党之后，党力实则弱化，而党统在派系斗争中 濒于破裂。法理上的“以党治国”演变为“以军治国”。</p>
<p>在孙中山设想中，训政只维持6年，然后进入宪政。1929年6月国民党三届二中全会也如此决议。但到了1935年并未结束训政。</p>
<p><strong>中政会：</strong>国民党自上而下设立了党政互动的双轨统治机构，党治的重点放在中央一级，孙中山1924年7月效仿俄共中央政治局设立中政会就是此意。</p>
<p>国民党改组后的最高权力机关是中央执行委员会。鉴于40余人的中执会难以对复杂多变的局势作出反应，孙中山提出党政军分离，先后设立政治委员会、军事委员会，这两个委员会名义上式中执会的下属机构。孙中山在世时，三个组织都听命于他，实际是党魁独裁制。中政会同时受总理和中执会节制，孙去世之后，中政会地位明显提高。26年国民党推选汪精卫、胡汉民、蒋介石为中政会委员，27年3月鉴于中政会有受蒋介石挟持的嫌疑，对中政会职权进行了限制。国民党实施训政之后，28年10月决议中政会集立法、决策、人事大权于一体。</p>
<p>后来中政会人数从十数人开始逐渐膨胀，30年代中政会有多达200余人，中政会逐渐变得没有实权。中政会衰落之后，中常会（中执会常委会）就更无足轻重。</p>
<p><strong>兼任：</strong>除了中政会之外，另一条党治通道是中央领导人兼任政军要职来控制政府和军队。主席、委员、五院院长、各部部长都是中央委员兼任。1936年统计，13名最显赫的党政要人兼任了165个职位，蒋介石本人兼任24个。</p>
<p>国民党中央党政军角色高度重叠，实则“法无定规，权从人转”，比如国家主席一职在林森和蒋介石出任前后的变化。国民党法理上最高的中央委员会也日趋没落。</p>
<p>中常会中执会的衰落本质是党权被侵蚀，主要是军权。胡汉民曾试图以党权抗争军权，宁汉之争便是如此。大体上27-31是两权相争，之后则是军权扼制党权。军政党的顺序从中央贯穿到地方。</p>
<p><strong>重军轻党：</strong>蒋介石推崇军人，以及军队的组织纪律，主张政治军事化、党务军事化，甚至社会军事化。政治上设立“行政督察专员”推进剿共，社会上推行保甲制度和新生活运动。KMT执政后，军人党员迅速膨胀（从1929年30w到1937年101万），而普通党员增长缓慢。</p>
<p><strong>双轨制：</strong>国民党推行中央实行党治领导行政，而地方上是党政双轨，行政领导党治。只在地方实力派控制的地区才有党政高度重合的现象。蒋介石等认为地方党治干预行政是“党乱”，胡汉民指出地方党组织是<strong>辅助</strong>政府行政，沟通政府和人民的。这也导致了地方上党治权威的降低，称为地方政府的附庸。</p>
<p><strong>党政冲突</strong>：地方党政冲突是KMT两大顽疾之一，一些地方甚至从文斗升级为武斗。党务人员薪俸较低，在30年代之后党部失势，地方党权低落，制约了KMT党治在基层的运作。</p>
<p><strong>以党治国：</strong>孙中山主张“党义治国”而非“党员治国”，但其后国民党并没很好遵循这一点。但1926年蒋介石建立南京政府前后，就谈到以党治国是根据党的主义指定政治方案，交给政府去实行，而不是直接施政。党籍并不是入仕的必要条件，中央政府机关中国民党党员的比例在1929年为36%，1933年降至22%，1939年又升到45%<em>（此处还需考虑后加入党的？）</em>。这一比例远远称不上独裁。南京上海的政府机关公务员中党员仅占10%-17%。27年以后KMT形式上执掌政权，但并不具备高度党治的实力。29年仅27万党员，37年也不过52万。29年南京政府控制8%国土和20%人口，到37年控制25%地区和66%人口，但是政权组织职能局限于上层和城市，党治实际控制有限。</p>
<p>政府在党外主要吸纳两部分人，一是北洋旧官僚（国民党内元老派包括蒋先生认为年轻党员“幼稚”，因而不让地方党部干预行政，当时有“南京政府，北京内阁”之说），二是专家知识分子。</p>
<h1 id="派系"><a href="#派系" class="headerlink" title="派系"></a>派系</h1><p>北伐时期胡汉民提出“党外无党，党内无派”，这一理念使得派系政治朝两个方面发展，一是争夺党的正统，二是派系斗争隐蔽化。</p>
<p><strong>1925~1931年继承权之争和“党统”之争</strong>：</p>
<p>27年“四一二”之前四次分裂</p>
<ul>
<li>25年8月廖仲恺被刺，胡汉民和汪精卫分裂</li>
<li>25年11月西山会议派另立中央</li>
<li>26年3月中山舰，蒋汪分裂</li>
<li>27年“四一二”宁汉分裂</li>
</ul>
<p>之后各派在“反共”问题上取得一致，但派系斗争激化。党内左右两派依然存在，蒋介石力图以武力树立正统地位，引发左右两派和地方军事集团的不满。</p>
<p>1931年2月“汤山事件”结束了蒋胡合作的局面。</p>
<p>右派（西山会议派）结构松散，28年之后实际失势；左派（改组派）声威虽猛，只有28-30年两年组织生命。</p>
<p><strong>1932~1937年次生派系斗争</strong>：</p>
<p>外部：“福建事变”和“两广事变”</p>
<p>内部：CC系、力行系和政学系</p>
<p>政学系是少数高层的松散组织。</p>
<p>CC系（“Center Club”）一方面控制党机器而使党派系化，一方面又有独立组织系统。33年-49年间KMT基本由CC系掌控。二陈一直否认CC系的存在，但是1933年初二陈在蒋授意下组织过“青白团”，顶层为“青白团”，中层为“中国国民党忠实党员同盟会”，下层是众多活动集社（上海“干社”，平津“诚社”，江苏“励进社”等）和外围团体（中国文化建设协会等）。强调蒋为唯一领袖的绝对集权制。“忠实党员同盟会”主要寄附各级党组织，活动对内秘密，对外以KMT招牌进行。只有纵向关系，下层甚至不知道上层组织的存在。</p>
<p>力行系是“派系党化”的“党中之党”，力图建立新的党组织改造KMT。32年“力行社”在蒋介石的亲自主持下成立，一度成为国家最高决策机构，32年下半年开始逐渐成为一个纯粹的决策执行组织。有三层组织，顶层为“三民主义力行社”约300人，第二层为“革命军人同志会”（人数不明）和“革命青年同志会”约3万人，第三层为“中华复兴社”约10-50万。战前力行社规模与KMT相当，两部分成员并非是重叠的。力行社也被外界误传为“蓝衣社”，常被视作一个新党。</p>
<p>CC系和力行社都强调蒋的绝对权威，采取集权主义体质和秘密组织系统，鼓吹法西斯主义，附设有庞大的特务机关。两者均在1938年3月KMT全国代表大会后宣布取消。</p>
<p>CC系和力行社关系日趋紧张，1934年蒋做出大致分工，CC系致力于党，力行社致力于军，但是两派之间的斗争一直持续，1938年后以党团队里的形式延续。</p>
<p><strong>1938~1949年拥蒋派系斗争</strong>：</p>
<p>党团之争、CC系和政学系</p>
<h1 id="党员"><a href="#党员" class="headerlink" title="党员"></a>党员</h1><p>KMT普通党员增长缓慢</p>
<p>党员与人口比例更低</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>政党</th>
<th>党员/人口</th>
</tr>
</thead>
<tbody>
<tr>
<td>KMT（1935）（包括61%军队）</td>
<td>1:300</td>
</tr>
<tr>
<td>苏共（1931）</td>
<td>1:65</td>
</tr>
<tr>
<td>中共（1958）</td>
<td>1:52</td>
</tr>
<tr>
<td>意大利法西斯（1934）</td>
<td>1:25</td>
</tr>
</tbody>
</table>
</div>
<p>1935年，KMT统治中心的江浙党员仅占16.8%，而与南京分庭抗礼的两广党员有1/3，另有1/4名义上奉KMT为正朔的省区党员。所以KMT是组织基础十分脆弱的执政党。</p>
<p>党员增长缓慢，一是党组织涣散，二是民众疏离。</p>
<p>农村无党，基层脆弱，战前KMT组织未能深入县以下。省党部以下组织多数不健全，地方党务有名无实，或完全停顿。</p>
<p>边缘省区如东北省组织活动被张学良抑制，山西阎锡山借学生运动抵制党部，山东韩复榘类似。两广长期分立，自成一系。</p>
<p>战前KMT党员除军人外，主要集中于知识界和政界。KMT执政后，青年学生人数下降，政界党员增加，农工党员比例下降。</p>
<p>KMT党的形象在北伐后两三年间急转直下。众多支持者如胡适、蒋廷黻也在30年后逐渐转变看法。另一方面，蒋介石也公开和私下对KMT进行批评。</p>
<p>“党部机关衙门化、党部委员官僚化、普通党员特殊化”</p>
<h1 id="抗战"><a href="#抗战" class="headerlink" title="抗战"></a>抗战</h1><p>三民主义青年团正式成立于1938年3月底。“党外造党”试图吸引对KMT反感的青年一代，同时想统合党内各派。</p>
<p>蒋对三青团团员以新生力量相期许，将KMT推到尴尬的境地。同时考虑CC系独掌KMT党机器，蒋属意力行社成员承担组建任务。这导致派系争斗，延续为党团之争。</p>
<p>党团双轨制，但三青团组织关系上与KMT日趋疏远，行为和工作上和KMT日趋接近。党团势成水火之时，蒋才强调KMT对三青团的领导地位，但党团斗争持续加剧，直到1947年党团矛盾激化危及KMT时，蒋才下决心把三青团并入KMT。</p>
<p>KMT中央党政一体化，地方上则要求党政互相监督，因而造成地方党政矛盾。战时格局没有改变，但省党部委员多由省主席兼任，省主席又由战区军事首领担任，省级实现了党政军一体化。地方上形成新式军阀，“以军统党”，“以政统党”，地方党部进一步萎缩。地方党部不得干涉地方政府，但协助和监督；地方政府往往加以抵制，党部显得软弱无能，沦为军政附庸。</p>
<p>抗战成立国防最高委员会，蒋以KMT总裁身份兼任委员长，独揽党政军一切大权。</p>
<p>抗战初期，KMT军事溃退，长江下游地区基层组织几乎解体，战前52万普通党员到1939年只余下28万。1939年开始，KMT采取政策大量吸收新党员，抗战胜利时达到264万，军队党员423万。三青团同期124w，中共121w。</p>
<p>KMT的组织扩张和渗透程度也大为强化。1938年要求县设置党部，1939年“新县制”要求乡镇设区党部，保设区分布，甲设党小组，并且恢复了大革命时期的“党团”制度。45年全国至少1/3乡镇和保建立了区党部和区分部。</p>
<p>党员分布中地域向西南转移。职业中政府机关公务员比例急剧上升，但官员不加甄别强制入党也导致旧权力成为党内官僚。党组织对党员质量不问，党员信仰不顾，党籍管理混乱，一味追求数量扩张，大多数党员游离于党组织之外。</p>
<h1 id="战后"><a href="#战后" class="headerlink" title="战后"></a>战后</h1><p>CC系长期把持党政，引起其他派系不满。六大中，以CC系为一方，以三青团、黄埔系、朱家华系、新桂系等为另一方分化为两大阵营，两大阵营相当。新中委中CC系凭借蒋的偏袒再次获得绝对优势，站总数1/4以上。</p>
<p>蒋空前扩增中委名额，意图缓解各派系矛盾，但不仅没能弥合纷争，反而流失党心。“六大”前后，人心涣散。</p>
<p><strong>1944~1947”党政革新运动“</strong>：虽然没有多少具体成果，但也有重要意义。革新集团是一个跨派系的松散结合，最早由一批CC分子聚会清谈，最初矛头指向孔、翁等政学系成员。1944年KMT五届十二中全会，他们形成初步同盟，痛愤KMT无能，甚至对蒋的领导方式不满。蒋虽然也对KMT失望，但无疑接受革新分子的要求，一方面也可能是考虑到三青团造成的困扰。这条战线也有黄埔/三青团参与，因为他们都有强烈的政治诉求且在反共问题上高度一致，这里更像是代际之争。政学系主导了国共谈判，革新分子趁机攻击政学系牺牲党的利益，蒋虽对他们感到不满，但还是勉强同意了中常委任命。1946年革新派在重庆中央党部举行了公开的党政革新座谈会，在党内党外公开革新目标，革新运动扩大为一场波及全党的政治运动。</p>
<p>在革新分子看来，KMT腐败的根源是北伐军事胜利，政治失败，失去了革命性。革新分子认为党和党员脱节、和民众疏离、政权旁落官僚等等。“国民党理论家”叶青归纳党务缺点：1、组织散漫，2、党员腐化，3、工作松懈，4、派别分歧。因而要求党内民主。</p>
<p>革新分子对KMT猛烈批评，一致认为是成败兴亡的关头。在他们看来三民主义仍是最好的主义，KMT只要唤起革命精神就能获得新生。革新运动除了几场清议和刊物外，并无多少实际成果。1946年10月KMT中央形式上发动一次流于形式的党员总清查。但是革新运动批判北伐后的失策、攻击政学系，后遭到蒋的严厉训斥解散。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>弱势独裁党的必然命运</p>
<p>KMT控制只到政治表层，而没有深入社会内部</p>
<p>一党专政+三民主义导致有集权的委员会又有分权的独立机关</p>
<p>党员对派系的忠诚超过了对党的忠诚</p>
<p>军&gt;政&gt;党</p>
<p>特务组织猖狂与其党机器无能有关</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/26/group/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hulieu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hulieu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/26/group/" class="post-title-link" itemprop="url">团团伙伙论</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-26 16:00:15" itemprop="dateCreated datePublished" datetime="2020-02-26T16:00:15+08:00">2020-02-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-20 11:02:47" itemprop="dateModified" datetime="2020-03-20T11:02:47+08:00">2020-03-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%8C%AB%E7%88%AA%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">猫爪记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%8C%AB%E7%88%AA%E8%AE%B0/Mathematics/" itemprop="url" rel="index"><span itemprop="name">Mathematics</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="群论"><a href="#群论" class="headerlink" title="群论"></a>群论</h3><p>集合X的变换$\alpha$的群记为$S_X$（对称群）</p>
<p><u>Cycle notation：可以证明任意变换可以写作不相交的轮换</u></p>
<p>另一种形式是写成交换的形式。</p>
<p>由此可以确定变换的奇偶。可以证明$sgn(\alpha)=(-1)^{n-t}$，t为轮换的个数。显然奇偶变换数量一样。</p>
<p>定义：操作$\mu:G\times G\rightarrow G$，半群$(G,<em>)$定义为G上有结合律的操作$\</em>$。</p>
<p>定义：群是有单位元的半群。</p>
<p>定义：同态$f:G\to H$，$f(ab)=f(a)f(b)$。同构是双射的同态。</p>
<p>定义：子群$S\leq G$。</p>
<p>定义：有限群，order</p>
<p>定义：同态$f$的kernel：$ker\:f={a|f(a)=1}$和image：$im\:f={h|h=f(a)}$</p>
<p>定义：$S\leq G$，右（左）陪集 =St(tS)。显然右陪集不交。</p>
<p>定义：index为右陪集数量，记为[G:S]。（Lagrange：G有限，则[G:S]=|G|/|S|）</p>
<p>循环群$|G|=n$，那么对于每个n的因子d，存在唯一子群$|H|=d$。（因此$n=\sum_{d|n}\phi(d)$。）反之，若对每个d，至多存在一个这样的子群，则G为循环群。</p>
<p>$|ST||S\cap T|=|S||T|$</p>
<p>定义：正规子群$K\lhd G$，如果对任意$g\in G$，$gKg^{-1}=K$。</p>
<p>定义：x的共轭为$for\:some\:a\:,axa^{-1}$</p>
<p>题目：（H.B.Mann)有限群G，子集ST，|S|+|T|&gt;G，那么G=ST。（考察S^{-1}g，必和T有交集）；有限域F的任意元素可以写成平方和。（考察a^2和b-a^2）</p>
<p>定义：$N\lhd G$，商群G/N定义为陪集的集合</p>
<p>定义：交换子$aba^{-1}b^{-1}$，其生成的群为交换子群。交换子群G’是G的正规子群。$H\lhd G$，则$G/H$可交换$\Leftrightarrow G’\leq H$</p>
<p>性质：(P.YFF)交换子群为“长交换子集”的子集。</p>
<p>性质：交换子集不一定等于交换子群，一个例子就是P.J.Cassidy给出的</p>
<script type="math/tex; mode=display">
\pmatrix{1&f(x)&h(x,y)\\
0&1&g(y)\\
0&0&1}</script><p>第一同构定理：同态$f$，$G/(ker\:f)\cong im\:f$</p>
<p>引理：G子群S、T中有一个是正规的，那么ST=TS也是子群</p>
<p>第二同构定理：$N\lhd G$，$T\leq G$，那么$N\cap T\lhd T$且$T/(N\cap T)\cong NT/N$。</p>
<p>第三同构定理：$K\leq H\leq G$，K、H正规，那么$(G/K)/(H/K)\cong G/H$。</p>
<p>Correspondence Theorem：$K\leq T\leq S\leq G$，K正规，那么$T\lhd S\Leftrightarrow T^*\lhd S^*$，且此时$S/T\cong S^*/T^*$。其中$S^*=S/K$。</p>
<p>定理：H，K正规，如果$HK=G$,$H\cap K=1$，那么$G\cong H\times K$。</p>
<p>定理：$A\lhd H$，$B\lhd K$，那么$(H\times K)/(A\times B)\cong(H/A)\times(K/B)$</p>
<p>定义：a的共轭的集合记为$a^G$</p>
<p>定义：群G的中心Z(G)是所有的$\{a|ag=ga\:,\:\forall g\in G\}$</p>
<p>定义：中心化子$C_G(a)=\{x|ax=xa\}$，显然这是个子群。</p>
<script type="math/tex; mode=display">
|a^G|=[G:C_G(a)]</script><p>定义：群H的共轭记为$H^g=gHg^{-1}$</p>
<p>定义：正规化子$N_G(H)=\{a\in G:\:aHa^{-1}=H\}$，显然这是个子群，且$|H\lhd N_G(H)|$。</p>
<p>H的共轭的个数=$[G:\:N_G(H)]$</p>
<p>题目：$H\lhd G$且有质数index，且$C_H(x)&lt;C_G(x)$，那么x在H中共轭的数量和在G中相等。（考虑$G=C_G(x)H$）（在证明A_n单群中多次用到）</p>
<p>引理：$\alpha,\:\beta\in S_n$，那么$\alpha\beta\alpha^{-1}$和$\beta$有相同的结构，即r-cycle数量相等。（证明：$\beta(i)=j,\:\alpha(i)=k,\:\alpha(j)=l$，那么$\alpha\beta\alpha^{-1}(k)=l$）</p>
<p>定理：$\beta$和$\gamma$是共轭当且仅当他们有相同的结构。</p>
<p>定理：order为12 的A4没有order为6的子群</p>
<p>定理：$A_n,\:n\geq 5$是单群。证明如下</p>
<ul>
<li>$A_4$有正规子群{(), (1,2)(3,4), (1,3)(2,4), (1,4)(2,3)}</li>
<li>$A_5$是单群（1、所有3-cycle是共轭的；2、所有不交的交换是共轭的；3、5-cycle构成两个12元的共轭集合；4、|H|=60，但是1+共轭集合都不是60的约数）</li>
<li>如果$H\lhd A_n$，且H中有3-cycle，那么$H=A_n$（首先证明所有3-cycle共轭，然后证明An可由3-cycle生成）</li>
<li>$A_6$是单群（考察$\{\alpha|\alpha(i)=i\}$，与$A_5$同构）</li>
<li>$A_n$是单群（考察$\beta(i)=j$，必有3-cycle与之不交换，所以可以找到$A_6$的同构）</li>
</ul>
<h3 id="一些群表示论定理"><a href="#一些群表示论定理" class="headerlink" title="一些群表示论定理"></a>一些群表示论定理</h3><p>（Cayley）任何一个群G可以被嵌入为$S_G$的子群。如果|G|=n，那么G可以被嵌入$S_n$。（Left translation $L_a(x)=ax$，<strong>$a\to L_a$也被称为G的左正规表示</strong>）</p>
<p>推论：k是一个域，有限群|G|=n，那么G可以被嵌入GL(n,k)。</p>
<p>35</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/21/japanese/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hulieu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hulieu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/21/japanese/" class="post-title-link" itemprop="url">王的日语笔记本</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-21 14:21:39" itemprop="dateCreated datePublished" datetime="2020-02-21T14:21:39+08:00">2020-02-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-20 11:04:55" itemprop="dateModified" datetime="2020-03-20T11:04:55+08:00">2020-03-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%8C%AB%E7%88%AA%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">猫爪记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%8C%AB%E7%88%AA%E8%AE%B0/Language/" itemprop="url" rel="index"><span itemprop="name">Language</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h1><h3 id="单词："><a href="#单词：" class="headerlink" title="单词："></a>单词：</h3><p>学生 がくせい</p>
<p>留学生 りゆうがくせい</p>
<p>教授 きようじゆ</p>
<p>职员しやいん</p>
<p>包 かばん</p>
<p>本子 ノート</p>
<p>伞 かさ</p>
<p>鞋 くつ</p>
<p>报纸 しんぶん</p>
<p>杂志 ざつし</p>
<p>照相机 カメラ</p>
<p>电视机 テレビ</p>
<p>照片 しやしん</p>
<p>礼物 おみやげ</p>
<p>电脑 パソコン</p>
<p>JR ジエーアール</p>
<p>朋友 ともだち</p>
<h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><p>１　いち</p>
<p>２　に</p>
<p>３　さん</p>
<p>４　し／よん</p>
<p>５　ご</p>
<p>６　ろく</p>
<p>７　しち／なな</p>
<p>８　はち</p>
<p>９　く／きゆう</p>
<p>１０　じゆう</p>
<h3 id="亲属"><a href="#亲属" class="headerlink" title="亲属"></a>亲属</h3><p>父亲 おどうさん</p>
<p>母亲 おかあさん</p>
<h3 id="地点"><a href="#地点" class="headerlink" title="地点"></a>地点</h3><p>百货商店 デパート</p>
<p>图书馆 としよかん</p>
<p>宾馆 ホテル</p>
<p>便利店 コンビニ</p>
<h3 id="方位"><a href="#方位" class="headerlink" title="方位"></a>方位</h3><p>上 うえ</p>
<p>下　した</p>
<p>前　まえ　</p>
<p>后　うし</p>
<p>相邻　となり</p>
<p>中　なか</p>
<p>外　そと</p>
<h3 id="动物"><a href="#动物" class="headerlink" title="动物"></a>动物</h3><p>猫 ねこ</p>
<p>狗 いぬ</p>
<h3 id="星期"><a href="#星期" class="headerlink" title="星期"></a>星期</h3><p>周日 日曜日 にちようび</p>
<p>周一 月曜日　げつようび</p>
<p>周二 火曜日　かようび</p>
<p>周三 水曜日　すいようび</p>
<p>周四 木曜日　もくようび</p>
<p>周五 金曜日　きんようび</p>
<p>周六 土曜日　どようび</p>
<h3 id="程度副词"><a href="#程度副词" class="headerlink" title="程度副词"></a>程度副词</h3><p>非常 とても／たいへん</p>
<p>一点儿 すこし／ちよつと</p>
<p>不太 あまり～ません</p>
<p>根本不 ぜんぜん～ません</p>
<h3 id="频率副词"><a href="#频率副词" class="headerlink" title="频率副词"></a>频率副词</h3><p>总是 いつも</p>
<p>经常 よく</p>
<p>偶尔 たまに</p>
<p>有时 時々</p>
<p>不太 あまり～ません</p>
<p>从不 ぜんぜん～ません</p>
<h3 id="连词"><a href="#连词" class="headerlink" title="连词"></a>连词</h3><p>表转折 でも</p>
<p>表转折 けど</p>
<p>表并列 そして</p>
<p>所以 だから</p>
<p>表“正如所料”  やはり（日常可用 やっぱり）</p>
<p>但是 が （连接两个小句）</p>
<h3 id="动词1"><a href="#动词1" class="headerlink" title="动词1"></a>动词1</h3><p>休息 やすみます</p>
<p>工作 はたらきます</p>
<p>开始 はじまります（始まります）</p>
<p>结束 おわります（終わります）</p>
<p>去 いきます</p>
<p>回来　かえり ます（帰ります）</p>
<p>学习 ならいます（習います）</p>
<p>かきます（書きます）</p>
<p>かきます（描きます）</p>
<p>かります（借ります）</p>
<p>かします（貸します）</p>
<h3 id="动词2"><a href="#动词2" class="headerlink" title="动词2"></a>动词2</h3><p>起床  おきます</p>
<p>睡觉 ねます（寝ます）</p>
<p>打（电话） かけます</p>
<h3 id="动词3"><a href="#动词3" class="headerlink" title="动词3"></a>动词3</h3><p>学习 べんきようします（勉強します）</p>
<h3 id="形容词"><a href="#形容词" class="headerlink" title="形容词"></a>形容词</h3><p>简单的 やさしい（易しい）</p>
<p>难的 むずかしい（難しい）</p>
<p>无聊的 つまらない</p>
<p>有趣的 おもしろい（面白い）</p>
<h3 id="词义辨析"><a href="#词义辨析" class="headerlink" title="词义辨析"></a>词义辨析</h3><p>建筑物的家用いえ，指家人用うち</p>
<p>刚刚，离现在很近たつたいま，稍前一点用さつき</p>
<p>お湯（ゆ）指热水，水（みず）仅指凉水</p>
<h3 id="常用句子："><a href="#常用句子：" class="headerlink" title="常用句子："></a>常用句子：</h3><p>你好 こんにちは</p>
<p>对不起 すみません</p>
<p>请 どうそ</p>
<p>请多关照 よろしく（おねがいします）</p>
<p>初次见面 はじめまして</p>
<p>是 そうです（+か 是应答时常用的说法，+ね用于同意对方的提议）</p>
<p>不是 ちがいます</p>
<p>不知道 わかいますん</p>
<p>非常 どうも</p>
<p>感谢 ありがとうございまし</p>
<p>对不起（搭话、提出请求的时候） あのう</p>
<p>表不完全有把握 たしか</p>
<p>表正在思考 ええと</p>
<p>我先走了 お先（さき）に失礼（しつれい）します</p>
<p>欢迎光临 いらつしやいませ</p>
<p>请给我（点餐/购物时的） ～を　ください</p>
<p>那么（接过话题或者中断谈话） じやあ</p>
<p>正合适 ちようど　いいです</p>
<p>转换话题 ところで</p>
<p>花费的钱或时间 かかいますか</p>
<p>赶快（暗示其他动作等一会） とりあえず</p>
<p>没错（口语） ちやんと</p>
<p>大丈夫   だいじょうぶ</p>
<p>根据…不同 ～に　よつて</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>なん+量词+も+肯定形式 表示数量多</p>
<p>だいぶ 强调程度高（变化中）</p>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p>从近到远これ、それ、あれ，修饰名词时要用この、その、あの，三个以上事物不能确定哪一个时用的疑问句どれ、どの</p>
<p>知识场所时用ここ、そこ、あそこ表示位置关系</p>
<p>问人用だれ，问东西用なん，问场所用どこ，问价格用いくら，询问时间なんじ、いつ</p>
<p>问怎么样+名词用 どんな　询问材料（内容）用なんの</p>
<p>も代替は的位子，相当于“也”</p>
<p>と在两个名词中间，表示“和”，共同做某事的对象也用这个</p>
<p>や和と的差异在于と列举所有项目，や只用于许多项目中的两项。</p>
<p>か在名词之间，表示“或者”</p>
<p>ごろ在时间后面，表大概</p>
<p>は可以表对比，此时可以单独使用，也可以加在助词后面构成复合形式</p>
<p>“何”根据后续音节不同，读音不同，基本读音是なに，但在助词の前面和量词前读なん，で前都可以　</p>
<p>よ在句末用来表示提醒，读升调　</p>
<p>~から表示原因</p>
<p>たり表示列举：</p>
<ul>
<li>动词た形改为たり</li>
<li>一类形容词加かつたり(です)</li>
<li>二类形容词/名词加だつたり(です)</li>
</ul>
<p>小句+か表示不确定</p>
<ul>
<li>不包含疑问的疑问句：将动词、一类形容词变为简体形+か　どうか</li>
<li>疑问词小句+か</li>
</ul>
<p>小句（简体形）+と+</p>
<ul>
<li>おもいます 想…</li>
<li>いいます 说…</li>
</ul>
<p>～のです／んです 表示所讲的内容解释情况</p>
<p>～に　ついて 关于…</p>
<h3 id="句法"><a href="#句法" class="headerlink" title="句法"></a>句法</h3><p>——は—— 可以表示 xx是xx，xx在xx</p>
<p>句末+ね 表示征求同意</p>
<p>疑问词+も+动词（否定）表示全面否定</p>
<p>动词+ます／ません</p>
<p>动词+ました／ませんでした（过去时）</p>
<p>表物体存在的两种用法</p>
<ul>
<li>（场所）に（物/人）が　あります／います</li>
<li>（物/人）は（场所）に　あります／います</li>
</ul>
<p>表示动作时间的</p>
<ul>
<li><p>时间+に+动词</p>
</li>
<li><p>时间+から+时间+まで+动词（持续时间）</p>
</li>
<li>表示时间数量的词语和动词一起使用，中间不加に</li>
</ul>
<p>表示移动动词时的用法</p>
<ul>
<li>场所+へ/に+动词 去哪儿</li>
<li>场所+から+动词 从哪来</li>
<li>场所+から+场所+まで+动词 从哪到哪</li>
<li>交通工具+で+动词 </li>
<li>场所+へ+动词（干什么）+に+动词 去哪儿干什么，移动行为目的的动词去掉ます</li>
<li>场所+を+动词 经过哪儿</li>
</ul>
<p>名词（动作的对象）+を+动词，这里读作お</p>
<p>动作的场所、工具、手段、原材料+で+动词</p>
<p>给予东西的表达</p>
<ul>
<li><p>名1（人）+は+名2（人）+に+名3（物）+を+あげます　表示1给2物品3</p>
</li>
<li><p>名1（人）+は+名2（人）+に+名3（物）+を+もらいます　表示1得到2的物品3</p>
</li>
</ul>
<p>あまり+否定形式 表示程度不高</p>
<p>询问对方意见どうですか，询问过去的事情どうでしだか</p>
<p>另一种询问方式いかがですか</p>
<p>名词（主体）+は+名词（对象）+が+わかります／できます 会不会做某事</p>
<p>名词（主体）+は+名词（对象）+が+ほしいです 想要什么</p>
<p>名词（主体）+は+名词（对象）+を+动词+たいです 想要干什么（有时也用が）</p>
<h3 id="动词语法"><a href="#动词语法" class="headerlink" title="动词语法"></a>动词语法</h3><p>三类动词：ます形去掉ます后，最后一个音位于い段的动词绝大部分属于一类；最后一个音位于え段的和少部分位于い段（初级大约15个）的属于第二类；来ます和します结尾的动词属于第三类。</p>
<p><strong>动词て形</strong></p>
<p>一类动词“て形”变换方式是去掉ます加て时，发音会有一些变化。</p>
<p>き变いて或いで，びみに变んで，ちりい变つて，し变して</p>
<p>二类和三类动词的“て形”变换方式是去掉ます直接加て。</p>
<p>动词て形+动词 表示相继发生（也可以用 动词て形+から+动词，但から只能在一个句子里用一次）</p>
<p>动词て形+ください 请某人做某事</p>
<p>动词て形+います 正在进行，或者结果状态（类似于认识、有这样的动词）</p>
<p>动词て形+も+いいます 表示许可</p>
<p>动词て形+は+いけません 表示禁止</p>
<p>（提问方式　～ても　いいですか）</p>
<p>まだ+动词否定 相当于还没有</p>
<p>动词+ましょう表示提议、也可用于回应提议</p>
<p><strong>动词ない形</strong></p>
<p>一类动词“ない形”变换方式是去掉ます最后一个音变相应的あ段音，然后加ない（注意い变成わ）。二、三类动词去掉ます直接加ない。</p>
<p>动词ない形+で+ください 表示否定的命令</p>
<p>动词ない形换成なければ+なりません表示必须</p>
<p>动词ない形换成なくても+いいです表示不作也可以</p>
<p><strong>动词基本形</strong></p>
<p>一类动词的基本形最后发音为う段</p>
<p>二、三类动词基本形为去掉ます加る</p>
<p>名词+は+动词基本形+ことが　できます 询问可能（回答用できます／できません）</p>
<p>名词+は+动词基本形+こと　です 谓语是一种动作时使用</p>
<p>动词基本形+まえに、～　动作发生在另一个动作之前</p>
<p><strong>动词た形</strong></p>
<p>就是动词て形的て改为た，で改为だ</p>
<p>动词た形+ことが　あります 经历过</p>
<p>动词た形+あとで、～　动作发生在另一个动作之后</p>
<p>动词た形+ほうが　いいです 用于两种事物选择（否定用动词ない形）</p>
<p>动词+ましょうか　提议</p>
<p>动词ます形去掉ます加上かた就是“~的方法”的意思。</p>
<p>动词+たり用来列举</p>
<h3 id="形容词语法"><a href="#形容词语法" class="headerlink" title="形容词语法"></a>形容词语法</h3><p>形容词分两类，<strong>一类是以 い结尾</strong>，做谓语要加です</p>
<p>名+は+一类形容词+です</p>
<p>他的否定形式是将词尾的い变成く，再加上ないです或者ありません</p>
<p>过去式是将词尾的い变为かつた，再加です</p>
<p>过去形式的否定式是将词尾的い变成く，再加上ないつたです或者ありませんした</p>
<p>一类形容词可以直接修饰名词</p>
<p><strong>第二类是不以 い结尾</strong>，做谓语要加です，过去式是加でした</p>
<p>否定形式是＋では　ありません</p>
<p>过去式的否定形式+ では　ありませんでした</p>
<p>修饰名词时： 形容词+な+名词</p>
<p><strong>表达情感的形容词</strong>（如喜欢等）</p>
<p>名词（主体）+ は+名词（对象）+が+形容词+です</p>
<p><strong>比较</strong></p>
<p>名词（主体）+ は+名词（对象）+よい+形容词+です（主体比对象更XX）</p>
<p>名词（主体）+ より+名词（对象）+の　ほうが+形容词+です（对象比主体更XX）</p>
<p>名词（主体）+ は+名词（对象）+ほど+形容词否定形式（对象比主体更XX）</p>
<p>いちばん最高级</p>
<p>提问：名词+と+名词+と+どちらが+形容词+ですか（どちら指多个总称）</p>
<p>回答：名词+の+ほうが，两者相当则用どちらも　～です</p>
<p>问形容词时回答：形容词+ほうが+いいです</p>
<p><strong>形容词连用</strong></p>
<p>形容词て形+形容词 表并列（一类去掉い加くて，二类加で）</p>
<p><strong>形容词表示变化</strong></p>
<p>一类形容词去掉い+く+なります／します（后者是由于主观动作引起的变化）</p>
<p>二类形容词/名词+に+なります／します</p>
<h3 id="量词语法"><a href="#量词语法" class="headerlink" title="量词语法"></a>量词语法</h3><p>量词用在动词前面 </p>
<p>名词+が／を+数量+量词+动词</p>
<p>数量+量词+で+500円（1个时不加）</p>
<p>数量的词后面+くらい 表示大概</p>
<h3 id="名词语法"><a href="#名词语法" class="headerlink" title="名词语法"></a>名词语法</h3><p>名词做谓语的时候加です，过去式是加でした</p>
<p>否定形式是＋では　ありません</p>
<p>过去式的否定形式+ では　ありませんでした</p>
<p>下面两种方式等价，名词1是旧信息，名词2是新信息</p>
<p>名词1+は+名词2+です</p>
<p>名词2+が+名词1+です</p>
<h3 id="礼貌用语"><a href="#礼貌用语" class="headerlink" title="礼貌用语"></a>礼貌用语</h3><p>对应该尊敬的对象或者交往不多的人，会将この人后面的人（ひと）变为方（かた）</p>
<p>ここ、そこ、あそこ、どこ的礼貌用语こちら、そちら、あちら、どちら</p>
<p>なかなか还不错，只能用于对下级</p>
<p>ください（＋ませんか）表达请求</p>
<h3 id="敬体形和简体形"><a href="#敬体形和简体形" class="headerlink" title="敬体形和简体形"></a>敬体形和简体形</h3><p>～ます／～です都是敬体形，用于对长辈或不亲密的人。动词的基本形、ない形、た形都属于简体形。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>敬体形</th>
<th>简体形</th>
</tr>
</thead>
<tbody>
<tr>
<td>现在将来形式</td>
<td>肯定</td>
<td>～ます</td>
<td>う段（基本形）</td>
</tr>
<tr>
<td></td>
<td>否定</td>
<td>～ません</td>
<td>たい（たい形）</td>
</tr>
<tr>
<td>过去形式</td>
<td>肯定</td>
<td>～ました</td>
<td>た（た形）</td>
</tr>
<tr>
<td></td>
<td>否定</td>
<td>～ませんでした</td>
<td>（なかした形）</td>
</tr>
</tbody>
</table>
</div>
<p>一类形容词、二类形容词和名词本身没有敬体形和简体形之分，只有作谓语的时候</p>
<p>一类形容词（い结尾）：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>敬体形</th>
<th>简体形</th>
</tr>
</thead>
<tbody>
<tr>
<td>现在将来形式</td>
<td>肯定</td>
<td>～いです</td>
<td>～い</td>
</tr>
<tr>
<td></td>
<td>否定</td>
<td>～く　ないです</td>
<td>～く　ない</td>
</tr>
<tr>
<td>过去形式</td>
<td>肯定</td>
<td>～かつたです</td>
<td>～かした</td>
</tr>
<tr>
<td></td>
<td>否定</td>
<td>～く　なかしたです</td>
<td>～く　なかした</td>
</tr>
</tbody>
</table>
</div>
<p>二类形容词：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>敬体形</th>
<th>简体形</th>
</tr>
</thead>
<tbody>
<tr>
<td>现在将来形式</td>
<td>肯定</td>
<td>～です</td>
<td>～だ</td>
</tr>
<tr>
<td></td>
<td>否定</td>
<td>～では　ありません</td>
<td>～では　ない</td>
</tr>
<tr>
<td>过去形式</td>
<td>肯定</td>
<td>～でした</td>
<td>～だした</td>
</tr>
<tr>
<td></td>
<td>否定</td>
<td>～では　ありませんでした</td>
<td>～では　なかした</td>
</tr>
</tbody>
</table>
</div>
<p>名词差不多 过去形式的简体后缀改为だつた</p>
<ul>
<li>简体疑问省略敬体的ですか，读升调。</li>
<li>かな和の这两个助词只用在简体形后面</li>
</ul>
<h1 id="拼音"><a href="#拼音" class="headerlink" title="拼音"></a>拼音</h1><p>前鼻音 -ん，后鼻音是-よ/ゆう</p>
<p>翘舌音-ang/-ing/-ao -よう</p>
<p>翘舌音-ong/-ou/-iu/-u -ゆう</p>
<p>zh- ち-</p>
<p>ch-/x- し-</p>
<p>xian せん</p>
<p>shi せい</p>
<p>che/she/xie しや</p>
<p>shang しやん</p>
<p>yuan いん </p>
<p>馆 かん</p>
<p>屋 や</p>
<p>店 てん</p>
<p>v一般变成b</p>
<p>附近 となり</p>
<p>大的 おおきな</p>
<p>考试 しけん（試験）</p>
<p>おみやげ</p>
<p>やすみ</p>
<p>１６４</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/21/ConvexOptimization2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hulieu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hulieu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/21/ConvexOptimization2/" class="post-title-link" itemprop="url">凸优化问题-应用和算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-21 11:04:43" itemprop="dateCreated datePublished" datetime="2020-02-21T11:04:43+08:00">2020-02-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-08 23:03:02" itemprop="dateModified" datetime="2020-04-08T23:03:02+08:00">2020-04-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%8C%AB%E7%88%AA%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">猫爪记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%8C%AB%E7%88%AA%E8%AE%B0/Mathematics/" itemprop="url" rel="index"><span itemprop="name">Mathematics</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="一些应用"><a href="#一些应用" class="headerlink" title="一些应用"></a>一些应用</h3><h5 id="逼近和拟合"><a href="#逼近和拟合" class="headerlink" title="逼近和拟合"></a>逼近和拟合</h5><p>范数逼近</p>
<script type="math/tex; mode=display">
min\:||Ax-b||</script><p>罚函数逼近（$l_p$-范数的一个有用的推广）</p>
<script type="math/tex; mode=display">
min\:\sum\phi(r_i)\\
subject\:to\:r=Ax-b</script><p>对<strong>野值</strong>不敏感的函数称为<strong>鲁棒</strong>的。当限定为凸的罚函数时，最不敏感的就是线性增长函数。例子就是绝对值函数和<strong>Huber罚函数</strong>。</p>
<p>基本问题</p>
<script type="math/tex; mode=display">
min\:||x||\\
subject\:to\:Ax=b</script><p>这是个凸优化问题。</p>
<p>正则化逼近：</p>
<script type="math/tex; mode=display">
min\:||Ax-b||+\gamma||x||</script><p><strong>Tikhonov正则化</strong>：</p>
<script type="math/tex; mode=display">
min\:||Ax-b||_2^2+\delta||x||_2^2</script><p>有解析解</p>
<script type="math/tex; mode=display">
x=(A^TA+\delta I)^{-1}A^Tb</script><p>重构、光滑、去噪声：</p>
<script type="math/tex; mode=display">
min\:(||x-x_{cor}||_2,\phi(x))</script><p><strong>函数拟合与插值</strong>：</p>
<p>考虑一族函数，通过</p>
<script type="math/tex; mode=display">
f(u)=\sum_{i=1}^nx_nf_n(u)</script><p>将x与映射$f:R^M\to R$联系起来。</p>
<p>另外还有插值<strong>条件约束</strong>，或者插值的不等式约束。以及对f的凸约束，比如Lipschitz约束。</p>
<p><strong>基筛选</strong>中寻找较少数目的基函数，使得能够在card(x)很小的情况下进行拟合。称为<strong>稀疏描述</strong>。</p>
<h5 id="统计估计"><a href="#统计估计" class="headerlink" title="统计估计"></a>统计估计</h5><p>最大似然问题可以表述如下</p>
<script type="math/tex; mode=display">
max\:l(x)=log(p_x(y))\\
subject\:to\:x\in C</script><p>Chebyshev界：我们希望给$prob(X\in C)$定界，假设$f(z)\geq 1_C(z)$，那么可以求解凸优化问题</p>
<script type="math/tex; mode=display">
min\:x_o+\sum a_ix_i\\
subject\:to\:f(z)=\sum x_if_i(z)\geq1\:\forall z\in C\\
f(z)=\sum x_if_i(z)\geq0\:\forall z\notin C</script><p>Chernoff界：定义为$prob(X\geq u)\leq inf_{\lambda\geq 0}Ee^{\lambda(X-u)}$同样得到</p>
<script type="math/tex; mode=display">
log(prob(X\in C))\leq\mu+logEe^{\lambda^Tx}</script><p>（这里略过数章…）</p>
<h3 id="无约束优化算法"><a href="#无约束优化算法" class="headerlink" title="无约束优化算法"></a>无约束优化算法</h3><script type="math/tex; mode=display">
min\:f(x)</script><p>其中$f$二次可微凸函数。那么最优点应该满足一阶导数为0，我们需要通过迭代求解。首先需要一个适当的初始点$x_0$，且$f(x_0)$下水平集必须是闭集。（下水平集的形状影响收敛速度）</p>
<p>我们假设目标函数是<strong>强凸</strong>的，即存在m&gt;0，满足$\nabla^2 f(x)\succeq mI$。（好处是梯度足够小的点都可以计算得到近似最优解。）</p>
<p>通用下降方法：确定下降方向；选择步长；修改x。</p>
<p>利用负梯度作为搜索方向是一种自然的选择，称为<strong>梯度下降法</strong>。</p>
<p>我们假设强凸，因此存在$mI\preceq \nabla^2f(x)\preceq MI$，那么可以得到上界</p>
<script type="math/tex; mode=display">
f(t)\leq f(x)-t||\nabla f(x)||_2^2+\frac{Mt^2}{2}||\nabla f(x)||_2^2</script><p>采用<strong>精确直线搜索</strong>的话，右边的最小值为$f(x)-(1/2M)||\nabla f(x)||_2^2$，所以</p>
<script type="math/tex; mode=display">
f(x^+)-p^*\leq (1-m/M)(f(x)-p^*)</script><p>因此是<strong>线性收敛</strong>的。事实上，即使是<strong>回溯直线搜索</strong>，满足$0\leq t\leq 1/M$，也可以达到<strong>线性收敛</strong>。</p>
<p><strong>最速下降方法</strong>是通过定义<strong>规范化的最速下降方向</strong>，即找到</p>
<script type="math/tex; mode=display">
\Delta x_{nsd}=argmin\{\nabla f(x)^Tv|||v||=1\}</script><p>上面范数取Euclid范数时即为梯度下降，采用二次范数$||·||_P$时，$\Delta x_{nsd}=-(\nabla f(x)^TP^{-1}\nabla f(x))^{-1/2}P^{-1}\nabla f(x)$。</p>
<p><strong>Newton方法</strong>：$\Delta x_{nt}=-\nabla^2 f(x)^{-1}\nabla f(x)$，这其实等价于Hessian矩阵定义的二次范数下的最速下降方法</p>
<p>可以表明，Newton方法的迭代过程分为两个阶段，第一阶段称为<strong>阻尼Newton阶段</strong>，步长t&lt;1，线性收敛速度，第二阶段为<strong>纯Newton阶段</strong>，步长t=1，二次收敛速度。</p>
<p><strong>自和谐函数</strong>的Newton方法分析不依赖未知常数（强凸性常数、李普西茨常数），且具有仿射不变性。</p>
<p>定义凸函数$f:R\to R$满足对所有x</p>
<script type="math/tex; mode=display">
|f'''(x)|\leq 2f''(x)^{3/2}</script><p>就是<strong>自和谐</strong>的。常数2可以被任何常数k替代。这个条件可以写成</p>
<script type="math/tex; mode=display">
|\frac{d}{dt}(f''(t)^{-1/2})|\leq1</script><p>由此得到$f’’(t)$的上下界</p>
<script type="math/tex; mode=display">
\frac{f''(0)}{(1+tf''(0)^{1/2})^2}\leq f''(t)\leq \frac{f''(0)}{(1-tf''(0)^{1/2})^2}</script><p>由此可以得到次优性的界。</p>
<h3 id="等式约束优化"><a href="#等式约束优化" class="headerlink" title="等式约束优化"></a>等式约束优化</h3><script type="math/tex; mode=display">
\min f(x)\\s.t. Ax=b</script><p>考虑二阶Taylor近似</p>
<script type="math/tex; mode=display">
\min f(x+v)=f(x)+\nabla f(x)^Tv+(1/2)v^T\nabla^2f(x)v\\
s.t.A(x+v)=b</script><p><strong>Newton方向</strong>$\Delta x_{nt}$由以下方程确定</p>
<script type="math/tex; mode=display">
\begin{pmatrix}\nabla^2f(x)&A^T\\A&0\end{pmatrix}\begin{pmatrix}\Delta x_{nt}\\w\end{pmatrix}=\begin{pmatrix}-\nabla f(x)\\0\end{pmatrix}</script><p>对于<strong>不可行初始点</strong>的newton方向，</p>
<script type="math/tex; mode=display">
\begin{pmatrix}\nabla^2f(x)&A^T\\A&0\end{pmatrix}\begin{pmatrix}\Delta x_{nt}\\w\end{pmatrix}=\begin{pmatrix}-\nabla f(x)\\b-Ax\end{pmatrix}</script><h3 id="线性规划问题的解法"><a href="#线性规划问题的解法" class="headerlink" title="线性规划问题的解法"></a>线性规划问题的解法</h3><p><strong>Primal单纯形法</strong></p>
<p>对于线性规划</p>
<script type="math/tex; mode=display">
min\:c^Tx\\
s.t.\:Ax=b\\
x\geq 0</script><p>和对偶问题</p>
<script type="math/tex; mode=display">
max\:b^Ty\\
s.t.\:A^Ty+s=c\\
s\geq 0</script><p>得到KKT条件</p>
<script type="math/tex; mode=display">
Ax=b,x\geq 0\\
A^Ty+s=c,s\geq 0\\
x_is_i=0</script><p>Primal单纯形法得到</p>
<script type="math/tex; mode=display">
x_B=B^{-1}b\geq 0,x_N=0\\
y=B^{-T}c_B\\
s_B=c_B-B^Ty=0,s_N=c_N-N^Ty？？0</script><p>（B是一个基，N是自由基）然后判断$s_N$和0的大小关系，决定是否停止迭代。如果$s_j\geq 0$那么x是最优解，否则可以找到q，$s_q&lt;0$。那么就找到$p\in B$移出基。</p>
<p>令$u=B^{-1}A_q$，那么$x_B^+=x_B-ux_q^+$。如果$u\leq 0$则原问题无界；否则找到$u_k&gt;0$，就可以找到$x_q^+$和$p$满足$ x_B^+\geq 0$和$x_p^+=0，确定</p>
<script type="math/tex; mode=display">
p=argmin\frac{x_B(i)}{u_i}</script><p><u>单纯形法工业级应用还需要解决很多问题，比如快速求逆、防止循环迭代等等。</u></p>
<p><strong>对偶单纯形法</strong></p>
<script type="math/tex; mode=display">
x_B=B^{-1}b？？0,x_N=0\\
y=B^{-T}c_B\\
s_B=c_B-B^Ty=0,s_N=c_N-N^Ty\geq 0</script><p> 如果$x_B\geq 0$，则达到最优，否则找到$q\in B$使得$x_q&lt;0$退出基，选择r加入基，$s_r^+=0$。然后进行更新：</p>
<script type="math/tex; mode=display">
s_B^+=s_b+ae_q\\
y^+=y+av(e_q=-B^Tv)</script><p><u>对偶单纯形法和单纯形法有时候速度差距很大。</u></p>
<p><strong>内点法</strong></p>
<p>$(x,y,s)$为当前估计，$(\Delta x,\Delta y,\Delta s)$是搜索方向，定义$\mu=\sum x_is_i/n$。所以要找到</p>
<script type="math/tex; mode=display">
A(x+\Delta x)=b\\
A^T(y+\Delta y)+s+\Delta s=c\\
(x_i+\Delta x_i)(s_i+\Delta s_i)=\sigma_\mu</script><p>舍弃二阶小量得到</p>
<script type="math/tex; mode=display">
A\Delta x=r_p:=b-Ax\\
A^T\Delta y+\Delta s=r_d:=c-A^Ty-s\\
x_i\Delta s_i+\Delta x_is_i=(r_c)_i:=\sigma_\mu-x_is_i</script><p>写成矩阵形式如下，令$L_x=Diag(x)$，$L_s=Diag(s)$</p>
<script type="math/tex; mode=display">
\begin{pmatrix}A&0&0\\
0&A^T&I\\
L_s&0&L_x\end{pmatrix}
\begin{pmatrix}\Delta x\\
\Delta y\\
\Delta s\end{pmatrix}
=
\begin{pmatrix}r_p\\
r_d\\
r_c
\end{pmatrix}</script><p>如果A满秩，$AL_s^{-1}L_xA^T$是对称正定的，可以解得到</p>
<script type="math/tex; mode=display">
\Delta y=(AL_s^{-1}L_xA^T)^{-1}(r_p+AL_s^{-1}(L_xr_d-r_c))\\
\Delta s = r_d-A^T\Delta y\\
\Delta x = -L_s^{-1}(L_x\Delta s-r_c)</script><p>然后进行步长搜索，保证$(x^{k+1},s^{k+1})&gt;0$。</p>
<p><u>步长搜索用Central Path，具体定义如下：</u> $C=\{(x_\tau,y_\tau,s_\tau|\tau&gt;0\}$满足</p>
<script type="math/tex; mode=display">
Ax_\tau=b,x_\tau>0\\
A^Ty_\tau+s_\tau=c,s_\tau>0\\
(x_\tau)_i(s_\tau)_i=\tau</script><p>Central Path neighborhoods是对$\theta,\gamma\in[0,1)$：</p>
<script type="math/tex; mode=display">
N_2(\theta)=\{(x,y,s)|||L_xL_se-\mu e||_2\leq\theta\mu\}\\
N_{-\infty}(\gamma)=\{(x,y,s)|x_is_i\geq\gamma\mu\}</script><p>一般而言$\theta=0.5$，$\gamma=10^{-3}$。</p>
<p>Path-Following：设定步长$\alpha_k$为最大的满足$(x^{k+1},y^{k+1},s^{k+1})\in N_{-\infty}(\gamma)$的值。那么$|\Delta x\cdot\Delta s|\leq 2^{-3/2}(1+1/\gamma)n\mu$，更新</p>
<script type="math/tex; mode=display">
\mu_{k+1}\leq(1-\delta/n)\mu_k,\delta=2^{3/2}\gamma\frac{1-\gamma}{1+\gamma}\sigma(1-\sigma)</script><p>那么如果$(x^0,y^0,s^0)\in N_{-\infty}(\gamma)$，存在$K=O(nln(1/\epsilon))$使得$\mu_k\leq\epsilon\mu_0$</p>
<p><u>内点法是很少见的多项式时间算法</u></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Hulieu"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Hulieu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">22</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/husimplicity/husimplicity.github.io" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;husimplicity&#x2F;husimplicity.github.io" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:tulongzikun@126.com" title="E-Mail → mailto:tulongzikun@126.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>
      <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1364161141&auto=1&height=66"></iframe>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hulieu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
